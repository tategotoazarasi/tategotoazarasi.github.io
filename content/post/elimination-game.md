---
title: "LeetCode 390. 消除游戏"
date: 2022-01-02T17:04:49+08:00
draft: false
tags: ["leetcode", "中等", "数学"]
math: true
---

给定一个从 1 到 n 排序的整数列表。  
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。  
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。  
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。  
返回长度为 n 的列表中，最后剩下的数字。

<!--more-->

**示例：**

**输入:**
n = 9,
<u>1</u> 2 <u>3</u> 4 <u>5</u> 6 <u>7</u> 8 <u>9</u>
2 <u>4</u> 6 <u>8</u>
<u>2</u> 6
6

**输出:**
6

## 题解

这道题目长得非常像约瑟夫环，但不是约瑟夫环。

因此直接用一个数组表示所有数字，再依次删除模拟整个过程的方法是不行的，我们需要考虑使用某种精妙的方法来表示每一回合的数。

> n = 9  
> arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]  
> arr = [2, 4, 6, 8]  
> arr = [2, 6]  
> arr = [6]

通过观察用例，我们可以得到以下规律：

1. 经历的回合数应该是 ⌊log2​n⌋+1

2. **arr 数组永远是一个等差数列**

3. arr 数组的数目，每次减少一半（向下取整）

4. 公差每次翻倍

其中，第二条规律是最令人兴奋的，因为它可以帮助我们使用一些简单的参数就可以表示所有剩余的数字。通过回忆高中数学的知识，我们知道一个等差数列可以由 a0​（首项）,d（公差）,n（数列元素个数）三个参数来定义。

综合以上规律，我们知道每次删除后，以上三个参数每次应该这样变化：

- d→2d

- n→21​n

- a0​→a0​ 或 a0​+d

大体上来说这道题目就是这样，其它细节可以看代码。

**如何决定**a0​ 的变化

答：当删除数字时，存在以下四种情况：

1. 从左向右删除，总共有奇数个数字（第一位要删掉，最后一位要删掉）

2. 从左向右删除，总共有偶数个数字（第一位要删掉，最后一位不用删掉）

3. 从右向左删除，总共有奇数个数字（第一位要删掉，最后一位要删掉）

4. 从右向左删除，总共有偶数个数字（第一位不用删掉，最后一位要删掉）

可以发现，若 a0​→a0​，则必然为情况 4；其余情况都为 a0​→a0​+d

```cpp
class Solution {
    public:
        int lastRemaining(int n) {
            int num_amount = n;
            int loop_cnt = 0;
            int a0 = 1, d = 1;
            while (num_amount != 1) {
                // 奇数个数字
                if (num_amount % 2 == 1) {
                    a0 = a0 + d;
                }
                // 偶数个数字
                else if (num_amount % 2 == 0) {
                    bool left_to_right = (loop_cnt % 2 == 0);
                    if (left_to_right) {
                        a0 = a0 + d;
                    } else
                        a0 = a0;
                }
                loop_cnt++;
                d *= 2;
                num_amount /= 2;
            }
            return a0;
        }
};
```
