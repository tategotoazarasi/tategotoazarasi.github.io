---
title: "LeetCode 5983. 同时运行 N 台电脑的最长时间"
date: 2022-01-16T12:20:00+08:00
draft: false
tags: ["leetcode", "困难", "二分"]
math: true
---

你有  `n`  台电脑。给你整数  `n`  和一个下标从 **0**  开始的整数数组  `batteries` ，其中第  `i`  个电池可以让一台电脑 **运行** `batteries[i]`  分钟。你想使用这些电池让  **全部** `n`  台电脑 **同时**  运行。

一开始，你可以给每台电脑连接 **至多一个电池** 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 **任意次** 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。

注意，你不能给电池充电。

请你返回你可以让 `n`  台电脑同时运行的 **最长**  分钟数。

<!--more-->

**示例 1：**

![](https://tategotoazarasi.github.io/images/leetcode5983_example1-fit.png)

> **输入：** n = 2, batteries = [3,3,3]
>
> **输出：** 4
>
> **解释：**
> 一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。
> 2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。
> 在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。
> 在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。
> 我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。

**示例 2：**

![](https://tategotoazarasi.github.io/images/leetcode5983_example2.png)

> **输入：** n = 2, batteries = [1,1,1,1]
>
> **输出：** 2
>
> **解释：**
> 一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。
> 一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。
> 1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。
> 我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。

**提示：**

- \\(1 <= n <= batteries.length <= 10^5\\)
- \\(1 <= batteries[i] <= 10^9\\)
- 对于一个给定的运行时间，你能确定是否有可能同时运行所有 n 台计算机吗？
- 试着用二分搜索来找到最大的运行时间

## 题解

假设所有电脑同时运行 t 分钟。那么，因为一个电池只能给一台电脑供电，因此在这 t 分钟的时间里，一个电池最多有 t 分钟的供电时间。我们只需要统计所有电池的可供电时间总和 \\( \displaystyle{S = \sum_i{\min(t, batteries_i)}} \\) ，然后检查它们是否可以给 n 台电脑供电即可（即 \\( \displaystyle{\frac{S}{t} \ge n} \\)）。

为什么这个解法是正确的？实际上，如果 \\( \displaystyle{\frac{S}{t} \ge n} \\) ，那么我们总可以找出一种符合要求的方案来支持 n 台电脑的运行。

比如题目示例 1，n=2,batteries=[3,3,3]，持续运行 4 分钟。那么，首先电池 0 供电电脑 0，供电 3 分钟，然后让电池 1 继续供电 1 分钟，然后电池 1 剩下的 2 格电量用于供电电脑 1；最后电池 2 补足剩下的 2 格电量给电脑 1 ，如下图所示。  
![image.png](https://tategotoazarasi.github.io/images/1642306078-hZaBUg-image.png)

可以发现，对于这类情况，我们只需要 按顺序 安排电池即可，一定不会发生时间冲突。

```cpp
class Solution {
public:
    long long maxRunTime(int n, vector<int>& batteries) {
        auto check = [&](long long t) {
            long long sum = 0;
            for(int i : batteries) sum += min(t, (long long)i);
            return sum / t >= n;
        };

        long long l = 1, r = 1e16;
        while(l < r) {
            long long m = (l + r) / 2;
            if(check(m)) {
                l = m + 1;
            }
            else {
                r = m;
            }
        }
        return l - 1;
    }
};
```
