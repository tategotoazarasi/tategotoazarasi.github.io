[{"content":"I was tinkering with Breezy Weather, the open-source weather app, the other day. It\u0026rsquo;s got a decent collection of widgets, but I felt like something was missing – one of those \u0026ldquo;kitchen sink\u0026rdquo; widgets that just throws everything you need onto your home screen. You know, the current time, what the weather\u0026rsquo;s doing right now, what it\u0026rsquo;s gonna do in the next few hours, AND the outlook for the next few days. I got tired of either opening the app or juggling multiple widgets to get the full picture. Naturally, the itch to code kicked in, and I decided to build it myself. Let\u0026rsquo;s call it the ClockDayHourWeekWidget.\nThis blog post is basically my development log. I\u0026rsquo;m jotting down the thought process, the steps I took, and a few bumps I hit along the way. It\u0026rsquo;s mainly for my future self, but hopefully, it might be useful for anyone else interested in Android widget development or maybe even contributing to Breezy Weather. The style\u0026rsquo;s going to be pretty casual – think of it as dev notes – but I\u0026rsquo;ll make sure to include the key technical bits and enough code snippets so you can understand what\u0026rsquo;s going on and potentially replicate it.\nThe Goal:\nCreate a new Android App Widget that displays:\nCurrent Time: Just like your standard clock. Current Weather: Icon, location name, current temperature. Hourly Forecast: A glimpse of the weather (icon, time, temp) for the next few hours (e.g., the next 5). Daily Forecast: The usual suspects (icon, day of the week, high/low temp) for the next few days (e.g., the next 5). Configurability: Following the Breezy Weather pattern, allow users to customize background style, transparency, text color, text size, clock font, etc., via a configuration screen. Alright, goal set. Let\u0026rsquo;s dive in!\n1. The Big Picture: Standing on the Shoulders of Giants Thankfully, Breezy Weather has a pretty well-defined structure, especially for adding new widgets. Looking at existing files like WidgetClockDayWeekProvider.kt and HourlyTrendWidgetIMP.kt, the pattern becomes clear. To add a new widget, you generally need these pieces:\nAppWidgetProvider (e.g., XxxWidgetProvider.kt): This is the widget\u0026rsquo;s entry point. It extends AppWidgetProvider and receives system broadcasts, most importantly onUpdate. Its main job is to kick off the real work of loading data and updating the view. Widget Implementation (e.g., XxxWidgetIMP.kt): Often an object (Kotlin singleton) inheriting from AbstractRemoteViewsPresenter. This is where the magic happens: fetching data, loading user configuration, building the RemoteViews object (which defines the widget\u0026rsquo;s UI), and handling click intents. Configuration Activity (e.g., XxxWidgetConfigActivity.kt): An Activity extending AbstractWidgetConfigActivity. It pops up when the user adds the widget, allowing them to customize its appearance ( background, colors, etc.). It also needs to show a live preview of the settings. XML Layout Files (widget_xxx.xml, widget_xxx_card.xml): These define the static structure of the widget\u0026rsquo;s UI. Typically, there\u0026rsquo;s a version without a background card and one with it. Widget Definition XML (xml/widget_xxx.xml, xml/v28/widget_xxx.xml): This metadata file tells the Android system about the widget – its minimum size, preview image, the configuration activity to launch, update frequency ( usually 0 here, as updates are triggered programmatically), etc. The v28 version usually adds widgetFeatures=\u0026quot;reconfigurable\u0026quot;. Resource Updates: You\u0026rsquo;ll need to touch several resource files: dimens.xml: Possibly define new dimensions if needed. keys.xml: Add a unique SharedPreferences key for storing the widget\u0026rsquo;s settings. strings.xml: Add the user-visible name for the widget. AndroidManifest.xml: Register the new Provider and Config Activity. Widgets.kt: Add unique request codes for PendingIntents. Basically, follow this recipe, create or modify each part, and voilà – a new widget is born. For our ClockDayHourWeekWidget, the existing ClockDayWeekWidget is a great starting point. It already handles the clock, date, current weather, and daily forecast. Our main task is to surgically insert the \u0026ldquo;hourly forecast\u0026rdquo; section into it.\n2. Getting Our Hands Dirty: Creating the Components Let\u0026rsquo;s build this thing piece by piece.\n1. Widget Provider (ClockDayHourWeekWidgetProvider.kt) This one\u0026rsquo;s relatively straightforward. We can copy WidgetClockDayWeekProvider.kt and make a few tweaks:\nRename the class to ClockDayHourWeekWidgetProvider. Inside the onUpdate method, make sure it calls the updateWidgetView method of our new implementation class, ClockDayHourWeekWidgetIMP. Key Point: When calling weatherRepository.getWeatherByLocationId, we absolutely must set both withDaily = true and withHourly = true. Our widget needs both sets of forecast data. // src/main/java/org/breezyweather/background/receiver/widget/ClockDayHourWeekWidgetProvider.kt package org.breezyweather.background.receiver.widget // ... other imports ... import org.breezyweather.remoteviews.presenters.ClockDayHourWeekWidgetIMP // Reference the new IMP import javax.inject.Inject @AndroidEntryPoint // Hilt annotation is crucial class ClockDayHourWeekWidgetProvider : AppWidgetProvider() { @Inject lateinit var locationRepository: LocationRepository @Inject lateinit var weatherRepository: WeatherRepository @OptIn(DelicateCoroutinesApi::class) // Note: Using GlobalScope here, a common but not ideal practice in Providers override fun onUpdate( context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray, ) { super.onUpdate(context, appWidgetManager, appWidgetIds) // Check if any widget of this type is still in use if (ClockDayHourWeekWidgetIMP.isInUse(context)) { // Launch a coroutine on the IO dispatcher to fetch data GlobalScope.launch(Dispatchers.IO) { // Get the first location (without parameters) val location = locationRepository.getFirstLocation(withParameters = false) // Call the IMP to update the view ClockDayHourWeekWidgetIMP.updateWidgetView( context, location?.copy( // Use copy to create a new object and fill in the weather weather = weatherRepository.getWeatherByLocationId( location.formattedId, withDaily = true, // Needed for daily data (isDaylight, daily forecast) withHourly = true, // !! Must be true, we need hourly data !! withMinutely = false, withAlerts = false ) ) ) } } } } A quick note on GlobalScope.launch(Dispatchers.IO): In the onUpdate method of an AppWidgetProvider, which runs on the main thread and has a short lifespan, this is a fairly common way to handle potentially long-running operations like network requests or database access. While GlobalScope isn\u0026rsquo;t generally recommended (its coroutines are tied to the application\u0026rsquo;s lifecycle and harder to manage), it\u0026rsquo;s a simpler solution in this specific context. More robust approaches might involve goAsync() paired with a Hilt-injected CoroutineScope or even WorkManager, but sticking to the existing pattern keeps things simpler here.\n2. Widget Implementation (ClockDayHourWeekWidgetIMP.kt) This is the beast. Most of the UI construction logic lives here. Again, copying ClockDayWeekWidgetIMP.kt gives us a solid foundation to build upon.\nIts Main Responsibilities:\nupdateWidgetView: Called by the Provider. Gets the config, calls getRemoteViews to build the UI, and finally updates the widget via AppWidgetManager. getRemoteViews: The core method. Takes Context, Location data, and various config parameters, returning a fully constructed RemoteViews object. isInUse: Checks if any instances of this specific widget type exist. setOnClickPendingIntent: Sets up the actions (like opening the app or calendar) when users click on different parts of the widget. Breaking Down getRemoteViews:\nGet Config \u0026amp; Colors: Use getWidgetConfig to load saved settings and initialize WidgetColor to handle color logic based on config and day/night status.\nChoose Layout: Based on WidgetColor\u0026rsquo;s judgment (whether to show a card background), load either R.layout.widget_clock_day_hour_week or R.layout.widget_clock_day_hour_week_card.\nPrepare Data: Extract weather data from the Location object, get instances of SettingsManager, ResourcesProviderFactory, etc.\nPopulate Sections (using views.setXXX methods):\nClock: Set the TextClock timezone (setTimeZone). Control the visibility (setViewVisibility) of the different font-styled TextClock views based on the clockFont config. Date: Set the TextClock timezone and date format (setCharSequence with format12Hour/format24Hour). Current Weather: Icon: Get the icon URI using ResourceHelper.getWidgetNotificationIconUri and set it with setImageViewUri. Handle potential nulls (weather.current or weatherCode) by hiding the view ( setViewVisibility(View.INVISIBLE)). Alternate Calendar: Set the TextView text based on CalendarHelper settings and the hideAlternateCalendar config. Place \u0026amp; Current Temp: Concatenate the strings and set the text for the corresponding TextView. Hourly Forecast (The New Bit): This is the core addition. We need the LinearLayout container designated for the hourly forecast in our layout. Define an array of IDs to easily access the time TextView, temperature TextView, and weather ImageView for each hourly item. Get the weather.nextHourlyForecast list, limiting it to a maximum number (e.g., MAX_HOURLY_ITEMS = 5). Loop Through Data: Iterate min(MAX_HOURLY_ITEMS, weather.nextHourlyForecast.size) times. Get the HourlyForecast object for the current hour. Set the time TextView\u0026rsquo;s text (using hourly.date.getHour(location, context)). Set the temperature TextView\u0026rsquo;s text (using temperatureUnit.getShortValueText), handling potential nulls. Set the weather ImageView\u0026rsquo;s icon (using ResourceHelper.getWidgetNotificationIconUri), again handling potential nulls for weatherCode and using hourly.isDaylight to pick the correct day/night icon. Control Visibility: Ensure this forecast item is visible (setVisibility(View.VISIBLE)). Handle Excess Views: For any placeholder views in the layout beyond the available data (e.g., layout has 5 slots, API gives 3 hours), hide them (setVisibility(View.GONE)). It\u0026rsquo;s best to hide the entire parent LinearLayout or RelativeLayout for that item. Container Visibility: If there\u0026rsquo;s no hourly data at all (hourlyItemCount == 0), hide the entire hourly forecast container LinearLayout (widget_clock_day_hour_week_hourly_container). // Inside ClockDayHourWeekWidgetIMP.kt -\u0026gt; getRemoteViews() (Hourly Forecast Snippet) // --- Hourly Forecast --- val hourlyIds = arrayOf( // ... (Define 2D array of TextView and ImageView IDs) ... arrayOf(R.id.widget_clock_day_hour_week_hour_time_1, R.id.widget_clock_day_hour_week_hour_temp_1, R.id.widget_clock_day_hour_week_hour_icon_1), // ... other hours ... ) val hourlyItemCount = min(MAX_HOURLY_ITEMS, weather.nextHourlyForecast.size) hourlyIds.forEachIndexed { i, hourlyId -\u0026gt; if (i \u0026lt; hourlyItemCount) { val hourly = weather.nextHourlyForecast[i] views.setTextViewText(hourlyId[0], hourly.date.getHour(location, context)) // Set time views.setTextViewText( hourlyId[1], // Set temperature hourly.temperature?.temperature?.let { temperatureUnit.getShortValueText(context, it) } ?: \u0026#34;...\u0026#34; ) hourly.weatherCode?.let { // Set icon views.setViewVisibility(hourlyId[2], View.VISIBLE) views.setImageViewUri( hourlyId[2], ResourceHelper.getWidgetNotificationIconUri( provider, it, hourly.isDaylight ?: dayTime, minimalIcon, color.minimalIconColor ) ) } ?: views.setViewVisibility(hourlyId[2], View.INVISIBLE) // Make sure the parent item container is visible (assuming parent ID is widget_clock_day_hour_week_hour_item_x) val parentId = context.resources.getIdentifier(\u0026#34;widget_clock_day_hour_week_hour_item_${i + 1}\u0026#34;, \u0026#34;id\u0026#34;, context.packageName) if (parentId != 0) views.setInt(parentId, \u0026#34;setVisibility\u0026#34;, View.VISIBLE) } else { // Hide unused items (preferably the parent container) val parentId = context.resources.getIdentifier(\u0026#34;widget_clock_day_hour_week_hour_item_${i + 1}\u0026#34;, \u0026#34;id\u0026#34;, context.packageName) if (parentId != 0) views.setInt(parentId, \u0026#34;setVisibility\u0026#34;, View.GONE) // Fallback: If parent ID isn\u0026#39;t found, hide individual elements // else { views.setInt(hourlyId[0], \u0026#34;setVisibility\u0026#34;, View.GONE); ... } } } // If no hourly data, hide the entire hourly section views.setViewVisibility( R.id.widget_clock_day_hour_week_hourly_container, if (hourlyItemCount \u0026gt; 0) View.VISIBLE else View.GONE ) Daily Forecast: This logic is very similar to the original ClockDayWeekWidgetIMP, just make sure to use the new IDs from our modified layout. It also needs the same treatment for handling insufficient data (hiding extra views) and hiding the entire daily container if no data exists. Apply Styles: Text Color: If a specific text color is configured (textColor != Color.TRANSPARENT), loop through all relevant TextViews (including the newly added hourly ones!) and use setTextColor. Text Size: If a non-100% size is set (textSize != 100), calculate the scale, get base dimensions ( R.dimen.xxx), multiply by scale, and then loop through all relevant TextViews, setting the size with setTextViewTextSize(TypedValue.COMPLEX_UNIT_PX, size). Remember the new hourly TextViews! You might need different base dimensions for different parts (clock vs. content vs. hourly time vs. daily day name). Clock Font: Use a when statement on clockFont to set the visibility of the appropriate TextClock container. Card Background: If color.showCard is true, set the background drawable (setImageViewResource) and its alpha (setInt(id, \u0026quot;setImageAlpha\u0026quot;, alpha)). Set Click Actions: Call the setOnClickPendingIntent method, passing the context, views, and location.\nsetOnClickPendingIntent:\nThis method wires up the clickable elements (weather icon, date, clock, daily icons) to perform actions. It creates PendingIntents and binds them using views.setOnClickPendingIntent(viewId, pendingIntent).\nThe crucial part is giving each PendingIntent a unique Request Code. We define these constants centrally in Widgets.kt. Breezy Weather provides helpers for common intents: getWeatherPendingIntent: Opens the main app screen. getDailyForecastPendingIntent: Opens the app scrolled to the specific forecast day. getAlarmPendingIntent: Tries to open the system alarm/clock app. getCalendarPendingIntent: Tries to open the system calendar app. We need to define a new block of non-conflicting request codes in Widgets.kt for ClockDayHourWeekWidget (e.g., starting with 14x). // Inside ClockDayHourWeekWidgetIMP.kt private fun setOnClickPendingIntent(context: Context, views: RemoteViews, location: Location) { // Click main weather area -\u0026gt; Open App views.setOnClickPendingIntent( R.id.widget_clock_day_hour_week_weather, // ID of the main content container getWeatherPendingIntent(context, location, Widgets.CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_WEATHER) // Use new code ) // Click daily forecast icon -\u0026gt; Open App to that day val todayIndex = location.weather?.todayIndex ?: 0 views.setOnClickPendingIntent( R.id.widget_clock_day_hour_week_day_icon_1, // Day 1 icon ID getDailyForecastPendingIntent(context, location, todayIndex, Widgets.CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_1) // New code ) // ... Set similar PendingIntents for day_icon_2 to day_icon_5 ... // Click clock -\u0026gt; Open Alarm/Clock App views.setOnClickPendingIntent( R.id.widget_clock_day_hour_week_clock_light, // Light font clock ID getAlarmPendingIntent(context, Widgets.CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CLOCK_LIGHT) // New code ) // ... Set similar PendingIntents for normal and black font clocks ... // Click date -\u0026gt; Open Calendar App views.setOnClickPendingIntent( R.id.widget_clock_day_hour_week_title, // Date TextClock ID getCalendarPendingIntent(context, Widgets.CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CALENDAR) // New code ) // Clicks for hourly forecast items could be added here if needed, // but the current design doesn\u0026#39;t seem to require them. /* views.setOnClickPendingIntent( R.id.widget_clock_day_hour_week_hour_icon_1, // getHourlyForecastPendingIntent(...) // Would need a helper and codes ) */ } 3. Configuration Activity (ClockDayHourWeekWidgetConfigActivity.kt) This activity lets users tweak the widget when they first add it. Copying ClockDayWeekWidgetConfigActivity.kt is the path of least resistance.\nModifications Needed:\nRename the class to ClockDayHourWeekWidgetConfigActivity. initLocations(): Ensure withHourly = true when fetching weather data, just like in the Provider. Even if the preview doesn\u0026rsquo;t show hourly details, the underlying data might be needed for other logic (like determining isDaylight accurately for icons if the current condition isn\u0026rsquo;t available). // Inside ClockDayHourWeekWidgetConfigActivity.kt override suspend fun initLocations() { val location = locationRepository.getFirstLocation(withParameters = false) locationNow = location?.copy( weather = weatherRepository.getWeatherByLocationId( location.formattedId, withDaily = true, withHourly = true, // Ensure hourly data is fetched withMinutely = false, withAlerts = false ) ) } initData(): Set default configuration values, like the initial clock font (clockFontValueNow). The base class AbstractWidgetConfigActivity handles defaults for card style, color, alpha, etc. initView(): Control which configuration options are visible on the screen. For this widget, options for card style, alpha, text color, text size, clock font, and hiding the alternate calendar should all be visible. updateWidgetView(): When the user changes a setting in the config UI, this method calls ClockDayHourWeekWidgetIMP.updateWidgetView to immediately update the widget instance on the home screen (live preview effect). remoteViews (getter): This property provides the RemoteViews for the preview area within the config screen. It must call ClockDayHourWeekWidgetIMP.getRemoteViews, passing the current selections from the config UI ( cardStyleValueNow, cardAlpha, textColorValueNow, etc.). configStoreName (getter): Returns the unique SharedPreferences key used to store this widget\u0026rsquo;s settings. Must be unique! We\u0026rsquo;ll define this key in keys.xml. // Inside ClockDayHourWeekWidgetConfigActivity.kt override val configStoreName: String get() { // Return the new key we define in keys.xml return getString(R.string.sp_widget_clock_day_hour_week_setting) } 4. XML Layout Files We need two layout files: layout/widget_clock_day_hour_week.xml (no background) and layout/widget_clock_day_hour_week_card.xml (with background).\nCopy widget_clock_day_week.xml and widget_clock_day_week_card.xml and then modify them.\nKey Modifications:\nRename Root Layout and ALL View IDs: To prevent clashes, systematically rename all IDs. A good practice is to replace widget_clock_day_week_ with widget_clock_day_hour_week_. Add Hourly Forecast Section: Between the \u0026ldquo;Date/Place/Current Temp\u0026rdquo; section and the \u0026ldquo;Daily Forecast\u0026rdquo; section, insert a new LinearLayout. Give it the ID android:id=\u0026quot;@+id/widget_clock_day_hour_week_hourly_container\u0026quot;. Set its orientation=\u0026quot;horizontal\u0026quot;. Inside it, place 5 child LinearLayouts (or RelativeLayouts), each representing one hour\u0026rsquo;s forecast. Set each hourly item\u0026rsquo;s LinearLayout to orientation=\u0026quot;vertical\u0026quot;, layout_width=\u0026quot;0dp\u0026quot;, layout_height=\u0026quot;wrap_content\u0026quot;, layout_weight=\u0026quot;1\u0026quot;, gravity=\u0026quot;center_horizontal\u0026quot;. Give them unique IDs like widget_clock_day_hour_week_hour_item_1 through item_5. Inside each hourly item LinearLayout, place the three necessary views: A TextView for the time (widget_clock_day_hour_week_hour_time_x). An ImageView for the weather icon (widget_clock_day_hour_week_hour_icon_x). A TextView for the temperature (widget_clock_day_hour_week_hour_temp_x). Use dimensions from dimens.xml, like @dimen/widget_time_text_size for the time, @dimen/widget_content_text_size for the temp, and @dimen/widget_little_weather_icon_size for the icon. Modify Daily Forecast IDs: Rename the original daily forecast IDs (like widget_clock_day_week_week_x, _temp_x, _icon_x) to widget_clock_day_hour_week_day_week_x, _day_temp_x, _day_icon_x. Also, give the parent LinearLayout container for the daily forecast an ID, like widget_clock_day_hour_week_daily_container. widget_clock_day_hour_week_card.xml: This file is essentially a copy of widget_clock_day_hour_week.xml, but with an ImageView added as the first child inside the root RelativeLayout. This ImageView will display the card background; give it the ID widget_clock_day_hour_week_card. \u0026lt;!-- layout/widget_clock_day_hour_week.xml (Snippet showing new hourly structure) --\u0026gt; \u0026lt;RelativeLayout ...\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/widget_clock_day_hour_week_weather\u0026#34; ...\u0026gt; \u0026lt;!-- ... (Clock, Date, Current Weather sections - IDs modified) ... --\u0026gt; \u0026lt;!-- Hourly Forecast --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/widget_clock_day_hour_week_hourly_container\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;@dimen/little_margin\u0026#34; android:layout_marginBottom=\u0026#34;@dimen/little_margin\u0026#34; android:baselineAligned=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;!-- Hour 1 --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/widget_clock_day_hour_week_hour_item_1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center_horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/widget_clock_day_hour_week_hour_time_1\u0026#34; android:textSize=\u0026#34;@dimen/widget_time_text_size\u0026#34; ... /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/widget_clock_day_hour_week_hour_icon_1\u0026#34; android:layout_width=\u0026#34;@dimen/widget_little_weather_icon_size\u0026#34; android:layout_height=\u0026#34;@dimen/widget_little_weather_icon_size\u0026#34; ... /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/widget_clock_day_hour_week_hour_temp_1\u0026#34; android:textSize=\u0026#34;@dimen/widget_content_text_size\u0026#34; ... /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- Hour 2 to 5 (Similar structure) --\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- Daily Forecast --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/widget_clock_day_hour_week_daily_container\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; ... \u0026gt; \u0026lt;!-- Day 1 --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/widget_clock_day_hour_week_day_item_1\u0026#34; ...\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/widget_clock_day_hour_week_day_week_1\u0026#34; ... /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/widget_clock_day_hour_week_day_icon_1\u0026#34; ... /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/widget_clock_day_hour_week_day_temp_1\u0026#34; ... /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- Day 2 to 5 (Similar structure, IDs modified) --\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 5. Widget Definition XML Create widget_clock_day_hour_week.xml in res/xml/ and a corresponding version in res/xml-v28/ (create the directory if it doesn\u0026rsquo;t exist).\nCopy xml/widget_clock_day_week.xml and xml-v28/widget_clock_day_week.xml.\nChanges to Make:\nandroid:minWidth / android:minHeight: Since we added the hourly forecast row, the widget needs more vertical space. Increase minHeight, for example, from @dimen/widget_grid_2 (110dp) to @dimen/widget_grid_3 (180dp). Keep minWidth at @dimen/widget_grid_4 (250dp). android:minResizeHeight: The minimum resize height also needs to increase accordingly, perhaps to @dimen/widget_grid_2. android:initialLayout: Point this to our new layout: @layout/widget_clock_day_hour_week. android:previewImage: Point this to a new preview drawable: @drawable/widget_clock_day_hour_week. Remember, you need to create this image yourself and place it in the drawable folders. android:configure: Point this to our new configuration activity: org.breezyweather.remoteviews.config.ClockDayHourWeekWidgetConfigActivity. v28 Version: Make the same changes, and ensure android:widgetFeatures=\u0026quot;reconfigurable\u0026quot; is present. \u0026lt;!-- res/xml/widget_clock_day_hour_week.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;appwidget-provider xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:minWidth=\u0026#34;@dimen/widget_grid_4\u0026#34; android:minHeight=\u0026#34;@dimen/widget_grid_3\u0026#34; \u0026lt;!-- Increased height --\u0026gt; android:minResizeWidth=\u0026#34;@dimen/widget_grid_3\u0026#34; android:minResizeHeight=\u0026#34;@dimen/widget_grid_2\u0026#34; \u0026lt;!-- Increased resize height --\u0026gt; android:updatePeriodMillis=\u0026#34;0\u0026#34; android:initialLayout=\u0026#34;@layout/widget_clock_day_hour_week\u0026#34; \u0026lt;!-- Point to new layout --\u0026gt; android:previewImage=\u0026#34;@drawable/widget_clock_day_hour_week\u0026#34; \u0026lt;!-- Point to new preview --\u0026gt; android:resizeMode=\u0026#34;horizontal|vertical\u0026#34; android:configure=\u0026#34;org.breezyweather.remoteviews.config.ClockDayHourWeekWidgetConfigActivity\u0026#34; \u0026lt;!-- Point to new config activity --\u0026gt; android:widgetCategory=\u0026#34;home_screen|keyguard\u0026#34; /\u0026gt; 3. Stitching It All Together: Resources \u0026amp; Registration The final step is to make sure all the necessary resource definitions and registrations are in place.\ndimens.xml: Double-check the dimensions used in the layout. Existing ones like @dimen/widget_time_text_size ( 10sp), @dimen/widget_content_text_size (14sp), @dimen/widget_little_weather_icon_size (36dp) seem appropriate. If you feel the hourly or daily sections need specific adjustments, define new dimensions here and reference them. For now, reusing existing ones should be fine.\nkeys.xml: Add the new string for the configuration storage key.\n\u0026lt;!-- res/values/keys.xml --\u0026gt; \u0026lt;resources ...\u0026gt; ... \u0026lt;string name=\u0026#34;sp_widget_clock_day_hour_week_setting\u0026#34; translatable=\u0026#34;false\u0026#34;\u0026gt;widget_clock_day_hour_week_setting\u0026lt;/string\u0026gt; ... \u0026lt;/resources\u0026gt; strings.xml: Add the user-visible name for the widget.\n\u0026lt;!-- res/values/strings.xml --\u0026gt; \u0026lt;resources ...\u0026gt; ... \u0026lt;string name=\u0026#34;widget_clock_day_hour_week\u0026#34;\u0026gt;Clock + Day + Hour + Week\u0026lt;/string\u0026gt; \u0026lt;!-- Or your preferred name --\u0026gt; ... \u0026lt;/resources\u0026gt; (Don\u0026rsquo;t forget translations in other values-*/strings.xml files if necessary!)\nAndroidManifest.xml: Inside the \u0026lt;application\u0026gt; tag, register the new Provider (\u0026lt;receiver\u0026gt;) and Config Activity (\u0026lt;activity\u0026gt;). It\u0026rsquo;s good practice to group them with the other widget declarations.\n\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;application ...\u0026gt; ... \u0026lt;!-- ClockDayHourWeek Widget Configuration Activity --\u0026gt; \u0026lt;activity android:name=\u0026#34;.remoteviews.config.ClockDayHourWeekWidgetConfigActivity\u0026#34; android:theme=\u0026#34;@style/BreezyWeatherTheme\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.appwidget.action.APPWIDGET_CONFIGURE\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; ... \u0026lt;!-- ClockDayHourWeek Widget Provider --\u0026gt; \u0026lt;receiver android:name=\u0026#34;.background.receiver.widget.ClockDayHourWeekWidgetProvider\u0026#34; android:label=\u0026#34;@string/widget_clock_day_hour_week\u0026#34; \u0026lt;!-- Reference the name from strings.xml --\u0026gt; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.appwidget.provider\u0026#34; android:resource=\u0026#34;@xml/widget_clock_day_hour_week\u0026#34; /\u0026gt; \u0026lt;!-- Reference the definition xml --\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.appwidget.action.APPWIDGET_UPDATE\u0026#34; /\u0026gt; \u0026lt;action android:name=\u0026#34;android.appwidget.action.ACTION_APPWIDGET_DISABLED\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; ... \u0026lt;/application\u0026gt; Widgets.kt: Add the new block of PendingIntent Request Code constants. Pick an unused range (like 14x).\n// src/main/java/org/breezyweather/remoteviews/Widgets.kt object Widgets { ... // other constants // clock + day + hour + week. (Using 14x block) const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_WEATHER = 141 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_1 = 1421 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_2 = 1422 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_3 = 1423 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_4 = 1424 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_DAILY_FORECAST_5 = 1425 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CALENDAR = 143 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CLOCK_LIGHT = 144 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CLOCK_NORMAL = 145 const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_CLOCK_BLACK = 146 // Add codes here if hourly forecast items become clickable // const val CLOCK_DAY_HOUR_WEEK_PENDING_INTENT_CODE_HOURLY_FORECAST_1 = 1471 // ... ... // rest of the constants } 4. Wrapping Up \u0026amp; Final Thoughts And\u0026hellip; that should be it! After adding all these files and making the necessary resource changes, rebuild the project. The new \u0026ldquo;Clock + Day + Hour + Week\u0026rdquo; widget should now appear in your system\u0026rsquo;s widget picker. When you add it to your home screen, the configuration activity will launch, and once configured, you should see your brand new, all-in-one weather widget!\nQuick Recap of the Process:\nDefine the Goal: Create a comprehensive weather widget. Analyze Existing Patterns: Identify the Provider -\u0026gt; IMP -\u0026gt; Config -\u0026gt; Layout -\u0026gt; Definition XML workflow. Copy \u0026amp; Modify: Leverage existing code (ClockDayWeek components) as a base, then modify extensively, especially the IMP and Layout files. Core Addition: Design and implement the hourly forecast section in the layout and add the corresponding data-binding and visibility logic in the IMP\u0026rsquo;s getRemoteViews. Attention to Detail: Systematically update all relevant IDs, configuration keys, widget names, and request codes for uniqueness. Adjust widget dimensions (minHeight, minResizeHeight). Resource Integration: Add the necessary declarations and definitions in AndroidManifest.xml, keys.xml, strings.xml, and Widgets.kt. Potential Gotchas:\nRemoteViews Limitations: Remember RemoteViews only supports a limited set of Views and methods. Complex interactions or custom drawing are tricky. We stuck to basics like TextView, ImageView, LinearLayout, RelativeLayout, and TextClock, which works fine. ID Conflicts: Forgetting to rename IDs after copying is an easy mistake that can lead to update errors or crashes. Double-check them! Data Fetching: Ensure the Provider requests withHourly = true, otherwise, the hourly section will be empty. Layout Adaptability: Widget appearance might need fine-tuning with dimens.xml values to look good across different screen sizes and densities. Overall, adding the ClockDayHourWeekWidget was a relatively smooth process, largely thanks to Breezy Weather\u0026rsquo;s clean structure and consistent widget implementation pattern. It involved a fair amount of code, but much of it was following the established template. The key was understanding how RemoteViews works and carefully handling the data binding and view states in the IMP class, especially for the newly added hourly section and the visibility logic for dynamic content.\nHope this rambling dev log is helpful to someone out there! Until the next coding adventure\u0026hellip; Cheers!\nSource Code\n","permalink":"https://tategotoazarasi.github.io/en/posts/clock-day-hour-week-widget/","summary":"\u003cp\u003eI was tinkering with Breezy Weather, the open-source weather app, the other day. It\u0026rsquo;s got a decent collection of\nwidgets, but I felt like something was missing – one of those \u0026ldquo;kitchen sink\u0026rdquo; widgets that just throws everything you\nneed onto your home screen. You know, the current time, what the weather\u0026rsquo;s doing \u003cem\u003eright now\u003c/em\u003e, what it\u0026rsquo;s gonna do in the\n\u003cem\u003enext few hours\u003c/em\u003e, AND the outlook for the \u003cem\u003enext few days\u003c/em\u003e. I got tired of either opening the app or juggling multiple\nwidgets to get the full picture. Naturally, the itch to code kicked in, and I decided to build it myself. Let\u0026rsquo;s call it\nthe \u003ccode\u003eClockDayHourWeekWidget\u003c/code\u003e.\u003c/p\u003e","title":"Dev Log: Adding a All-in-One Widget to Breezy Weather - The ClockDayHourWeekWidget Journey"},{"content":"Ever stepped into a vast, sprawling game world and wondered, \u0026ldquo;How did they build all this?\u0026rdquo; From the infinite blocky landscapes of Minecraft to the galaxy-spanning planets of No Man\u0026rsquo;s Sky or the intricate simulated histories of Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).\nInstead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions – to generate game content automatically. This isn\u0026rsquo;t just about saving time (though it certainly helps!); it\u0026rsquo;s about creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that\u0026rsquo;s different every single time you start a new game, a world generated just for you, with its own unique geography, climate, and maybe even history. That\u0026rsquo;s the power and allure of PCG.\nThis post is a deep dive into the technologies, algorithms, and methods used to generate these fictional worlds, focusing primarily on the large-scale environmental aspects: the maps, the terrain, the climate, and the biomes that bring these virtual places to life. We\u0026rsquo;ll cover:\nThe Fundamentals: What PCG is, the magic of seeds, and the crucial role of noise functions (Perlin, Simplex, and friends). Shaping the World: Different map geometries (flat vs. spherical) and tiling systems (squares, hexes, irregular shapes). Raising the Land: Techniques for creating continents and oceans, from simple noise heightmaps to sophisticated plate tectonics simulations. Carving the Details: How erosion (water and thermal) and river systems turn basic terrain into believable landscapes. Breathing Life into It: Simulating climate (temperature, rainfall, wind) and distributing biomes (deserts, forests, tundras). Under the Hood: The data structures used to represent these complex worlds. Learning from the Masters: Quick looks at how systems like WorldEngine, Mapgen4, and Tectonics.js put these ideas into practice. Code Corner: Practical C++ snippets illustrating core concepts like noise and erosion. The Horizon: Where world generation might be heading next. Whether you\u0026rsquo;re a seasoned game developer, an aspiring world-builder, or just curious about the magic behind your favorite games, grab a virtual pickaxe, and let\u0026rsquo;s dig in!\nThe Building Blocks: Fundamentals of Procedural World Generation At its heart, procedural generation is about using algorithms to create content instead of manually authoring every detail. Think of it like giving the computer a recipe rather than a finished cake. The recipe (the algorithm) defines the steps, and the computer follows them to bake a unique cake (the game world) each time, potentially with slight variations based on the ingredients (parameters and randomness).\nThe Seed of Creation A key concept is the seed. Most procedural generation relies on pseudorandom number generators (PRNGs). These algorithms produce sequences of numbers that appear random but are actually deterministic. If you start a PRNG with the same initial value, called the seed, it will always produce the exact same sequence of numbers.\nIn game development, this is incredibly powerful. You can generate a massive, complex world using algorithms driven by a PRNG. Instead of storing gigabytes of map data, you just need to store the generation algorithms and a single seed number (often just a 32-bit or 64-bit integer). When a player wants to play that specific world again or share it with a friend, they just need the seed. This is how games like Minecraft allow players to share specific world layouts [1].\nWhy Go Procedural? The benefits are compelling:\nContent Variety \u0026amp; Replayability Generate near-infinite unique worlds, levels, or items, keeping the experience fresh [1].\nDevelopment Efficiency \u0026amp; Scalability Create vast amounts of content with potentially less manual effort, allowing small teams to build large worlds.\nReduced Storage/Download Size Store the generator (code) and a seed, not the massive output data [1].\nEmergent Possibilities Complex interactions between simple procedural rules can lead to unexpected and interesting results.\nThe Challenges Of course, it\u0026rsquo;s not magic. Getting PCG right involves challenges:\nCoherence and Quality Ensuring generated content makes sense, looks good, and is playable. Randomness needs structure.\nAvoiding Repetition Making sure the generated content doesn\u0026rsquo;t feel monotonous or obviously algorithmic.\nArtistic Control Giving designers enough control to guide the generation towards a specific vision, rather than accepting whatever the algorithm spits out. This often involves hybrid approaches, where procedural elements are combined with hand-authored content or guided by designer-specified constraints.\nDebugging Finding bugs in content that only appears under certain random seeds can be tricky.\nNoise: The Canvas of Creation One of the most fundamental tools in the procedural generation toolbox, especially for terrain and textures, is **noise **. We\u0026rsquo;re not talking about audio noise, but rather mathematical functions that generate pseudo-random, yet structured, patterns. Unlike pure rand(), which gives unrelated values at each point, noise functions produce values that vary smoothly across space.\nPerlin Noise Developed by Ken Perlin in the 1980s (earning him an Academy Award!), Perlin noise is a type of gradient noise. It works by setting up a grid and assigning a random gradient (direction) vector to each grid point. To get the noise value at any location within a grid cell, you calculate vectors from the location to the cell\u0026rsquo;s corners, compute the dot product with the corner gradients, and then smoothly interpolate these values [2]. The result is a smooth, continuous, organic-looking pattern often used for terrain heightmaps, clouds, fire effects, and wood grain textures [1]. However, because it\u0026rsquo;s based on a square/cubic grid, Perlin noise can sometimes exhibit subtle directional artifacts, especially noticeable at lower frequencies.\nSimplex Noise Also developed by Ken Perlin (in 2001) to address some of Perlin noise\u0026rsquo;s limitations, Simplex noise uses a simpler lattice structure (triangles in 2D, tetrahedra in 3D) instead of a square/cubic grid [3]. This results in several advantages:\nLower computational complexity, especially in higher dimensions. No significant directional artifacts (more isotropic). Smoother visual appearance. For these reasons, Simplex noise is often preferred for modern terrain generation [4]. Value Noise A simpler approach where random values (not gradients) are assigned to grid points, and the noise value at any location is found by smoothly interpolating the values at the surrounding grid points [5]. It\u0026rsquo;s computationally cheaper than gradient noise but can sometimes look blockier or less \u0026ldquo;natural.\u0026rdquo;\nFractional Brownian Motion (fBm) / Fractal Noise This isn\u0026rsquo;t a single noise function but a technique for combining multiple layers (called octaves) of a base noise function (like Perlin or Simplex) at different frequencies and amplitudes [6].\nThe first octave (low frequency, high amplitude) creates large, broad features. Subsequent octaves add progressively higher frequencies and lower amplitudes, layering finer and finer details on top. The key parameters are:\nPersistence Controls how much the amplitude decreases for each successive octave (typically \u0026lt; 1).\nLacunarity Controls how much the frequency increases for each successive octave (typically \u0026gt; 1). By summing these layers, you get a \u0026ldquo;fractal\u0026rdquo; appearance – statistical self-similarity across different scales, much like real mountains or coastlines. fBm is the workhorse for generating realistic-looking base terrain heightmaps.\nHere\u0026rsquo;s a conceptual C++ snippet showing how fBm (or \u0026ldquo;octave noise\u0026rdquo;) might be implemented using a placeholder noise2D function (which could be Perlin or Simplex):\n#include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;random\u0026gt; // For seeding, though actual noise uses deterministic hashing // Placeholder noise function: returns noise value in [-1,1] for coordinates (x,y). // In reality, this would involve permutation tables, gradient vectors, interpolation etc. // See libraries like FastNoiseLite, libnoise, or implement Perlin/Simplex yourself. double noise2D(double x, double y); // Generate fractal noise (fBm) by summing octaves of noise double fractalBrownianMotion(double x, double y, int octaves, double persistence = 0.5, double lacunarity = 2.0) { double totalValue = 0.0; double frequency = 1.0; double amplitude = 1.0; double maxValue = 0.0; // Used for normalization for (int i = 0; i \u0026lt; octaves; ++i) { totalValue += amplitude * noise2D(x * frequency, y * frequency); maxValue += amplitude; // Accumulate max possible amplitude amplitude *= persistence; // Decrease amplitude for next octave frequency *= lacunarity; // Increase frequency for next octave } // Normalize the result to be roughly in [-1, 1] (assuming noise2D is in [-1, 1]) if (maxValue \u0026gt; 0) { return totalValue / maxValue; } else { return 0.0; // Avoid division by zero if octaves=0 or amplitude=0 } } int main() { const int width = 512, height = 512; std::vector\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; heightmap(height, std::vector\u0026lt;double\u0026gt;(width)); // --- Noise Initialization Would Go Here --- // (e.g., seeding the PRNG, setting up permutation tables for Perlin/Simplex) // --- Generate Heightmap using fBm --- int numOctaves = 8; double noisePersistence = 0.5; // Standard 1/f noise characteristic double noiseLacunarity = 2.0; double baseFrequency = 2.0; // Controls the overall scale of the largest features for (int y = 0; y \u0026lt; height; ++y) { for (int x = 0; x \u0026lt; width; ++x) { // Map pixel coordinates to noise input coordinates // Dividing by width/height scales input; baseFrequency adjusts overall scale double nx = (double(x) / width) * baseFrequency; double ny = (double(y) / height) * baseFrequency; // Generate fBm noise value double elevation = fractalBrownianMotion(nx, ny, numOctaves, noisePersistence, noiseLacunarity); // Map the noise value (e.g., [-1, 1]) to your desired height range // Example: Map to [0, 1] heightmap[y][x] = (elevation + 1.0) * 0.5; } } // --- Use the Heightmap --- // (e.g., render it, determine land/water based on a threshold, etc.) // ... return 0; } Noise functions are the fundamental texture, the raw material from which many procedural worlds are sculpted. But just applying noise isn\u0026rsquo;t enough to create a believable world. We need structure, geology, and the effects of natural processes.\nShaping the Canvas: Map Geometry and Representation Before we can paint mountains and rivers, we need a canvas. How do we represent the game world? The choice of map geometry has profound implications for everything that follows.\nFlat Maps (Planar Worlds) The simplest approach is to treat the world as a 2D plane.\nInfinite Continuous Planes Games like Minecraft conceptually use an infinite plane. The world isn\u0026rsquo;t pre-generated; chunks are generated on the fly as the player explores, often using noise functions evaluated at the chunk\u0026rsquo;s coordinates. Techniques like periodic noise or careful coordinate management are needed to ensure chunks stitch together seamlessly [7].\nBounded Planes Simpler maps might just have hard edges (invisible walls or an \u0026ldquo;edge of the world\u0026rdquo;). This is easy but can feel artificial.\nWrapped Planes (Toroidal Worlds) To eliminate edges, flat maps can be \u0026ldquo;wrapped.\u0026rdquo; Going off the east edge brings you to the west edge, and going off the north edge brings you to the south. Topologically, this creates a torus (a donut shape), not a sphere. This is common in older strategy games or simulations where a finite but borderless world is desired [8].\nSpherical Maps (Planetary Worlds) For simulating planets, strategy games spanning a globe, or space exploration games, a spherical representation is more realistic. However, this introduces complexity. How do you map a sphere onto data structures and display it on a 2D screen?\nChallenges Representing a sphere without significant distortion or awkward singularities (like the poles in latitude-longitude grids) is tricky. An equirectangular projection (mapping latitude/longitude directly to a rectangular grid) is simple but severely stretches areas near the poles and collapses everything to a single point at the poles.\nCommon Solutions Cube Mapping Project the sphere onto the six faces of a cube. Each face can be treated as a regular square grid, minimizing distortion compared to equirectangular. The main challenge is handling the seams/edges between the cube faces smoothly.\nIcosahedral Subdivision (Geodesic Grids) Start with an icosahedron (20 triangular faces) inscribed within the sphere. Project its vertices onto the sphere. Then, recursively subdivide each triangle into smaller triangles, projecting new vertices onto the sphere. This creates a geodesic dome structure. The dual of this triangular mesh (connecting the centers of adjacent triangles) results in a grid composed mostly of hexagons, with exactly 12 pentagons located at the original icosahedron\u0026rsquo;s vertices (think of a soccer ball pattern) [4]. This hex-pent grid provides relatively uniform cell sizes and shapes across the sphere, making it popular for global climate models and some planetary generators [4]. The main complexity lies in the data structures needed to handle the 12 pentagons and track neighbor relationships.\nFibonacci Lattice / Spiral Points Algorithms exist to distribute points quasi-uniformly on a sphere\u0026rsquo;s surface using spiral patterns related to the Fibonacci sequence or golden ratio [4]. These points can then be used as centers for Voronoi regions or vertices for a Delaunay triangulation, creating an irregular but relatively even mesh covering the sphere. Amit Patel\u0026rsquo;s influential planet generation experiments often start by distributing points this way, then slightly \u0026ldquo;jittering\u0026rdquo; them to avoid unnatural regularity [4].\nTiling Schemes: Squares vs. Hexes vs. Irregular Whether the map is flat or spherical (represented facet by facet, like a cube map or geodesic grid), we often divide it into discrete units or tiles for gameplay or simulation purposes.\nSquare Tiles The simplest. Easy to address (row, column), easy to map to pixel grids. Neighbors are straightforward (4 cardinal, possibly 4 diagonal). The main drawback, especially for movement or area-of-effect calculations, is the difference between orthogonal and diagonal distances/connectivity.\nHexagonal Tiles A favorite for many strategy games (Civilization V/VI, RimWorld\u0026rsquo;s planet map). Why?\nUniform Adjacency Each hex has 6 neighbors, all equidistant from the center. This eliminates the diagonal vs. orthogonal awkwardness of squares, making movement costs and distances more consistent.\nConnectivity The 6-way connectivity can lead to more organic-looking shapes for landmasses and region boundaries.\nImplementation Requires slightly more complex coordinate systems (axial or cube coordinates are common) and careful handling of neighbor finding and wrapping, especially on a sphere. Excellent guides exist, notably from Red Blob Games [9] [8].\nIrregular Polygons (Voronoi/Graph-Based) Instead of uniform tiles, partition the map using irregular polygons, often generated via a Voronoi diagram.\nScatter a set of points (seeds) across the map (plane or sphere). For each seed, define its region (cell) as all locations closer to that seed than any other. The result is a tessellation of the map into irregular polygonal cells. Amit Patel\u0026rsquo;s Polygon Map Generation tutorials are seminal work in this area [10].\nAdvantages Can produce much more natural-looking coastlines, region boundaries, and river paths (which can flow along the edges of the Voronoi graph). The underlying graph structure is great for simulating flows or relationships between regions. It provides a \u0026ldquo;good skeleton\u0026rdquo; for placing features [10]. Systems like Mapgen4 and Tectonics.js utilize this approach [4].\nDisadvantages: Computationally more expensive to generate and work with. Geometric operations (like finding neighbors or calculating distances/areas) are more complex than on a regular grid.\nThe choice of map geometry and tiling impacts everything downstream, from how noise is applied to how simulations like erosion or climate are run. A spherical Voronoi mesh arguably offers the highest potential for realism on a planetary scale, but simpler grids (flat or wrapped, square or hex) are often chosen for performance and ease of implementation.\nRaising the Land: Generating Continents and Oceans With a canvas defined, the next step is painting the broad strokes: where is land, and where is sea? How do continents form? Two main paradigms dominate: noise-based heightmaps and plate tectonics simulation.\nFractal Noise Heightmaps: The Quick and Dirty Approach The most common method is to use fractal noise (like fBm described earlier) to generate an elevation map or * heightmap*. This is typically a 2D grid where each cell stores an elevation value.\nGenerate Noise Use multiple octaves of Perlin or Simplex noise to create a heightfield $H(x, y)$. Low frequencies create broad continents/basins, high frequencies add detail.\nSet Sea Level Choose a threshold value. All points on the heightmap below this value become ocean; all points above become land. A common target is ~70% ocean, similar to Earth, which might correspond to picking the 30th percentile of height values as sea level [1].\nThis quickly produces a world with land and sea. However, pure noise has limitations:\nLack of Structure Real continents have long, linear mountain ranges, vast flat plains, and specific shapes dictated by geological history. Noise-based terrain tends to produce more random, blobby, or uniformly hilly landscapes. Mountain ranges don\u0026rsquo;t align meaningfully [1].\nIsland Problem Naively thresholding noise often results in worlds that are either mostly ocean with scattered small islands, or mostly land with scattered lakes, rather than a few large continents.\nTechniques to Improve Noise-Based Continents Shaping Functions Multiply the noise heightmap by another function (e.g., a radial gradient that lowers elevation near the edges of the map) to force oceans around a central landmass. WorldEngine uses a trick where they normalize the heightmap so the lowest point is at the border and highest is central, then flood from the edges to ensure a central continent [1].\nDomain Warping A clever technique popularized by Inigo Quilez and others. Instead of evaluating noise at (x, y), you evaluate it at coordinates that have been distorted by another noise function. For example: height = noise1(x + offset * noise2(x, y), y + offset * noise3(x, y)). This \u0026ldquo;warps\u0026rdquo; the coordinate space, creating swirling, folded, and branching patterns in the output noise [7]. Domain warping can produce features that look remarkably like eroded terrain – twisty ridges, river-like valleys – without actually simulating erosion [7]. It\u0026rsquo;s computationally cheap (just more noise lookups) and adds significant visual complexity, making basic noise terrain look much more interesting.\nDiamond-Square Algorithm A classic (though somewhat dated) fractal algorithm specifically for generating heightmaps. It works by recursively subdividing squares, setting corner points, then calculating midpoints with random offsets. It tends to produce characteristic square-aligned artifacts but is simple to implement.\nNoise provides the fundamental texture and detail, but for realistic structure, we often need to simulate the processes that build that structure.\nPlate Tectonics Simulation: Building Worlds Geologically On Earth, continents and mountains are formed by the slow dance of tectonic plates. Simulating this process can produce far more plausible large-scale world structures. While full geophysical simulation is complex, simplified models are feasible for world generation. Notable projects exploring this include WorldEngine, Tectonics.js, PyTectonics, and academic work like \u0026ldquo;Procedural Tectonic Planets\u0026rdquo; [1] [11] [12].\nA Simplified Tectonic Algorithm Initialize Plates Divide the world (represented as a grid or spherical mesh) into a number of distinct regions, representing tectonic plates (e.g., 6-20 plates). This can be done randomly (e.g., Voronoi partitioning) or based on initial noise patterns. Assign each plate an initial velocity (direction and speed).\nMove Plates Simulate the movement of each plate over a time step according to its velocity. On a sphere, this movement follows great circle paths.\nDetect Interactions Identify where plates are colliding (convergent boundary), pulling apart (divergent boundary), or sliding past each other (transform boundary).\nModify Terrain Convergence (Collision) Where plates collide, uplift the terrain significantly, forming mountain ranges. If one plate is denser (oceanic vs. continental), it might subduct (slide underneath), leading to uplift on the overriding plate and potentially volcanic activity or deep ocean trenches.\nDivergence (Rifting) Where plates pull apart, lower the terrain, creating rift valleys on land or mid-ocean ridges under the sea where new crust forms.\nTransform Minimal vertical change, but can create fault lines.\nIterate Repeat steps 2-4 for many simulated time steps (representing millions of years). Plate velocities might change, plates might merge or break apart.\nMore Sophisticated Models (e.g., Tectonics.js) Tectonics.js implements a more physics-inspired model on a spherical grid [11]:\nIt tracks crust properties like density and age. Oceanic crust becomes denser as it ages [11]. Dense oceanic crust tends to subduct under lighter continental or younger oceanic crust [11]. Plate velocities are calculated based on forces pulling plates towards subduction zones [11]. Plates are dynamically identified by grouping areas with similar velocities. At convergent boundaries, overlapping crust is effectively deleted (simulating subduction). At divergent boundaries, gaps are filled with new crust [11]. This leads to emergent, realistic features: long mountain chains, island arcs, spreading ocean basins [11]. The downside is computational cost – it\u0026rsquo;s not instantaneous [11]. Benefits of Tectonic Simulation Plausible Structure Generates continents, oceans, and mountain ranges with shapes and alignments that resemble real geology. Features that noise alone struggles with.\nInherent History The generated world has a \u0026ldquo;story.\u0026rdquo; You can trace why a mountain range exists (e.g., collision of plates X and Y). This is great for lore and deeper simulation [11] [13].\nEmergent Land/Sea Distribution The amount and shape of land isn\u0026rsquo;t predefined but emerges naturally from the simulation.\nHybrid Approaches Pure tectonic simulation can sometimes produce terrain that lacks fine detail or looks \u0026ldquo;bland\u0026rdquo; between the major features. Many systems, like WorldEngine, use a hybrid approach:\nStart with an initial heightmap generated by noise (providing base detail). Run a plate tectonics simulation to deform this heightmap, creating large-scale structures. Apply more noise afterward to add roughness and smaller features back in. [1]. This combination often yields the best results: realistic large-scale structure with natural-looking small-scale variation. After generating the basic landforms via noise, tectonics, or a hybrid, the next step is often to refine the terrain with processes that shape it over time.\nCarving the Details: Erosion and River Simulation A freshly generated heightmap, even one based on tectonics and noise, often looks too sharp, too uniform, too\u0026hellip; computer-generated. Real landscapes are heavily sculpted by erosion – the relentless wearing away of rock and soil by water, wind, ice, and gravity. Simulating erosion is crucial for adding realism and creating features like river valleys, smooth hills, and depositional plains. As the WorldEngine developers state, \u0026ldquo;If you do not simulate erosion you will never obtain realistic maps.\u0026rdquo; [1].\nHydraulic Erosion (Water Power) This is the most significant type of erosion for shaping large landscapes. It involves water (rain, rivers) dislodging soil/rock particles, transporting them downhill, and depositing them where the water slows down. There are two main algorithmic approaches [14]:\nEulerian (Grid-Based) Treats water as a fluid layer covering the terrain grid. Each cell tracks water depth and sediment concentration. Water flows between cells based on height differences (pressure gradients), carrying sediment with it. Sediment is eroded from the ground where flow is high and deposited where it\u0026rsquo;s low. These models often use simplified versions of fluid dynamics equations (like the shallow water equations). They can capture large-scale effects but can be complex and computationally intensive.\nLagrangian (Particle-Based / \u0026ldquo;Rain Droplet\u0026rdquo; Model): Simulates the paths of individual water droplets. This is very popular in game development due to its conceptual simplicity and ability to create intricate channel networks. The basic idea:\nSpawn Droplet Create a \u0026ldquo;raindrop\u0026rdquo; particle at a random location on the heightmap with a small amount of water and initially no sediment.\nFlow Downhill Move the droplet in the direction of the steepest downhill slope, calculated from the heightmap gradient at its current position. Its velocity increases on steeper slopes.\nErode/Deposit The droplet\u0026rsquo;s capacity to carry sediment depends on factors like its water volume, velocity, and the slope it\u0026rsquo;s on.\nIf the droplet is moving fast/downhill (high capacity) and currently holds less sediment than its capacity, it erodes material from the ground, decreasing terrain height and increasing its sediment load. If the droplet slows down (e.g., on flatter ground, low capacity) and holds more sediment than it can carry, it deposits sediment, increasing terrain height and decreasing its load. A simple capacity model might be: capacity = k * velocity * slope [14]. The amount eroded or deposited is then proportional to the difference between capacity and current sediment load [14]. Evaporate The droplet gradually loses water over time/distance.\nTerminate The simulation for that droplet ends when it runs out of water, flows off the map, or gets stuck in a pit.\nRepeat Simulate thousands or millions of these droplets. Each path contributes incrementally to carving channels and building up depositional areas.\nHere\u0026rsquo;s the C++ pseudocode snippet (adapted from Article 1 and common implementations) illustrating the core loop for a single droplet:\n#include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; // For std::max, std::min // Assumes existence of a HeightMap class/struct // with methods like: // double getHeight(double x, double y); // Interpolated height // Vector2 getGradient(double x, double y); // Steepest downhill gradient vector // void addHeight(int gridX, int gridY, double delta); // Modify height at grid cell // int width(); int height(); struct HeightMap { /* ... definition ... */ }; struct Vector2 { double x, y; }; struct Droplet { double x, y; // Current position (continuous) double vx, vy; // Current velocity double water; // Amount of water remaining double sediment; // Amount of sediment carried }; // Simulation parameters (tune these!) const int maxSteps = 64; // Max lifetime of a droplet const double timeStep = 1.0; // Simulation step duration const double friction = 0.1; // Slows down velocity over time const double evaporationRate = 0.01; // Water lost per step const double erosionRate = 0.01; // How readily soil is eroded const double depositRate = 0.01; // How readily sediment is deposited const double sedimentCapacityFactor = 10.0; // Scales overall capacity const double minSlopeForErosion = 0.01; // Don\u0026#39;t erode on near-flat ground const double minWater = 0.001; // Stop when droplet is too small void simulateDroplet(Droplet\u0026amp; d, HeightMap\u0026amp; H) { for (int step = 0; step \u0026lt; maxSteps; ++step) { // Get current grid cell indices and interpolated position int gridX = static_cast\u0026lt;int\u0026gt;(d.x); int gridY = static_cast\u0026lt;int\u0026gt;(d.y); // Boundary check if (gridX \u0026lt; 0 || gridX \u0026gt;= H.width() - 1 || gridY \u0026lt; 0 || gridY \u0026gt;= H.height() - 1) { break; // Droplet flowed off map } // Calculate height and gradient at the droplet\u0026#39;s interpolated position double currentHeight = H.getHeight(d.x, d.y); Vector2 gradient = H.getGradient(d.x, d.y); // Points downhill // Update velocity based on gradient (gravity) and friction d.vx = (d.vx * (1.0 - friction)) + gradient.x * timeStep; d.vy = (d.vy * (1.0 - friction)) + gradient.y * timeStep; // Store old position double oldX = d.x; double oldY = d.y; // Update position based on velocity d.x += d.vx * timeStep; d.y += d.vy * timeStep; // Boundary check again after move if (d.x \u0026lt; 0 || d.x \u0026gt;= H.width() - 1 || d.y \u0026lt; 0 || d.y \u0026gt;= H.height() - 1) { // Deposit remaining sediment at last valid position before leaving map H.addHeight(gridX, gridY, d.sediment); break; } // Calculate height difference between old and new position double newHeight = H.getHeight(d.x, d.y); double deltaHeight = currentHeight - newHeight; // Positive if moving downhill // Calculate sediment capacity // Capacity depends on water volume, speed, and slope (deltaHeight) // Simple model: capacity proportional to water * deltaHeight (steeper drop = more capacity) // Clamp deltaHeight to avoid negative capacity if moving uphill slightly double speed = std::sqrt(d.vx * d.vx + d.vy * d.vy); double capacity = std::max(0.0, deltaHeight) * d.water * sedimentCapacityFactor * speed; // Erode or deposit sediment at the *previous* cell (gridX, gridY) // This prevents digging holes directly under the droplet if (deltaHeight \u0026gt; minSlopeForErosion) { // Only erode/deposit significantly if moving downhill double sedimentDiff = capacity - d.sediment; if (sedimentDiff \u0026gt; 0) { // Can carry more: Erode double amountToErode = std::min(sedimentDiff * erosionRate, deltaHeight); // Don\u0026#39;t erode more than available height diff amountToErode = std::min(amountToErode, H.getHeight(gridX + 0.5, gridY + 0.5) * 0.1); // Limit erosion based on current height too amountToErode = std::max(0.0, amountToErode); // Ensure non-negative H.addHeight(gridX, gridY, -amountToErode); // Remove from terrain d.sediment += amountToErode; // Add to droplet } else { // Carrying too much: Deposit double amountToDeposit = std::min(-sedimentDiff * depositRate, d.sediment); // Deposit difference, up to amount carried amountToDeposit = std::max(0.0, amountToDeposit); // Ensure non-negative H.addHeight(gridX, gridY, amountToDeposit); // Add to terrain d.sediment -= amountToDeposit; // Remove from droplet } } // Evaporate water d.water *= (1.0 - evaporationRate); if (d.water \u0026lt; minWater) { // Deposit remaining sediment if droplet evaporates H.addHeight(gridX, gridY, d.sediment); break; } } } // --- In main() or simulation loop --- // HeightMap terrain = ...; // Initial heightmap // int numDroplets = 100000; // std::mt19937 rng(seed); // Random number generator // std::uniform_real_distribution\u0026lt;double\u0026gt; distX(0.0, terrain.width() - 1.0); // std::uniform_real_distribution\u0026lt;double\u0026gt; distY(0.0, terrain.height() - 1.0); // for (int i = 0; i \u0026lt; numDroplets; ++i) { // Droplet drop = { // distX(rng), distY(rng), // Random start position // 0.0, 0.0, // Initial velocity // 1.0, // Initial water // 0.0 // Initial sediment // }; // simulateDroplet(drop, terrain); // } // --- Terrain now contains eroded features --- Performance Note: Simulating millions of droplets can be slow. Optimizations include:\nGPU acceleration (as researched by Mei et al. [1]). Simulating larger \u0026ldquo;streams\u0026rdquo; or using grid-based flow accumulation models instead of individual droplets. Thermal Erosion (Weathering / Mass Wasting) This simulates the effect of gravity causing material on steep slopes to crumble and slide downwards, accumulating at the base (forming talus slopes). It\u0026rsquo;s much simpler than hydraulic erosion.\nA common algorithm:\nIterate through each cell (x, y) of the heightmap. Compare its height H(x, y) to its neighbors H(nx, ny). For each neighbor lower than the current cell, calculate the height difference d = H(x, y) - H(nx, ny). If this difference d exceeds a threshold (representing the material\u0026rsquo;s \u0026ldquo;angle of repose\u0026rdquo; – the steepest angle it can maintain), then move some material from the higher cell (x, y) to the lower neighbor (nx, ny). The amount moved is typically proportional to the excess difference (d - threshold). For example, move c * (d - threshold) amount of height, where c is a small constant [15] [16]. Ensure total height is conserved (or approximately conserved) by distributing the removed height among all lower neighbors exceeding the threshold. Repeat this process for several iterations until the terrain stabilizes (no more slopes exceed the threshold significantly). Thermal erosion is computationally cheap and effective at smoothing out unnaturally sharp peaks and cliffs left by noise generation or tectonic uplift, giving mountains a more weathered look. It\u0026rsquo;s often applied as a final smoothing pass.\nRiver Network Generation and Watersheds While hydraulic erosion creates river channels, sometimes you want to explicitly define major rivers for gameplay or ensure a realistic drainage network exists.\nFlow Accumulation Analysis: A standard GIS technique adaptable for games.\nFor each cell, determine its flow direction – which neighbor is steepest downhill? Calculate flow accumulation for each cell: how many upstream cells eventually drain through this cell? This is often done recursively or iteratively, passing flow counts downstream. Cells with a high flow accumulation value represent potential river paths. Define a threshold – cells above it are part of a river network. This naturally creates branching tributary systems flowing from highlands to lowlands or oceans. Explicit River Carving Start potential rivers at high points (e.g., mountain springs, areas of high simulated rainfall). Simulate the river flowing downhill, actively lowering the terrain height along its path to \u0026ldquo;carve\u0026rdquo; a valley. Rules are needed to handle hitting flat areas (meander) or depressions (form lakes). Amit Patel\u0026rsquo;s Mapgen4 allows users to draw rivers, and the system then carves them into the terrain [17].\nSimulation-Driven Rivers In systems like WorldEngine, rivers emerge more directly from the coupled simulation. After calculating precipitation and running erosion, they explicitly trace water flow paths from source to sea, calculate water volume in each segment, and designate tiles with significant flow as rivers [1].\nWatersheds The flow direction map also allows identifying watersheds (or drainage basins) – the area of land that drains into a particular river or outlet point. These watersheds, separated by ridges (drainage divides), form natural geographical regions often useful for defining political borders, biome zones, or AI territories.\nIn summary, erosion and river simulation transform a static heightmap into a landscape that feels shaped by natural forces over time. They carve the valleys, create the river networks, and deposit the fertile plains that make a world feel lived-in and geologically plausible. Even simplified erosion or faked effects like domain warping can add significant realism compared to raw noise terrain.\nBreathing Life into the World: Climate, Weather, and Biomes We have land, water, mountains, and rivers. But what makes a desert different from a jungle, or a tundra from a temperate forest? Climate. Simulating climate patterns – temperature, precipitation, wind – allows us to determine which biomes (ecological regions) should exist where.\nSimulating Climate Full global climate modeling (GCM) like that used by climate scientists is computationally prohibitive for most game world generation. Instead, simplified, heuristic models are used to capture the most important factors influencing climate:\nLatitude The primary driver of temperature. Closer to the equator = more direct sunlight = warmer. Temperature generally decreases towards the poles. A simple model might be Temp = BaseTemp - TempDrop * abs(latitude) or using a sine function.\nAltitude Temperature decreases with height (the lapse rate, roughly 6.5°C per 1000m). Mountains are colder than lowlands at the same latitude.\nLand vs. Water Water heats and cools more slowly than land. Coastal areas tend to have more moderate temperatures (less seasonal variation) than continental interiors (continentality). Large bodies of water also act as moisture sources.\nPrevailing Winds Global atmospheric circulation creates dominant wind patterns (e.g., easterly trade winds in the tropics, westerlies in mid-latitudes). Winds transport moisture from oceans over land.\nOcean Currents (Advanced) Warm currents (like the Gulf Stream) can significantly warm coastal regions; cold currents can cool them. Simulating these adds realism but is often skipped in simpler models.\nOrographic Precipitation (Rain Shadows) This is crucial! When moist air carried by wind hits a mountain range, it\u0026rsquo;s forced upwards. As it rises, it cools, and its capacity to hold moisture decreases. This causes rain or snow to fall on the windward side of the mountains. The air that descends on the leeward side is now dry, creating a rain shadow – an area of low precipitation (often deserts or steppes) [18]. Any plausible climate simulation must account for this effect.\nSimplified Climate Modeling Approach Temperature Map Calculate base temperature based on latitude. Adjust for altitude using the lapse rate. Optionally, add modifications for distance from coast (continentality).\nPrevailing Winds Define basic wind directions for different latitude bands (e.g., West in mid-latitudes, East in tropics).\nMoisture \u0026amp; Precipitation Simulate moisture transport. A simple way (used in Mapgen4) is to process cells in order along the wind direction [18]. Start with moisture over oceans (evaporation). As air moves over land, it might pick up some moisture (less than ocean) or gradually lose it. When air hits mountains (rising elevation along wind path), reduce its moisture-holding capacity. If capacity drops below current moisture, the excess falls as rain/snow on the windward slope [18]. The air passed to the leeward side is now drier. Incorporate general global patterns (e.g., high rainfall near the equator - ITCZ, dry zones around 30° latitude). Output Generate maps of average annual temperature and average annual precipitation.\nWorldEngine uses a simplified approach: Temperature from latitude/altitude, Precipitation from temperature plus noise, with specific erosion/flow steps calculating river discharge and humidity [1]. They explicitly chose not to simulate seasons to keep complexity manageable, focusing on annual averages [1].\nFor higher fidelity (perhaps for sci-fi games aiming for realism), tools like ExoPlaSim exist. It\u0026rsquo;s a simplified but physically based 3D global climate model that can simulate atmospheric circulation, heat transport, and precipitation for planets with different parameters (rotation, atmosphere, star type) [19] [20]. Running such a model is more intensive but yields highly realistic climate patterns.\nAssigning Biomes Once you have temperature and precipitation maps, you can classify different regions into biomes. Biomes represent major ecological communities characterized by dominant plant types and adapted to the prevailing climate (e.g., Tropical Rainforest, Temperate Grassland, Arctic Tundra, Subtropical Desert).\nBiome Classification Schemes The simplest way is to use a lookup diagram based on temperature and precipitation.\nWhittaker Biome Diagram A classic ecological chart plotting average annual temperature vs. average annual precipitation, dividing the space into major biome types.\nHoldridge Life Zones A more detailed system used by WorldEngine. It considers temperature, precipitation, and also potential evapotranspiration (related to energy availability) to define a finer set of life zones (~38 zones) [1]. WorldEngine implemented around 40 specific biomes based on this, from \u0026ldquo;Subpolar Dry Tundra\u0026rdquo; to \u0026ldquo;Tropical Rainforest\u0026rdquo; [1].\nAlgorithm For each land cell on your map, get its calculated temperature and precipitation values. Use the chosen classification scheme (Whittaker, Holdridge, or a custom one) to determine the corresponding biome type. Assign the biome type to the cell. (Optional) Apply smoothing or filtering: A single desert tile in the middle of a rainforest might be a noise artifact. You could use a majority filter or smooth biome boundaries to make transitions look more natural. Adding Nuance More advanced systems might consider:\nSoil Moisture/Drainage A flat, wet area might become a swamp or marsh, even if the temperature/precipitation alone suggest forest. WorldEngine simulates water flow and permeability to identify potentially marshy areas [1].\nSeasonality If seasons were simulated, the variation in temperature and precipitation could influence biomes (e.g., differentiating deciduous from coniferous forests).\nSoil Type/Fertility This could emerge from erosion simulation (sediment deposition = fertile) and influence vegetation density or type.\nBiome generation is often the final step in creating the environmental backdrop. It gives the world its visual character and dictates the types of resources, flora, and fauna players might encounter. The beauty is seeing how the underlying geology (tectonics creating mountains) influences climate (rain shadows) which in turn dictates the biomes (deserts behind mountains).\nUnder the Hood: Map Data Structures How is all this complex world information actually stored in memory or on disk? The choice of data structure impacts performance, flexibility, and the types of simulations that are easy to implement.\nRegular Grids (Raster Data) The most common approach, especially for heightmaps. Use 2D arrays (or 3D for voxels like Minecraft) to store values ( elevation, temperature, biome ID, etc.) for each cell.\nPros: Simple addressing (map[row][col]), efficient neighborhood lookups (crucial for erosion, smoothing, cellular automata), aligns well with texture mapping for rendering. Cons: Can be memory-intensive for large, high-resolution maps. Represents discrete steps, less natural for smooth features (though interpolation helps). Spherical representation using grids suffers from distortion (equirectangular) or edge seams (cube map). Hex grids require special coordinate mapping onto the 2D array. Graph-Based Representations (Irregular Meshes) Store the world as a network of nodes and edges, often based on Voronoi diagrams or Delaunay triangulations.\nNodes (e.g., Voronoi cell centers) store properties (elevation, biome). Edges represent adjacency and can store information like flow rates (for rivers) or boundary types. Red Blob Games\u0026rsquo; Polygon Map Generation tutorials detail storing data at corners, edges, and centers of the Voronoi polygons for different purposes [10]. Pros Excellent for representing irregular, natural boundaries. Flexible resolution possible. Good for pathfinding or flow simulations along graph edges.\nCons More complex data structures. Neighborhood operations can be slower/more complex than grid lookups. Physics simulations (like fluid dynamics) are harder to implement on irregular meshes.\nSpherical Subdivisions (DGGS) For true global representation, use specialized structures like icosahedral geodesic grids (hex/pent meshes) or other Discrete Global Grid Systems (DGGS). These aim for near-uniform cell size/shape across the sphere with no singularities.\nPros Best for accurate global simulations (climate, tectonics). Minimal distortion.\nCons Complex implementation, especially handling neighbor relationships and coordinates across the sphere.\nMulti-Layer Data A generated world isn\u0026rsquo;t just a heightmap. It\u0026rsquo;s a collection of related data layers. A practical system often stores multiple aligned grids or graphs:\nElevation map Water map (ocean/lake depth, river paths/flow) Temperature map Precipitation map Biome map Tectonic plate ID map Vegetation density map, etc. WorldEngine, for example, explicitly stores many such layers per tile [1]. This allows different systems (rendering, AI, gameplay logic) to access the specific information they need. It also allows exporting different map views (like a climate map or political map).\nImplicit/Functional Representation For truly infinite or extremely detailed worlds, storing everything explicitly is impossible. Instead, use functions ( like noise functions) to calculate terrain properties on demand at any given coordinate (x, y, z). Games like No Man\u0026rsquo;s Sky rely heavily on generating planet surfaces locally from mathematical formulas as the player approaches, rather than storing the entire planet\u0026rsquo;s geometry.\nThe ideal data structure depends on the scale of the world, the required level of detail, the types of simulations being run, and performance constraints. Many systems use a combination – perhaps a coarse graph for global structure and finer grids for local detail.\nLearning from the Masters: Quick Case Studies Let\u0026rsquo;s briefly look at how some notable projects and games combine these techniques:\nWorldEngine (Open Source Generator) A prime example of a full pipeline [1]. Its steps roughly follow our discussion:\nInitial heightmap (Simplex noise). Plate tectonics simulation (deforms heightmap, creates mountains). Flooding to set sea level. Climate simulation (temperature based on latitude/altitude, precipitation based on temp + noise). Hydraulic erosion (droplet model, carving rivers). Hydrology (calculating river flow, humidity). Biome assignment (Holdridge life zones). It emphasizes the synergy: noise for detail, tectonics for structure, erosion for realism. It outputs multiple data layers exportable to game engines or GIS tools. Mapgen4 (Red Blob Games - Web Tool) Focuses on interactive fantasy map generation [17]. Uses a Voronoi graph structure. Key features:\nFast, interactive updates (user paints features, map regenerates). Achieved via optimized data structures (e.g., spatial partitioning for rivers) and possibly multithreading. Simplified climate simulation (wind, orographic rain) driving river formation and biomes. Height calculation uses distance fields for smooth blending of user-painted mountains. Stylized rendering to look like hand-drawn maps. It shows how core concepts can be implemented efficiently even in a web browser for interactive use. Tectonics.js / PyTectonics (Carl Davidson et al.) Focuses specifically on high-fidelity plate tectonics simulation on a sphere [11]. Uses spherical Voronoi meshes and simulates crust properties, subduction, and velocity fields based on physical principles. Produces very realistic continental configurations but is computationally intensive. Often used as a starting point – generate the tectonic base map, then use other tools for erosion and detailing.\nDwarf Fortress (Bay 12 Games) Famous for its incredibly deep simulation. World generation involves:\nGenerating a base fractal heightmap. Simulating geology (mineral distribution). Simulating rainfall, drainage, rivers, and lakes. Simulating temperature and biomes. Crucially, simulating thousands of years of history: rise and fall of civilizations, wars, mythical beasts, heroes – all leaving traces on the world and creating rich, unique lore tied to the generated geography [1]. It highlights how procedural generation can extend far beyond just terrain into history and culture. Minecraft (Mojang Studios) Uses chunk-based generation on a conceptually infinite plane. Core terrain uses layered 3D Perlin/Simplex noise. Biomes influence terrain height variation, decorations (trees, structures), and block types. Features like caves, ravines, and ore veins are added using separate procedural algorithms within each chunk. Focuses on exploration and emergence from relatively simple block-based rules.\nNo Man\u0026rsquo;s Sky (Hello Games) Generates an entire galaxy of planets using deterministic procedural formulas from a single seed. Planet surfaces are generated on the fly using noise functions and other algorithms as the player approaches. Emphasizes scale, variety, and seamless exploration from space to ground.\nThese examples show there\u0026rsquo;s no single \u0026ldquo;right\u0026rdquo; way. The best approach depends on the game\u0026rsquo;s goals: deep simulation vs. fast interaction, realism vs. stylized appearance, planetary scale vs. local detail. Often, the most successful systems are hybrids, carefully combining noise, simulation, and heuristics.\nPeeking into the Future: Where World Generation is Headed The field is constantly evolving. Here are some exciting directions and possibilities:\nTighter Integration \u0026amp; Coupling Simulating feedback loops. How does massive erosion affect tectonic uplift over millions of years? How does climate change (e.g., an ice age simulated historically) impact erosion rates and biome distribution? Current systems often run steps sequentially; future ones might have more interplay.\nMore Sophisticated Simulation Incorporating more physics: advanced fluid dynamics for erosion and rivers, better atmospheric modeling for climate ( including seasons, dynamic weather), simulation of volcanism (hotspots like Hawaii), ecological succession modeling (how biomes evolve and compete over time).\nAI and Machine Learning Generative Models: Training AI (like GANs or diffusion models) on real-world terrain or climate data to produce plausible fictional outputs (e.g., \u0026ldquo;generate a landscape in the style of the Scottish Highlands\u0026rdquo;).\nParameter Tuning Using ML to automatically find generation parameters that produce worlds meeting specific design criteria (e.g., \u0026ldquo;a world with 3 continents, mostly temperate forests, and navigable rivers\u0026rdquo;).\nSmart Content Placement AI could learn plausible locations for resources, settlements, or points of interest based on the generated environment.\nReal-Time \u0026amp; Interactive Generation Moving beyond pre-computation. Imagine worlds that visibly evolve based on player actions (e.g., a magical cataclysm triggers tectonic shifts, large-scale engineering projects alter river flows and climate). This requires highly efficient, incremental algorithms. Cortial et al.\u0026rsquo;s \u0026ldquo;Procedural Tectonic Planets\u0026rdquo; explored interactive design using tectonics [12].\nBridging Scales (Procedural Zoom) Seamlessly connecting large-scale planetary generation with fine-grained local detail. Generate the planet coarsely, then use different, higher-frequency procedural techniques (or even rule-based systems) to add detail dynamically as the player zooms in or moves closer, ensuring consistency across scales.\nHistory and Culture Simulation Expanding on the Dwarf Fortress model. Tightly integrating the generation of civilizations, historical events, ruins, and lore with the physical world generation, so the environment shapes the history, and the history leaves visible marks on the environment.\nUnified \u0026amp; Modular Frameworks Creating flexible pipelines where developers can easily swap different modules (e.g., choose between fast fake erosion or slow physical simulation, plug in different climate models) based on project needs. The framework passes world data layers between modules.\nThe ultimate goal? To generate worlds that feel not just visually plausible but alive, with depth, history, and internal consistency – worlds that tell stories through their very landscapes.\nConclusion: The Art and Science of WorldSmithing Procedural world generation is a captivating blend of art and science. It draws on mathematical noise, geological simulation, climate science, and ecological principles, all orchestrated by algorithms to conjure digital universes from little more than a seed value.\nWe\u0026rsquo;ve journeyed from the basic concepts of noise and seeds through the intricacies of shaping continents with tectonics, carving details with erosion, breathing life with climate and biomes, and storing it all efficiently. We\u0026rsquo;ve seen that the most compelling results often come from a synthesis of techniques: the raw detail of noise, the structural foundation of simulation, and the refining touch of processes like erosion.\nThe tools and algorithms are becoming increasingly sophisticated, allowing even small teams or solo developers to create worlds of staggering scale and complexity. While challenges remain in achieving perfect realism, controllability, and performance, the future points towards even more powerful and integrated systems, potentially leveraging AI and real-time dynamics.\nUltimately, procedural generation empowers creators not just to build worlds, but to become digital worldsmiths, crafting universes that surprise, delight, and immerse players in ways previously unimaginable. By understanding the algorithms and harnessing the processes that shape our own planet, we unlock the potential to create countless others, each waiting to be explored.\nReferences [1] F. Tomassetti, ‘Diving Into Procedural Content Generation, With WorldEngine’, Smashing Magazine. [Online]. Available: https://www.smashingmagazine.com/2016/03/procedural-content-generation-introduction/ [2] ‘Perlin noise’, Wikipedia. [Online]. Available: https://en.wikipedia.org/wiki/Perlin_noise [3] ‘Simplex noise’, Wikipedia. [Online]. Available: https://en.wikipedia.org/wiki/Simplex_noise [4] A. J. Patel, ‘Procedural map generation on a sphere’, Red Blob Games. [Online]. Available: https://www.redblobgames.com/x/1843-planet-generation/ [5] ‘Value noise’, Wikipedia. May 21, 2021. [Online]. Available: https://en.wikipedia.org/w/index.php?title=Value_noise\u0026oldid=1024311499 [6] ‘Brownian surface’, Wikipedia. Oct. 16, 2024. [Online]. Available: https://en.wikipedia.org/w/index.php?title=Brownian_surface\u0026oldid=1251552796 [7] F. Gennari, ‘3DWorld: Domain Warping Noise’, 3DWorld. [Online]. Available: https://3dworldgen.blogspot.com/2017/05/domain-warping-noise.html [8] A. J. Patel, ‘Wraparound hexagon tile maps on a sphere’, Red Blob Games. [Online]. Available: https://www.redblobgames.com/x/1640-hexagon-tiling-of-sphere/ [9] A. J. Patel, ‘Hexagonal Grids’, Red Blob Games, 2013. [Online]. Available: https://www.redblobgames.com/grids/hexagons/ [10] A. J. Patel, ‘Polygonal Map Generation, HTML5 version’, Red Blob Games. [Online]. Available: https://simblob.blogspot.com/2017/09/mapgen2-html5.html [11] C. Davidson, ‘Tectonics.js: 3D Plate Tectonics in your web browser’. [Online]. Available: https://davidson16807.github.io/tectonics.js/blog/ [12] Y. Cortial, A. Peytavie, E. Galin, and E. Guérin, ‘Procedural Tectonic Planets’, Computer Graphics Forum, vol. 38, no. 2, pp. 1–11, May 2019, doi: 10.1111/cgf.13614. [13] ‘Unless it’s modeling islands, I find most terrain generators unnatural, at least\u0026hellip;’, Hacker News. [Online]. Available: https://news.ycombinator.com/item?id=14794095 [14] M. Mujtaba, ‘Simulating Hydraulic Erosion of Terrain’, gameidea. [Online]. Available: https://gameidea.org/2023/12/22/simulating-hydraulic-erosion-of-terrain/ [15] A. Paris, ‘Terrain Erosion on the GPU’, Make it Shaded. [Online]. Available: https://makeitshaded.github.io/terrain-erosion/ [16] B. Benes and R. Forsbach, ‘Layered data representation for visual simulation of terrain erosion’, in Proceedings Spring Conference on Computer Graphics, IEEE, 2001, pp. 80–86. [Online]. Available: https://ieeexplore.ieee.org/abstract/document/945341/ [17] A. J. Patel, mapgen4. (Apr. 2023). TypeScript. [Online]. Available: https://github.com/redblobgames/mapgen4 [18] A. J. Patel, ‘Mapgen4: rainfall’, Red Blob Games. [Online]. Available: https://simblob.blogspot.com/2018/09/mapgen4-rainfall.html [19] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. Fan, ‘Enabling new science with the ExoPlaSim 3D climate model’, Bulletin of the American Astronomical Society, vol. 53, no. 3, p. 1140, 2021. [20] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. L. Fan, ‘ExoPlaSim: Extending the planet simulator for exoplanets’, Monthly Notices of the Royal Astronomical Society, vol. 511, no. 3, pp. 3272–3303, 2022. [21] X. Mei, P. Decaudin, and B.-G. Hu, ‘Fast hydraulic erosion simulation and visualization on GPU’, in 15th Pacific Conference on Computer Graphics and Applications (PG’07), IEEE, 2007, pp. 47–56. Accessed: Mar. 30, 2025. [Online]. Available: https://ieeexplore.ieee.org/abstract/document/4392715/ [22] K. F. Fraedrich, H. Jansen, E. Kirk, U. Luksch, and F. Lunkeit, ‘The Planet Simulator: Towards a user friendly model’, Meteorologische Zeitschrift, vol. 14, no. 3, pp. 299–304, 2005. [23] J. Olsen, ‘Realtime procedural terrain generation’, 2004, Accessed: Mar. 30, 2025. [Online]. Available: https://citeseerx.ist.psu.edu/document?repid=rep1\u0026type=pdf\u0026doi=5961c577478f21707dad53905362e0ec4e6ec644 [24] L. Viitanen, ‘Physically based terrain generation: Procedural heightmap generation using plate tectonics’, 2012, Accessed: Mar. 30, 2025. [Online]. Available: https://www.theseus.fi/bitstream/handle/10024/40422/Viitanen_Lauri_2012_03_30.pdf [25] G. Cordonnier et al., ‘Large Scale Terrain Generation from Tectonic Uplift and Fluvial Erosion’, Computer Graphics Forum, vol. 35, no. 2, pp. 165–175, May 2016, doi: 10.1111/cgf.12820. ","permalink":"https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/","summary":"\u003cp\u003eEver stepped into a vast, sprawling game world and wondered, \u0026ldquo;How did they \u003cem\u003ebuild\u003c/em\u003e all this?\u0026rdquo; From the infinite blocky\nlandscapes of \u003cem\u003eMinecraft\u003c/em\u003e to the galaxy-spanning planets of \u003cem\u003eNo Man\u0026rsquo;s Sky\u003c/em\u003e or the intricate simulated histories of\n\u003cem\u003eDwarf Fortress\u003c/em\u003e, the answer often lies in a fascinating field: \u003cstrong\u003eProcedural Content Generation (PCG)\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eInstead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions –\nto generate game content automatically. This isn\u0026rsquo;t just about saving time (though it certainly helps!); it\u0026rsquo;s about\ncreating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that\u0026rsquo;s different\nevery single time you start a new game, a world generated just for you, with its own unique geography, climate, and\nmaybe even history. That\u0026rsquo;s the power and allure of PCG.\u003c/p\u003e","title":"Building New Worlds: A Deep Dive into Procedural Generation for Video Games"}]