<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2 | Tategoto Azarasi</title>
<meta name=keywords content="cpp,rust,wasm,webassembly,wasmtime,entt,boost-signals2,ffi,host-plugin,plugin-architecture,ecs,entity-component-system,event-handling,signals-and-slots,decoupling,refactoring,cross-language-communication,game-development,simulation,interoperability,c-api,bridge"><meta name=description content="Refactor a C++ EnTT host and Rust WASM plugin, replacing custom event triggers with Boost.Signals2 via Wasmtime for robust, decoupled FFI communication and advanced host-plugin interaction."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2"><meta property="og:description" content="Refactor a C++ EnTT host and Rust WASM plugin, replacing custom event triggers with Boost.Signals2 via Wasmtime for robust, decoupled FFI communication and advanced host-plugin interaction."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-07T21:50:58+08:00"><meta property="article:modified_time" content="2025-04-07T21:50:58+08:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Wasm"><meta property="article:tag" content="Webassembly"><meta property="article:tag" content="Wasmtime"><meta property="article:tag" content="Entt"><meta name=twitter:card content="summary"><meta name=twitter:title content="Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2"><meta name=twitter:description content="Refactor a C++ EnTT host and Rust WASM plugin, replacing custom event triggers with Boost.Signals2 via Wasmtime for robust, decoupled FFI communication and advanced host-plugin interaction."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2","item":"https://tategotoazarasi.github.io/en/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2","name":"Beyond Basic Bridging: Robust Eventing Between C\u002b\u002b EnTT and Rust WASM with Boost.Signals2","description":"Refactor a C++ EnTT host and Rust WASM plugin, replacing custom event triggers with Boost.Signals2 via Wasmtime for robust, decoupled FFI communication and advanced host-plugin interaction.","keywords":["cpp","rust","wasm","webassembly","wasmtime","entt","boost-signals2","ffi","host-plugin","plugin-architecture","ecs","entity-component-system","event-handling","signals-and-slots","decoupling","refactoring","cross-language-communication","game-development","simulation","interoperability","c-api","bridge"],"articleBody":"Let’s dive back into our evolving C++/Rust/WASM project. In our previous explorations, we successfully:\nEstablished robust methods for managing entity relationships (1:1, 1:N, N:N) within the C++ EnTT ECS framework. Built a bridge using Wasmtime for bidirectional communication and memory sharing between a C++ host and a Rust WASM module. Combined these concepts, creating a stable C FFI layer to allow a Rust WASM plugin to manage EnTT entity relationships residing in the C++ host. This layered architecture, leveraging EnTT’s data-oriented nature and a carefully crafted C FFI, proved effective in overcoming the inherent limitations of the WASM boundary. However, as projects grow, the need for more sophisticated interaction patterns emerges. Our previous solution relied on the WASM module calling host functions to perform actions. What if we need the host to notify the WASM plugin when certain events occur within the EnTT world? What if the WASM plugin needs to intercept or modify the behaviour of host operations?\nOur initial foray into this involved creating custom “trigger” and “patching” mechanisms. While these solutions functioned, their ad-hoc nature, often depending on string-based function lookups and requiring manual management of callbacks, revealed significant drawbacks, rapidly leading to systems that were complex, brittle, and difficult to maintain. We specifically encountered a number of challenges. A primary concern was type safety; the reliance on function names represented as strings provided absolutely no compile-time guarantee that a given WASM function’s signature would actually match what the host expected for a particular trigger or patch point. Another difficulty arose in connection management: manually keeping track of which WASM functions were registered to handle which specific events became increasingly cumbersome, and tasks like disconnecting or updating these registrations necessitated meticulous, error-prone bookkeeping. Furthermore, our custom system offered no inherent capability to control the execution order or apply prioritization when multiple WASM callbacks were registered for the very same event. The handling of results presented yet another significant problem: determining how results from potentially multiple WASM “patch” functions should be combined, or even whether one WASM plugin should possess the ability to entirely prevent an action initiated by the host, was left without any standard or well-defined approach within our custom framework. Lastly, a considerable amount of boilerplate code was required; implementing the necessary registration, lookup, and invocation logic for every single trigger or patch point involved substantial and repetitive coding effort on both the C++ host and the Rust WASM sides of the system.\nIt became clear that we needed a more robust, standardized, and feature-rich eventing system. Enter Boost.Signals2.\nThis post chronicles the refactoring journey, replacing our custom trigger and patching mechanisms with the powerful and flexible Boost.Signals2 library. We’ll explore how this transition simplifies the architecture, enhances type safety ( as much as possible across FFI), provides sophisticated features like automatic connection management, prioritization, and result combination (“combiners”), and ultimately leads to a more maintainable and extensible host-plugin interaction model.\nWe’ll dissect the significant changes on both the C++ host side (introducing a SignalManager, adapting WasmHost and EnttManager, and leveraging C++ macros for signal emission) and the Rust WASM side (implementing signal slots and a new connection mechanism). Prepare for a deep dive into leveraging a mature signaling library to orchestrate complex events across the WASM boundary.\nThe Case for Signals: Why Boost.Signals2? Before dismantling our existing trigger/patch system, let’s understand why Boost.Signals2 is a compelling alternative. At its core, Boost.Signals2 implements the signals and slots programming pattern, a powerful mechanism for decoupled communication.\nAt its core, Boost.Signals2 implements the signals and slots programming pattern, a potent mechanism facilitating decoupled communication within an application. You can conceptualize signals as event broadcasters. Whenever a particular event takes place in the system, such as an entity being on the verge of creation or a name component having just been added, a corresponding signal object is formally “emitted” or “fired,” announcing the event occurrence.\nComplementing signals are the slots, which function as the designated event receivers. These slots are typically functions or callable function objects, like C++ lambdas, that are explicitly registered or “connected” to one or more specific signals. The crucial behavior is that when a signal is emitted, the framework automatically invokes all the slots currently connected to that specific signal.\nThe link established between a particular signal and a slot is represented by a connection object. A critically important feature offered by Boost.Signals2, setting it apart from many manual systems, is its provision of automatic connection management. This means that if either the signal itself or a connected slot object ceases to exist (for instance, by going out of scope) or if the connection is explicitly severed, the library automatically breaks the link. This robust management prevents the common and problematic issue of dangling callbacks, where the system might attempt to invoke a function that no longer exists, which is a significant advantage when compared to manually managed callback lists.\nWhere Boost.Signals2 particularly demonstrates its power, especially for our integration scenario, is through its concept of combiners. A combiner is essentially a rule or a policy that dictates how the return values generated by multiple slots, all connected to the same signal, should be aggregated or processed into a single outcome. For example, when dealing with “before” events, like before_create_entity, we might desire a behavior where any single connected slot has the power to veto or prevent the original operation from proceeding. This can be effectively achieved by implementing a custom combiner that intelligently stops the invocation sequence and returns immediately as soon as any slot returns true, thereby signaling that the operation should be skipped. Conversely, for “after” events where connected slots might intend to modify a result, such as in the after_get_name scenario, we could employ a standard combiner like boost::signals2::optional_last_value. This specific combiner conveniently returns the value that was produced by the very last slot executed in the sequence, a behavior that becomes particularly useful when slots are assigned different priorities. It’s also worth noting that the default combiner behavior simply returns void if the slots have no return value, or it returns a boost::optional containing the result from the last slot that returned a non-void value.\nFurthermore, Boost.Signals2 allows slots to be connected with associated group priorities. This feature provides developers with fine-grained control over the precise order in which slots connected to the same signal are executed relative to one another, enabling more complex interaction sequences.\nFinally, the library offers various configurable levels of thread safety. While our current host application operates in a single thread, this capability is a crucial consideration for potentially multi-threaded host environments, ensuring that signal emissions and slot connections can be handled safely under concurrent conditions.\nBy adopting Boost.Signals2, we replace our bespoke, error-prone system with a well-tested, feature-rich library designed specifically for this kind of event handling, significantly improving robustness and maintainability.\nHost-Side Revolution: The SignalManager and Macro Magic The most significant changes occur on the C++ host side. We need a central place to define our signals and manage connections to WASM slots, and we need a non-intrusive way to emit these signals when our existing C API functions are called.\nIntroducing SignalManager This new class becomes the heart of our host-side eventing system.\nSignal Definitions: Inside signal_manager.h, we define specific signal types using boost::signals2::signal. The template arguments define the signature of the slots that can connect to it (return type and parameter types). Critically, we also specify a combiner type.\n// signal_manager.h (Illustrative Snippets) #include #include #include // For optional_last_value combiner namespace WasmHostSignals { // Custom Combiner: Stops invocation if any slot returns true. // Useful for \"before\" signals to allow skipping the original action. struct StopOnTrueCombiner { typedef bool result_type; // The combiner returns bool template\u003ctypename InputIterator\u003e result_type operator()(InputIterator first, InputIterator last) const { while (first != last) { // Dereference the iterator to get the slot's return value // Assuming slots connected to signals using this combiner return bool if (*first) { // If the slot returned true... return true; // ...stop and return true (indicating skip) } ++first; } return false; // No slot returned true, return false (don't skip) } }; // --- Signal Type Definitions --- // Example: Entity Creation // bool(): Return true to skip creation. using SignalBeforeCreateEntity = boost::signals2::signal\u003cbool(), StopOnTrueCombiner\u003e; // uint32_t(uint32_t original_id): Can modify the returned ID. using SignalAfterCreateEntity = boost::signals2::signal\u003cuint32_t(uint32_t), boost::signals2::optional_last_value\u003cuint32_t\u003e\u003e; // Example: Entity Destruction // bool(uint32_t entity_id): Return true to skip destruction. using SignalBeforeDestroyEntity = boost::signals2::signal\u003cbool(uint32_t), StopOnTrueCombiner\u003e; // void(uint32_t entity_id): Just a notification. using SignalAfterDestroyEntity = boost::signals2::signal\u003cvoid(uint32_t)\u003e; // Example: Get Name (Complex due to buffer) // bool(uint32_t id, char* buffer, size_t buffer_len): Can skip original get. // Note: WASM slot won't easily access the host buffer content here. // Signature might be simplified in practice. using SignalBeforeGetName = boost::signals2::signal\u003cbool(uint32_t, char*, size_t), StopOnTrueCombiner\u003e; // size_t(uint32_t id, char* buffer, size_t buffer_len, size_t original_req_len): Can modify required_len. using SignalAfterGetName = boost::signals2::signal\u003csize_t(uint32_t, char*, size_t, size_t), boost::signals2::optional_last_value\u003csize_t\u003e\u003e; // ... Define signal types for all relevant host operations ... class WasmHost; // Forward declaration class SignalManager { public: // Signals are public members for macros to access easily // Could be private with accessor methods too. SignalBeforeCreateEntity signal_before_create_entity; SignalAfterCreateEntity signal_after_create_entity; SignalBeforeDestroyEntity signal_before_destroy_entity; SignalAfterDestroyEntity signal_after_destroy_entity; // ... Other signal members ... SignalBeforeGetName signal_before_get_name; SignalAfterGetName signal_after_get_name; // ... and many more ... explicit SignalManager(WasmHost* host); ~SignalManager(); // Deleted copy/move constructors/assignment operators SignalManager(const SignalManager\u0026) = delete; SignalManager\u0026 operator=(const SignalManager\u0026) = delete; // ... // Connects a WASM function (by name) to a specific signal (by name) bool connectWasmSlot(const std::string\u0026 signal_name, const std::string\u0026 wasm_func_name, int priority); private: WasmHost* wasm_host_ptr_; // Needed to call back into WASM // Type definition for the factory function using WasmSlotConnectorFactory = std::function\u003cboost::signals2::connection( WasmHost* host, // Pointer to WasmHost boost::signals2::signal_base\u0026 signal, // Reference to the specific signal object const std::string\u0026 wasm_func_name, // Name of the WASM function int priority // Priority for connection )\u003e; // Map from signal name (string) to a factory that creates the connection lambda std::map\u003cstd::string, WasmSlotConnectorFactory\u003e slot_connector_factories_; // Initializes the slot_connector_factories_ map void initializeConnectorFactories(); // Structure to potentially track connection info (optional) struct WasmSlotInfo { std::string wasm_function_name; int priority = 0; boost::signals2::connection connection; // Stores the connection object }; // Store connections grouped by signal name (optional, for management) std::map\u003cstd::string, std::vector\u003cstd::shared_ptr\u003cWasmSlotInfo\u003e\u003e\u003e wasm_connections_; }; } // namespace WasmHostSignals Several critical design decisions shape the effectiveness of the SignalManager. The choice of combiners is fundamental to defining the interaction logic for different event types. For instance, we specifically define our custom StopOnTrueCombiner for signals intended to run before an operation (like before_create_entity), enabling any connected slot to prevent the original action simply by returning true. For signals emitted after an operation, especially those where slots might wish to modify a return value (such as after_create_entity potentially altering the returned ID), we utilize the standard boost::signals2::optional_last_value combiner. This combiner has the behavior of returning the value produced by the very last slot that executed in the sequence, a feature that integrates naturally with the priority system. In cases where the signal serves purely as a notification (like after_destroy_entity), the default combiner, which simply returns void, is perfectly adequate.\nThe definition of signal signatures, such as bool(), uint32_t(uint32_t), void(uint32_t), and so forth, plays a crucial role in establishing the contract for any slots wishing to connect. These signatures dictate the exact parameter types and the return type that a compliant slot function must adhere to, which is essential for maintaining type safety across the system. It’s noteworthy that even complex scenarios, like the before_get_name signal, initially include buffer details (char*, size_t) in their signature to match the underlying C API. However, we recognize the practical difficulties of WASM slots directly manipulating host memory buffers via these parameters and anticipate that the actual WASM slot implementation might simplify its approach, perhaps ignoring these buffer arguments and opting to call back into the host via another FFI function if the buffer content is needed.\nConnecting WASM functions is facilitated by the connectWasmSlot public method. This function serves as the designated entry point that the WASM module will ultimately invoke, using the intermediary host_connect_signal FFI function, to register its handlers as slots. connectWasmSlot requires the string name of the target signal on the host and the string name of the function exported by the WASM module that should be connected to it.\nInternally, the setup relies heavily on the initializeConnectorFactories private method, which is executed within the SignalManager’s constructor. This method’s responsibility is to populate the slot_connector_factories_ map. This map uses the string name of a signal (e.g., the literal string \"before_create_entity\") as its key. The corresponding value for each key is a C++ lambda function, which we term a “lambda factory.”\nEach lambda factory stored within the slot_connector_factories_ map is precisely engineered to perform a single, specific task: it knows how to connect a WASM function, identified by its name string, to one particular, hardcoded Boost.Signals2 signal member within the SignalManager instance (e.g., the factory associated with the key \"before_create_entity\" knows it must operate on the signal_before_create_entity member). To achieve this, the factory lambda typically captures the this pointer of the SignalManager or sometimes directly captures the specific signal member it targets. It’s designed to accept several arguments: a pointer to the WasmHost instance (necessary for invoking WASM functions), a reference to the specific target signal object (passed as a signal_base\u0026 for polymorphism within the factory signature, requiring a static_cast back to the concrete signal type inside), the string name of the WASM function to connect, and the desired connection priority. The core action within the factory lambda is the call signal.connect(priority, [host, wasm_func] (...) { ... }). The crucial element here is the second lambda passed to signal.connect – this inner lambda is the actual slot wrapper. This wrapper lambda is precisely what the Boost.Signals2 framework will execute whenever the specific Boost signal it’s connected to is emitted. The logic embedded within this slot wrapper lambda is responsible for bridging the gap to Wasmtime. It receives arguments directly from the Boost signal emission, matching the Boost signal’s defined signature (for example, the original_id parameter for signal_after_create_entity). Its first task is to marshal these incoming C++ arguments into the format Wasmtime expects, typically a std::vector. Next, it invokes the target WASM function by name using the WasmHost pointer and its callFunction method (e.g., host-\u003ecallFunction(wasm_func, args)), carefully specifying the expected ReturnType based on the WASM function’s FFI signature (like int32_t for a WASM function returning a boolean, or uint32_t for one returning an entity ID). This call inherently involves handling potential Wasmtime traps, usually by checking the Result returned by callFunction. If the WASM call is successful, the wrapper then unmarshals the resulting wasmtime::Val back into the C++ data type that is expected by the combiner associated with the Boost signal (for instance, converting an int32_t result back to a bool for signals using the StopOnTrueCombiner, or to a uint32_t for those using optional_last_value). Finally, this unmarshalled C++ value is returned by the slot wrapper lambda, feeding it back into the Boost signal’s processing mechanism ( specifically, its combiner).\nTo correctly route the connection request, the connectWasmSlot method must determine the actual boost::signals2::signal member object corresponding to the provided signal_name string. The current implementation employs a straightforward, albeit potentially lengthy, if/else if cascade to perform this mapping. It compares the input string against known signal names and, upon finding a match, passes a reference to the appropriate signal member ( like signal_before_create_entity) into the corresponding factory lambda retrieved from the slot_connector_factories_ map.\nFinally, robust connection management is implicitly handled by Boost.Signals2. While the code includes an optional mechanism to store the boost::signals2::connection object returned by connect within a wasm_connections_ map ( keyed by signal name), which could facilitate more granular future management like targeted disconnections, the primary benefit comes from the SignalManager’s destructor. Within the destructor, all stored connections are explicitly disconnected. More importantly, even without this explicit storage, Boost guarantees that connections are automatically broken if either the signal or the slot’s context (which isn’t directly applicable here since our slots are host-side lambdas calling WASM) is destroyed, significantly mitigating the risk of dangling pointers or callbacks.\nWasmHost now creates and owns both the SignalManager and the EnttManager, passing the SignalManager pointer to the EnttManager constructor. EnttManager itself is simplified – it no longer manages triggers directly but uses its SignalManager pointer to emit signals where appropriate (primarily in the onEntityDestroyedSignalHook).\nEmitting Signals via Macros (host_macros.h) We need to trigger these signals whenever the corresponding host C API functions are called from WASM. We could manually insert signal emission code into every host function lambda in host.cpp, but that’s repetitive and error-prone. Instead, we use C++ macros defined in host_macros.h.\n// host_macros.h (Illustrative Snippet) #pragma once #include \"entt_api.h\" #include \"signal_manager.h\" #include \"wasm_host.h\" #include #include #include #include #include // For runtime_error // Helper within namespace to avoid polluting global scope namespace WasmHostUtils { // (Keep read_wasm_string_helper, check_result, handle_wasm_trap helpers here) } // namespace WasmHostUtils // Macro to define a host function taking 0 arguments and returning a value #define DEFINE_HOST_FUNC_0_ARGS_RET(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE, RET_TYPE, WASM_RET_TYPE, DEFAULT_RET) \\ (LINKER).func_new( \\ \"env\", (NAME), (WASM_TYPE), \\ [(HOST_PTR), (MGR_HANDLE)]( \\ wasmtime::Caller caller, \\ wasmtime::Span args, \\ wasmtime::Span results \\ ) -\u003e wasmtime::Result { \\ using namespace WasmHostSignals; \\ using namespace WasmHostUtils; \\ SignalManager\u0026 sig_mgr = (HOST_PTR)-\u003egetSignalManager(); \\ RET_TYPE final_result = (DEFAULT_RET); /* Initialize with default */ \\ try { \\ /* --- Before Signal --- */ \\ /* Assuming signal names match: before_NAME */ \\ bool skip = sig_mgr.signal_##before_##C_API_FUNC(); \\ if (skip) { \\ std::cout \u003c\u003c \"[Host Signal] Skipping \" \u003c\u003c (NAME) \u003c\u003c \" due to before_ signal.\" \u003c\u003c std::endl; \\ } else { \\ /* --- Original C API Call --- */ \\ RET_TYPE original_result = C_API_FUNC((MGR_HANDLE)); \\ \\ /* --- After Signal --- */ \\ /* Assuming signal names match: after_NAME */ \\ /* Pass original result, combiner decides final result */ \\ final_result = sig_mgr.signal_##after_##C_API_FUNC(original_result); \\ } \\ /* --- Marshall result for WASM --- */ \\ results[0] = wasmtime::Val(static_cast(final_result)); \\ return std::monostate(); \\ } catch (const wasmtime::Trap\u0026 trap) { \\ std::cerr \u003c\u003c \"[Host Function Error] \" \u003c\u003c (NAME) \u003c\u003c \" trapped: \" \u003c\u003c trap.message() \u003c\u003c std::endl; \\ return wasmtime::Trap(trap.message()); /* Create new trap */ \\ } catch (const std::exception\u0026 e) { \\ std::cerr \u003c\u003c \"[Host Function Error] \" \u003c\u003c (NAME) \u003c\u003c \" exception: \" \u003c\u003c e.what() \u003c\u003c std::endl; \\ return wasmtime::Trap(std::string(\"Host function \") + (NAME) + \" failed: \" + e.what()); \\ } catch (...) { \\ std::cerr \u003c\u003c \"[Host Function Error] \" \u003c\u003c (NAME) \u003c\u003c \" unknown exception.\" \u003c\u003c std::endl; \\ return wasmtime::Trap(std::string(\"Host function \") + (NAME) + \" failed with unknown exception.\"); \\ } \\ } \\ ).unwrap() /* Use unwrap() for example, check Result in prod */ // Other macros for different signatures (e.g., U32_VOID, U32_STR_VOID, U32_GET_STR...) // Example: Macro for uint32_t argument, void return #define DEFINE_HOST_FUNC_U32_VOID(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE) \\ (LINKER).func_new( \\ \"env\", (NAME), (WASM_TYPE), \\ /* Lambda implementation similar to above */ \\ [(HOST_PTR), (MGR_HANDLE)](/* ... */) -\u003e wasmtime::Result { \\ /* ... extract uint32_t arg ... */ \\ uint32_t arg0_u32 = /* ... */; \\ try { \\ bool skip = sig_mgr.signal_##before_##C_API_FUNC(arg0_u32); \\ if (!skip) { \\ C_API_FUNC((MGR_HANDLE), arg0_u32); \\ sig_mgr.signal_##after_##C_API_FUNC(arg0_u32); \\ } else { /* Log skip */ } \\ return std::monostate(); /* Void return */ \\ } catch(/* ... trap/exception handling ... */) { /* ... */ } \\ } \\ ).unwrap() // Example: Macro for uint32_t argument, getting a string #define DEFINE_HOST_FUNC_U32_GET_STR(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE) \\ (LINKER).func_new( \\ \"env\", (NAME), (WASM_TYPE), \\ /* Lambda implementation */ \\ [(HOST_PTR), (MGR_HANDLE)](/* ... */) -\u003e wasmtime::Result { \\ /* ... extract uint32_t id, char* buffer_ptr_offset, size_t buffer_len ... */ \\ uint32_t entity_id = /* ... */; \\ int32_t buffer_offset = /* ... */; \\ size_t buffer_len = /* ... */; \\ char* wasm_buffer = nullptr; \\ try { \\ /* Get memory and calculate wasm_buffer pointer safely */ \\ auto mem_span_opt = WasmHostUtils::get_wasm_memory_span_helper(caller); \\ if (!mem_span_opt) return wasmtime::Trap(\"Failed to get WASM memory\"); \\ auto\u0026 mem_span = mem_span_opt.value(); \\ if (buffer_offset \u003e= 0 \u0026\u0026 buffer_len \u003e 0 /* ... more bounds checks ... */){ \\ wasm_buffer = reinterpret_cast(mem_span.data() + buffer_offset);\\ } else if (buffer_offset != 0 || buffer_len \u003e 0) { /* Invalid buffer args */ } \\ \\ size_t final_req_len = 0; /* Default */ \\ bool skip = sig_mgr.signal_##before_##C_API_FUNC(entity_id, wasm_buffer, buffer_len); \\ if (!skip) { \\ size_t original_req_len = C_API_FUNC((MGR_HANDLE), entity_id, wasm_buffer, buffer_len); \\ /* Pass original_req_len to after signal */ \\ final_req_len = sig_mgr.signal_##after_##C_API_FUNC(entity_id, wasm_buffer, buffer_len, original_req_len); \\ } else { /* Log skip, return 0 */ final_req_len = 0; } \\ results[0] = wasmtime::Val(static_cast(final_req_len)); /* Return size_t as i32 */ \\ return std::monostate(); \\ } catch(/* ... trap/exception handling ... */) { /* ... */ } \\ } \\ ).unwrap() // ... More macros for other patterns ... The C++ macros defined in host_macros.h encapsulate several key elements essential for integrating the host’s C API functions with the Boost.Signals2 event system when exposing them to the WASM module via Wasmtime. Their primary function is boilerplate reduction; they conveniently wrap the necessary linker.func_new call required by Wasmtime and construct the complex lambda function that serves as the actual host function implementation callable by WASM.\nThese macros are highly parameterized to handle different function signatures. They typically accept arguments such as the Wasmtime linker object, a pointer to the WasmHost instance, the opaque handle for the EnttManager, the specific name the WASM module will use to import the function (referred to as NAME), a pointer to the underlying C API function being wrapped (C_API_FUNC), the corresponding Wasmtime function type definition, the expected C++ return type of the C API function, the corresponding WASM ABI type for the return value (e.g., int32_t for a C int or uint32_t), and a default return value to use if the operation is skipped by a signal.\nWithin the lambda generated by the macro, specific captures are essential. The lambda captures the HOST_PTR, which is crucial for gaining access to the SignalManager instance needed to emit signals, and it also captures the MGR_HANDLE, the opaque pointer required to invoke the original C API function.\nThe lambda implementation handles the intricate details of argument and result marshalling across the WASM boundary. It’s responsible for extracting incoming arguments from the Span provided by Wasmtime, converting them to the types expected by the C API function. For functions dealing with buffers or strings, it performs necessary bounds checking, often using helper functions, to ensure memory safety when interacting with WASM’s linear memory. After the operation and potential signal handling, it marshals the final computed result back into the Span for the WASM caller.\nA core responsibility of the macro-generated lambda is signal emission. It first retrieves the SignalManager instance via the captured HOST_PTR. Then, before invoking the wrapped C API function, it emits the corresponding “before” signal. This emission uses C++ preprocessor token pasting (##) to dynamically construct the correct signal member name based on the C API function’s name (for example, combining signal_##before_## with entt_manager_create_entity results in signal_before_entt_manager_create_entity). The lambda carefully checks the return value provided by the \" before\" signal’s combiner (e.g., the boolean result from StopOnTrueCombiner). If this return value indicates that the operation should be skipped (typically true), the lambda logs a message and immediately returns the predefined default value to WASM, bypassing the call to the original C API function and the emission of the “after” signal. If the “before” signal does not indicate a skip, the lambda proceeds to call the original C API function (C_API_FUNC) using the captured manager handle and extracted arguments. Following the C API call, it emits the corresponding “after” signal, passing any relevant original arguments along with the result obtained from the C API call. Finally, it captures the return value generated by the “after” signal’s combiner (which might have been modified by WASM slots, for example, using optional_last_value) and uses this value as the final_result that is ultimately marshalled and returned to the WASM caller.\nLastly, robust error handling is built into the generated lambda. It includes comprehensive try-catch blocks designed to catch standard C++ exceptions (std::exception) as well as Wasmtime-specific traps (wasmtime::Trap) that might occur during the execution of the C API function, the signal emissions, or the slot invocations within WASM. These caught exceptions or traps are then safely converted into new wasmtime::Trap objects, ensuring that host-side errors are propagated back to the WASM runtime gracefully without crashing the host process. Special care is taken to correctly handle the move-only semantics of wasmtime::Trap when re-throwing or constructing new traps.\nIn host.cpp, we now replace the direct lambda definitions with calls to these macros for each host function we want to expose with signal support.\n// host.cpp (main, illustrative usage) // ... includes, setup ... // Get pointers and references WasmHost host(wasm_path); EnttManager* manager_raw_ptr = \u0026host.getEnttManager(); EnttManagerHandle* manager_handle = reinterpret_cast\u003cEnttManagerHandle*\u003e(manager_raw_ptr); Linker\u0026 linker = host.getLinker(); Store\u0026 store = host.getStore(); WasmHost* host_ptr = \u0026host; // For macro capture // SignalManager\u0026 signal_manager = host.getSignalManager(); // Not directly needed here host.setupWasi(); // Define function types... // Use the macros to define host functions DEFINE_HOST_FUNC_0_ARGS_RET(linker, host_ptr, manager_handle, \"host_create_entity\", entt_manager_create_entity, void_to_i32_type, uint32_t, int32_t, FFI_NULL_ENTITY); DEFINE_HOST_FUNC_U32_VOID(linker, host_ptr, manager_handle, \"host_destroy_entity\", entt_manager_destroy_entity, i32_to_void_type); DEFINE_HOST_FUNC_U32_GET_STR(linker, host_ptr, manager_handle, \"host_get_name\", entt_manager_get_name, i32ptrlen_to_size_type); // ... Define ALL other host functions using the appropriate macros ... // Define the signal connection function (doesn't need a macro as it doesn't wrap a C API call) linker.func_new( \"env\", \"host_connect_signal\", /* type */ ..., // Capture signal_manager by reference [\u0026signal_manager = host.getSignalManager()](...) { // Note capture detail // ... implementation using signal_manager.connectWasmSlot ... } ).unwrap(); host.initialize(); // Instantiate // ... Call connect_all_signals in WASM ... // ... Call test_relationships_oo in WASM ... // ... Manual test section calling linker.get() to ensure signal firing ... Connecting WASM Slots: host_connect_signal How does the WASM module tell the host, “Please connect my wasm_before_create_entity function to your before_create_entity signal”? We provide one more host function specifically for this: host_connect_signal.\nThis specific host function, host_connect_signal, is defined directly within host.cpp using linker.func_new and a lambda, rather than relying on one of the host function macros, primarily because it doesn’t wrap an existing C API function but instead provides new functionality specific to the signal system. The lambda implementation performs several distinct steps when invoked by the WASM module.\nFirst, it receives its necessary input arguments directly from the WASM caller via the Span args. These arguments consist of pointers and lengths representing the signal name (signal_name_ptr, signal_name_len) and the WASM function name (wasm_func_name_ptr, wasm_func_name_len), along with an integer representing the desired connection priority.\nNext, to safely retrieve the actual string values from the potentially insecure pointers provided by WASM, the lambda utilizes the WasmHostUtils::read_wasm_string_helper utility function. This helper reads the specified number of bytes from the WASM linear memory at the given offsets, performing necessary bounds checks and returning the strings.\nCrucially, the lambda is defined in a way that it captures a reference to the host’s central SignalManager instance. This captured reference provides the context needed to interact with the signal system.\nWith the signal and function names successfully read and the SignalManager accessible, the core logic of the lambda is executed: it invokes the connectWasmSlot method on the captured signal_manager, passing the retrieved signal_name, wasm_func_name, and priority as arguments. This call delegates the actual task of creating and registering the signal-slot connection to the SignalManager.\nFinally, after the connection attempt, the lambda returns the outcome back to the WASM module. It takes the boolean success status returned by connectWasmSlot and marshals it into the expected FFI format, typically an int32_t (1 for success, 0 for failure), which is placed into the Span results for the WASM caller to interpret.\nThis provides the crucial link, allowing the WASM module to dynamically register its handlers during its initialization phase.\nWASM-Side Adaptation: Becoming a Signal Client The Rust WASM module now needs to adapt to this new signal-based system.\nThe first step in adapting the Rust WASM module involves dismantling the previous custom eventing infrastructure. This cleanup requires removing the remnants of the now-obsolete trigger and patching systems. Specifically, the src/patch_handler.rs file, along with the PatchHandler trait defined within it, must be entirely deleted from the project. Correspondingly, within the FFI layer defined in src/ffi.rs, the extern \"C\" import declarations that previously brought in the host functions related to registering patches and triggers, namely host_register_patch and host_register_trigger, need to be removed. Finally, the exported WASM functions that served as the initialization entry points for these old systems, init_patches and init_triggers, must also be removed from the exports list, as the host will no longer call them.\nWith the old plumbing removed, a new mechanism must be established to allow the WASM module to initiate the connection of its handlers to the host’s signals. This new process involves several coordinated steps within the Rust code. First, the necessary FFI import declaration for the new host function responsible for handling connections, host_connect_signal, must be added to the extern \"C\" block located in src/ffi.rs, mirroring the function signature defined on the host side. Second, to encapsulate the unsafe FFI interaction, a safe Rust wrapper function, ffi::connect_signal, needs to be created. This wrapper function should accept standard Rust string slices (\u0026str) for the signal name and the WASM function name, along with an integer priority. Its implementation will handle the necessary conversions of these Rust strings into null-terminated CStrings suitable for the FFI call and will contain the unsafe block required to invoke the imported host_connect_signal function, returning a boolean indicating the success or failure of the connection attempt. Third, the responsibility for orchestrating all necessary connections from the WASM side is centralized within a new function, core::connect_all_signals, implemented in src/core.rs. This function’s sole purpose is to repeatedly call the safe ffi::connect_signal wrapper, systematically pairing the known string names of the signals exposed by the host (such as \"before_create_entity\") with the string names of the corresponding exported WASM functions designed to handle those signals (like \"wasm_before_create_entity\"), along with their desired priorities. Fourth and finally, to expose this connection logic to the host, a C-compatible function named connect_all_signals needs to be exported from src/ffi.rs using #[no_mangle] pub unsafe extern \"C\". The implementation of this exported function simply delegates the actual work by calling core::connect_all_signals(). The C++ host application will then be responsible for invoking this single exported connect_all_signals function exactly once, typically right after the WASM module has been successfully instantiated, thereby triggering the registration of all defined WASM signal handlers with the host’s SignalManager.\n// src/ffi.rs (Snippets) // ... other imports ... #[link(wasm_import_module = \"env\")] unsafe extern \"C\" { // --- Signal Connection Import (NEW) --- fn host_connect_signal( signal_name_ptr: *const c_char, signal_name_len: usize, wasm_func_name_ptr: *const c_char, wasm_func_name_len: usize, priority: c_int, ) -\u003e c_int; // Returns bool (0 or 1) for success // ... other host function imports remain ... } // --- Signal Connection Wrapper (NEW) --- pub fn connect_signal( signal_name: \u0026str, wasm_func_name: \u0026str, priority: i32, ) -\u003e bool { // ... (Implementation as shown previously, using CString::new and unsafe call) ... let success_code = unsafe { host_connect_signal(...) }; success_code != 0 } // --- Exported Function for Host to Trigger Connections --- #[no_mangle] pub unsafe extern \"C\" fn connect_all_signals() { println!(\"[WASM Export] connect_all_signals called. Connecting handlers via core...\"); crate::core::connect_all_signals(); // Delegate to core logic } // --- Exported Signal Handler Implementations (Slots) --- // ... (Functions like wasm_before_create_entity as defined previously) ... // --- Test Runner Export --- #[no_mangle] pub unsafe extern \"C\" fn test_relationships_oo() { // ... runs core::run_entt_relationship_tests_oo ... } // src/core.rs (Snippet) use crate::ffi::{connect_signal, DEFAULT_SIGNAL_PRIORITY /* ... */}; /// Connects all WASM signal handlers (slots) to the corresponding host signals. /// Called by the host via the exported `connect_all_signals` function in ffi.rs. pub fn connect_all_signals() { println!(\"[WASM Core] Connecting WASM functions to host signals...\"); let mut success = true; // Connect slots for host_create_entity success \u0026= connect_signal( \"before_create_entity\", // Host signal name (string) \"wasm_before_create_entity\", // Exported WASM function name (string) DEFAULT_SIGNAL_PRIORITY, ); success \u0026= connect_signal( \"after_create_entity\", // Host signal name \"wasm_after_create_entity\", // Exported WASM function name DEFAULT_SIGNAL_PRIORITY, ); // ... connect ALL other slots similarly ... success \u0026= connect_signal( \"after_get_profile_for_player\", \"wasm_after_get_profile_for_player_high_prio\", // Name matches exported function DEFAULT_SIGNAL_PRIORITY + 100, // Higher priority number ); if success { /* Log success */ } else { /* Log failure */ } } // ... run_entt_relationship_tests_oo() remains largely the same ... Implementing WASM Signal Slots The Rust functions that were previously designated for the custom patching mechanism, such as prefix_create_entity, are now either repurposed or replaced by new functions specifically designed to serve as the signal slots within the Boost.Signals2 framework. For these functions to correctly receive signals emitted by the host, they must adhere to two fundamental requirements.\nFirstly, they must be properly exported from the WASM module so that the host’s SignalManager (via Wasmtime) can locate and invoke them when connecting or firing signals. This necessitates marking each slot function with #[no_mangle] to prevent Rust’s name mangling and declaring it as pub unsafe extern \"C\" to ensure C-compatible linkage and calling conventions. Critically, the exact name assigned to each exported slot function in the Rust code must perfectly match the string literal used when connecting it within the core::connect_all_signals function; any discrepancy will result in a connection failure.\nSecondly, and equally crucial, the function signature of each WASM slot – encompassing both its parameters and its return type – must precisely align with the expectations hardcoded into the corresponding host-side slot wrapper lambda. These wrapper lambdas are defined within the SignalManager::initializeConnectorFactories method in the C++ host. Any mismatch in the number of parameters, their types, or the return type will lead to undefined behavior or runtime traps when the host attempts to call the WASM slot. For instance, the slot wasm_before_create_entity() is expected by the host wrapper to take no arguments and return a c_int, where 0 signifies continuation and 1 indicates the operation should be skipped. Similarly, wasm_after_create_entity(original_id: u32) must accept a u32 representing the original entity ID and return a u32, allowing it the opportunity to modify the ID passed back through the signal chain. A slot like wasm_after_destroy_entity(entity_id: u32) is expected to accept the ID but return void, as it functions purely as a notification. More complex cases like wasm_before_get_name(entity_id: u32, buffer_len: u32) demonstrate a simplification in the FFI signature; the host wrapper expects it to receive the entity ID and the intended buffer length but not the host-side buffer pointer itself, returning a c_int (0 or 1) to potentially veto the get_name operation. This design choice avoids the complexity and potential unsafety of the WASM slot directly accessing the host buffer; should the slot require the actual string content during this “before” phase, it would need to initiate a separate call back into the host (e.g., using host_get_name itself). Correspondingly, the wasm_after_get_name(entity_id: u32, buffer_len: u32, original_req_len: u32) slot receives the ID, buffer length, and the original required length calculated by the C API, and is expected to return a u32 representing the potentially adjusted required length. This pattern of precisely matching the parameter list and return type defined implicitly by the host’s slot wrapper lambda must be rigorously applied to all other WASM functions intended to serve as signal slots for the various host events.\n// src/ffi.rs (Slot Implementation Snippets) // --- host_create_entity --- #[no_mangle] pub unsafe extern \"C\" fn wasm_before_create_entity() -\u003e c_int { println!(\"[WASM Slot] \u003c\u003c\u003c before_create_entity called\"); 0 // Allow creation } #[no_mangle] pub unsafe extern \"C\" fn wasm_after_create_entity(original_id: u32) -\u003e u32 { println!(\"[WASM Slot] \u003c\u003c\u003c after_create_entity called (Original ID: {})\", original_id); original_id // Return original ID } // --- host_get_profile_for_player --- #[no_mangle] pub unsafe extern \"C\" fn wasm_before_get_profile_for_player(player_id: u32) -\u003e c_int { println!(\"[WASM Slot] \u003c\u003c\u003c before_get_profile_for_player called (P: {})\", player_id); 0 // Allow get } // Default priority postfix slot #[no_mangle] pub unsafe extern \"C\" fn wasm_after_get_profile_for_player(player_id: u32, original_profile_id: u32) -\u003e u32 { println!(\"[WASM Slot] \u003c\u003c\u003c after_get_profile_for_player called (P: {}, OrigProf: {})\", player_id, original_profile_id); // This one just observes original_profile_id } // High priority postfix slot (runs AFTER the default one) #[no_mangle] pub unsafe extern \"C\" fn wasm_after_get_profile_for_player_high_prio(player_id: u32, current_profile_id: u32) -\u003e u32 { println!( \"[WASM Slot][HIGH PRIO] \u003c\u003c\u003c after_get_profile_for_player_high_prio called (P: {}, CurrentProf: {})\", player_id, current_profile_id // current_profile_id is the result from the previous slot/original call ); // Example: Override profile ID for player 2 if player_id == 2 { println!(\" \u003e [HIGH PRIO] Changing profile for player 2 to 888!\"); return 888; // Override the value } current_profile_id // Otherwise, return the value passed in } // ... Implement ALL other exported slot functions ... Now, when the host emits signal_before_create_entity, the wasm_before_create_entity function in the WASM module will be executed. When the host emits signal_after_get_profile_for_player, both wasm_after_get_profile_for_player and wasm_after_get_profile_for_player_high_prio will run (in priority order), and the optional_last_value combiner will ensure the final result seen by the host macro is the value returned by the high-priority slot.\nThe Full Picture: Execution Flow with Signals To understand the interplay between the WASM module, the host, and the signal system, let’s trace the sequence of events when the WASM module initiates an entity creation by calling host_create_entity. We assume the WASM slots wasm_before_create_entity and wasm_after_create_entity have already been successfully connected to the corresponding host signals via connect_all_signals.\nThe process begins within the WASM module. A call to the higher-level entity::create_entity() function occurs, which in turn invokes the lower-level FFI wrapper ffi::create_entity(). Inside this FFI wrapper, the unsafe block executes the actual call across the boundary: host_create_entity().\nControl now transfers to the C++ host. The specific lambda wrapper function, previously generated by the DEFINE_HOST_FUNC_0_ARGS_RET macro and registered with Wasmtime’s linker for the name host_create_entity, receives this incoming call. The first action within this host lambda is to obtain a reference to the SignalManager. Following this, the lambda emits the signal_before_create_entity signal, passing no arguments as per the signal’s definition.\nThe Boost.Signals2 framework intercepts this signal emission and proceeds to invoke any slots connected to signal_before_create_entity. In our scenario, this triggers the execution of the host-side slot wrapper lambda that was created specifically for the WASM function \"wasm_before_create_entity\". This slot wrapper lambda prepares its arguments (none in this case) and executes a Wasmtime call back into the module: host-\u003ecallFunction(\"wasm_before_create_entity\", ...).\nExecution jumps back to the WASM module, specifically to the wasm_before_create_entity() function. This function runs its logic, typically printing a log message indicating it was called, and then returns its result, which is 0 ( representing false in C ABI boolean convention), signaling that the operation should proceed.\nBack in the host, the slot wrapper lambda receives the int32_t result (0) from the Wasmtime call and unmarshals it into a C++ bool (false). This boolean result is then passed back to the Boost.Signals2 framework. The StopOnTrueCombiner associated with signal_before_create_entity receives this false value. Since it’s not true, the combiner allows processing to continue (if other slots were connected, they would run now). Ultimately, the combiner returns false to the original host function lambda that emitted the signal.\nThe host lambda checks the skip flag returned by the combiner. Since it’s false, the lambda determines that the operation should not be skipped and proceeds with the core logic. It now calls the underlying C API function: entt_manager_create_entity(manager_handle). This C API function, in turn, calls the EnttManager::createEntity() method on the C++ manager object. Inside the manager, registry_.create() is invoked, a new EnTT entity is created, its ID is converted to uint32_t, a creation log message is printed, and this uint32_t ID is returned.\nThe ID (original_result) travels back up the call stack from EnttManager to the C API function, and then to the host lambda. Now, the host lambda emits the second signal: signal_after_create_entity(original_result), passing the newly created entity’s ID.\nAgain, Boost.Signals2 takes over, invoking the slots connected to signal_after_create_entity. This leads to the execution of the slot wrapper lambda associated with \"wasm_after_create_entity\", which is called with the original_id. This wrapper lambda prepares its arguments (packing the original_id into a wasmtime::Val) and calls back into the module: host-\u003ecallFunction(\"wasm_after_create_entity\", ...). Note the expected return is int32_t because the WASM function returns u32, which fits in i32.\nExecution returns to WASM’s wasm_after_create_entity(original_id) function. It executes its logic (e.g., logging) and, in this example, simply returns the original_id it received.\nThe host slot wrapper receives this ID as an int32_t result from Wasmtime and unmarshals it back into a uint32_t. This value is passed to the Boost.Signals2 framework. The optional_last_value combiner associated with signal_after_create_entity receives this result. As it’s the only (or the last) slot executed, the combiner wraps this value and returns boost::optional(result) to the host lambda.\nThe host lambda receives the combiner’s result (boost::optional). It extracts the contained value (or would use a default if the optional were empty, though not expected here). This extracted value becomes the final_result. The lambda then marshals this final_result (the entity ID) into the results span as a wasmtime::Val of kind I32 for the original WASM caller.\nFinally, the host lambda completes its execution by returning success (std::monostate()) to the Wasmtime runtime. Wasmtime then returns control back to the point where the initial host_create_entity() call was made within WASM’s ffi::create_entity function. This function receives the ID and returns it up to entity::create_entity, which then uses Entity::new(id) to create the final Rust wrapper object for the newly created entity. This completes the entire cross-boundary call sequence, including signal interceptions.\nThis detailed flow illustrates the powerful orchestration provided by Boost.Signals2, handling slot invocation, argument passing (from signal to slot wrapper), return value combination, and allowing interception points before and after the core C API logic, all while integrating with Wasmtime calls across the FFI boundary.\nBenefits and Considerations Revisited This significant refactoring effort yields substantial benefits for the overall architecture and maintainability of the C++/Rust/WASM integration. Foremost among these is the establishment of a unified mechanism; the Boost.Signals2 system now replaces both the previous custom trigger implementation and the separate patching framework, providing a single, consistent model for handling events between the host and the plugin. This contributes significantly to the system’s robustness. Boost.Signals2 inherently manages signal-slot connections automatically, effectively preventing the common issue of dangling callbacks that could arise in manual systems. Furthermore, its built-in combiner concept offers standard and predictable methods for aggregating or processing results when multiple listeners (WASM slots) respond to the same host signal. The refactoring also promotes better decoupling within the host application. The C API implementation layer (entt_api.cpp), for instance, becomes considerably simpler as it no longer needs any intrinsic awareness of the trigger or patching logic. The EnttManager class is similarly streamlined, offloading event management responsibilities. Instead, the newly introduced C++ macros and the dedicated SignalManager now cleanly encapsulate the logic related to signal emission and connection management. The system gains considerable flexibility through the features offered by Boost.Signals2; assignable priorities allow for precise control over the execution order of different WASM slots connected to the same signal, while the availability of various combiners enables the implementation of diverse interaction patterns, such as allowing WASM to veto host actions, modify return values, or simply receive notifications. Ultimately, this leads to improved maintainability. The clearer separation of concerns between core logic, the C API, the signal management infrastructure, and the WASM FFI/slot implementation, combined with the reliance on a well-established standard library like Boost.Signals2, makes the entire codebase easier for developers to understand, debug, and modify safely over time.\nHowever, adopting this approach also introduces several considerations that must be acknowledged. The most obvious is the introduction of a new external dependency on the Boost library, specifically requiring Boost.Signals2 which, depending on the build system and configuration, might implicitly pull in other Boost components. There is also an inherent increase in conceptual complexity; developers working with the system now need to understand the core concepts of Boost.Signals2, including signals, slots, combiners, connection management, and the specific factory pattern used within our SignalManager, which represents an initial learning curve compared to the simpler, albeit less robust, custom solutions. Additionally, the C++ macro magic employed in host_macros.h, while effective at reducing repetitive boilerplate code for signal emission, can also introduce a layer of opacity, potentially making it harder to debug the exact flow of control within the host function wrappers without understanding the macro expansions. A critical point of potential fragility remains in the FFI signature matching: the contract between the C++ host’s slot wrapper lambda ( defined within the signal connector factory) and the signature of the exported Rust WASM slot function it intends to call must be manually synchronized with extreme care. Any mismatch in parameter types, number of parameters, or return types will not be caught at compile time but will manifest as difficult-to-diagnose runtime traps or undefined behavior. Lastly, the reliance on string-based names persists during the crucial connection phase. Both the host-side connectWasmSlot method and the WASM-side connect_signal wrapper function operate using string literals to identify signals and WASM functions. Simple typographical errors in these string names will result in silent connection failures, which can be challenging to track down without careful logging or debugging procedures on both sides of the FFI boundary.\nConclusion: A More Elegant Bridge By replacing our custom eventing system with Boost.Signals2, we’ve significantly elevated the sophistication and robustness of the interaction between our C++ EnTT host and the Rust WASM plugin. We now have a unified, flexible, and more maintainable mechanism for the host and plugin to react to each other’s actions, intercept operations, and modify results in a controlled manner.\nThe SignalManager centralizes signal definition and connection logic, while the C++ macros provide a clean way to instrument our existing host C API functions with signal emissions. On the WASM side, exporting dedicated slot functions and using a single host call (host_connect_signal) to register them simplifies the plugin’s responsibility. Features like combiners (StopOnTrueCombiner, optional_last_value) and priorities unlock powerful patterns like vetoing actions or overriding results, all managed by the Boost.Signals2 framework.\nWhile it introduces a Boost dependency and requires understanding its concepts, the payoff in terms of reduced custom code complexity, automatic connection management, and standardized event handling is substantial. This architecture provides a solid foundation for building even more intricate and dynamic interactions across the WASM boundary, proving that even complex event-driven communication is achievable with the right tools and design patterns.\nOur journey continues, but this refactoring marks a significant step towards a more mature and production-ready C++/Rust/WASM integration.\n","wordCount":"7721","inLanguage":"en","datePublished":"2025-04-07T21:50:58+08:00","dateModified":"2025-04-07T21:50:58+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Beyond Basic Bridging: Robust Eventing Between C++ EnTT and Rust WASM with Boost.Signals2</h1><div class=post-meta><span title='2025-04-07 21:50:58 +0800 +0800'>April 7, 2025</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;7721 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/zh/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#the-case-for-signals-why-boostsignals2>The Case for Signals: Why <code>Boost.Signals2</code>?</a></li><li><a href=#host-side-revolution-the-signalmanager-and-macro-magic>Host-Side Revolution: The <code>SignalManager</code> and Macro Magic</a><ol><li><a href=#introducing-signalmanager>Introducing <code>SignalManager</code></a></li><li><a href=#emitting-signals-via-macros-host_macrosh>Emitting Signals via Macros (<code>host_macros.h</code>)</a></li><li><a href=#connecting-wasm-slots-host_connect_signal>Connecting WASM Slots: <code>host_connect_signal</code></a></li></ol></li><li><a href=#wasm-side-adaptation-becoming-a-signal-client>WASM-Side Adaptation: Becoming a Signal Client</a><ol><li><a href=#implementing-wasm-signal-slots>Implementing WASM Signal Slots</a></li></ol></li><li><a href=#the-full-picture-execution-flow-with-signals>The Full Picture: Execution Flow with Signals</a></li><li><a href=#benefits-and-considerations-revisited>Benefits and Considerations Revisited</a></li><li><a href=#conclusion-a-more-elegant-bridge>Conclusion: A More Elegant Bridge</a></li></ol></nav></div></details></div><div class=post-content><p>Let&rsquo;s dive back into our evolving C++/Rust/WASM project. In our previous explorations, we successfully:</p><ol><li>Established robust methods
for <a href=/en/posts/weaving-the-web-managing-entity-relationships-in-entt/>managing entity relationships (1:1, 1:N, N:N) within the C++ EnTT ECS framework</a>.</li><li>Built a bridge using Wasmtime
for <a href=/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/>bidirectional communication and memory sharing between a C++ host and a Rust WASM module</a>.</li><li>Combined these
concepts, <a href=/en/posts/bridging-the-gap-flexible-relationship-management-between-cpp-host-and-rust-wasm-plugins-using-entt/>creating a stable C FFI layer to allow a Rust WASM plugin to manage EnTT entity relationships residing in the C++ host</a>.</li></ol><p>This layered architecture, leveraging EnTT&rsquo;s data-oriented nature and a carefully crafted C FFI, proved effective in
overcoming the inherent limitations of the WASM boundary. However, as projects grow, the need for more sophisticated
interaction patterns emerges. Our previous solution relied on the WASM module <em>calling</em> host functions to perform
actions. What if we need the <em>host</em> to notify the WASM plugin when certain events occur within the EnTT world? What if
the WASM plugin needs to <em>intercept</em> or <em>modify</em> the behaviour of host operations?</p><p>Our initial foray into this involved creating custom &ldquo;trigger&rdquo; and &ldquo;patching&rdquo; mechanisms. While these solutions
functioned, their ad-hoc nature, often depending on string-based function lookups and requiring manual management of
callbacks, revealed significant drawbacks, rapidly leading to systems that were complex, brittle, and difficult to
maintain. We specifically encountered a number of challenges. A primary concern was type safety; the reliance on
function names represented as strings provided absolutely no compile-time guarantee that a given WASM function&rsquo;s
signature would actually match what the host expected for a particular trigger or patch point. Another difficulty arose
in connection management: manually keeping track of which WASM functions were registered to handle which specific events
became increasingly cumbersome, and tasks like disconnecting or updating these registrations necessitated meticulous,
error-prone bookkeeping. Furthermore, our custom system offered no inherent capability to control the execution order or
apply prioritization when multiple WASM callbacks were registered for the very same event. The handling of results
presented yet another significant problem: determining how results from potentially multiple WASM &ldquo;patch&rdquo; functions
should be combined, or even whether one WASM plugin should possess the ability to entirely prevent an action initiated
by the host, was left without any standard or well-defined approach within our custom framework. Lastly, a considerable
amount of boilerplate code was required; implementing the necessary registration, lookup, and invocation logic for every
single trigger or patch point involved substantial and repetitive coding effort on both the C++ host and the Rust WASM
sides of the system.</p><p>It became clear that we needed a more robust, standardized, and feature-rich eventing system. Enter <code>Boost.Signals2</code>.</p><p>This post chronicles the refactoring journey, replacing our custom trigger and patching mechanisms with the powerful and
flexible <code>Boost.Signals2</code> library. We&rsquo;ll explore how this transition simplifies the architecture, enhances type safety (
as much as possible across FFI), provides sophisticated features like automatic connection management, prioritization,
and result combination (&ldquo;combiners&rdquo;), and ultimately leads to a more maintainable and extensible host-plugin interaction
model.</p><p>We&rsquo;ll dissect the significant changes on both the C++ host side (introducing a <code>SignalManager</code>, adapting <code>WasmHost</code> and
<code>EnttManager</code>, and leveraging C++ macros for signal emission) and the Rust WASM side (implementing signal slots and a
new connection mechanism). Prepare for a deep dive into leveraging a mature signaling library to orchestrate complex
events across the WASM boundary.</p><h2 id=the-case-for-signals-why-boostsignals2>The Case for Signals: Why <code>Boost.Signals2</code>?<a hidden class=anchor aria-hidden=true href=#the-case-for-signals-why-boostsignals2>#</a></h2><p>Before dismantling our existing trigger/patch system, let&rsquo;s understand why <code>Boost.Signals2</code> is a compelling alternative.
At its core, <code>Boost.Signals2</code> implements the <strong>signals and slots</strong> programming pattern, a powerful mechanism for
decoupled communication.</p><p>At its core, <code>Boost.Signals2</code> implements the signals and slots programming pattern, a potent mechanism facilitating
decoupled communication within an application. You can conceptualize signals as event broadcasters. Whenever a
particular event takes place in the system, such as an entity being on the verge of creation or a name component having
just been added, a corresponding signal object is formally &ldquo;emitted&rdquo; or &ldquo;fired,&rdquo; announcing the event occurrence.</p><p>Complementing signals are the slots, which function as the designated event receivers. These slots are typically
functions or callable function objects, like C++ lambdas, that are explicitly registered or &ldquo;connected&rdquo; to one or more
specific signals. The crucial behavior is that when a signal is emitted, the framework automatically invokes all the
slots currently connected to that specific signal.</p><p>The link established between a particular signal and a slot is represented by a connection object. A critically
important feature offered by <code>Boost.Signals2</code>, setting it apart from many manual systems, is its provision of automatic
connection management. This means that if either the signal itself or a connected slot object ceases to exist (for
instance, by going out of scope) or if the connection is explicitly severed, the library automatically breaks the link.
This robust management prevents the common and problematic issue of dangling callbacks, where the system might attempt
to invoke a function that no longer exists, which is a significant advantage when compared to manually managed callback
lists.</p><p>Where <code>Boost.Signals2</code> particularly demonstrates its power, especially for our integration scenario, is through its
concept of combiners. A combiner is essentially a rule or a policy that dictates how the return values generated by
multiple slots, all connected to the same signal, should be aggregated or processed into a single outcome. For example,
when dealing with &ldquo;before&rdquo; events, like <code>before_create_entity</code>, we might desire a behavior where any single connected
slot has the power to veto or prevent the original operation from proceeding. This can be effectively achieved by
implementing a custom combiner that intelligently stops the invocation sequence and returns immediately as soon as any
slot returns <code>true</code>, thereby signaling that the operation should be skipped. Conversely, for &ldquo;after&rdquo; events where
connected slots might intend to modify a result, such as in the <code>after_get_name</code> scenario, we could employ a standard
combiner like <code>boost::signals2::optional_last_value</code>. This specific combiner conveniently returns the value that was
produced by the very last slot executed in the sequence, a behavior that becomes particularly useful when slots are
assigned different priorities. It&rsquo;s also worth noting that the default combiner behavior simply returns <code>void</code> if the
slots have no return value, or it returns a <code>boost::optional&lt;ResultType></code> containing the result from the last slot that
returned a non-void value.</p><p>Furthermore, <code>Boost.Signals2</code> allows slots to be connected with associated group priorities. This feature provides
developers with fine-grained control over the precise order in which slots connected to the same signal are executed
relative to one another, enabling more complex interaction sequences.</p><p>Finally, the library offers various configurable levels of thread safety. While our current host application operates in
a single thread, this capability is a crucial consideration for potentially multi-threaded host environments, ensuring
that signal emissions and slot connections can be handled safely under concurrent conditions.</p><p>By adopting <code>Boost.Signals2</code>, we replace our bespoke, error-prone system with a well-tested, feature-rich library
designed specifically for this kind of event handling, significantly improving robustness and maintainability.</p><h2 id=host-side-revolution-the-signalmanager-and-macro-magic>Host-Side Revolution: The <code>SignalManager</code> and Macro Magic<a hidden class=anchor aria-hidden=true href=#host-side-revolution-the-signalmanager-and-macro-magic>#</a></h2><p>The most significant changes occur on the C++ host side. We need a central place to define our signals and manage
connections to WASM slots, and we need a non-intrusive way to emit these signals when our existing C API functions are
called.</p><h3 id=introducing-signalmanager>Introducing <code>SignalManager</code><a hidden class=anchor aria-hidden=true href=#introducing-signalmanager>#</a></h3><p>This new class becomes the heart of our host-side eventing system.</p><p><strong>Signal Definitions:</strong> Inside <code>signal_manager.h</code>, we define specific signal types using <code>boost::signals2::signal</code>. The
template arguments define the signature of the slots that can connect to it (return type and parameter types).
Critically, we also specify a <em>combiner</em> type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// signal_manager.h (Illustrative Snippets)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;boost/signals2.hpp&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;optional&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>// For optional_last_value combiner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> WasmHostSignals {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Custom Combiner: Stops invocation if any slot returns true.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Useful for &#34;before&#34; signals to allow skipping the original action.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StopOnTrueCombiner</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>bool</span> result_type; <span style=color:#75715e>// The combiner returns bool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> InputIterator<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    result_type <span style=color:#66d9ef>operator</span>()(InputIterator first, InputIterator last) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (first <span style=color:#f92672>!=</span> last) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Dereference the iterator to get the slot&#39;s return value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Assuming slots connected to signals using this combiner return bool
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>first) { <span style=color:#75715e>// If the slot returned true...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> true; <span style=color:#75715e>// ...stop and return true (indicating skip)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>first;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false; <span style=color:#75715e>// No slot returned true, return false (don&#39;t skip)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- Signal Type Definitions ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example: Entity Creation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// bool(): Return true to skip creation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalBeforeCreateEntity <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span>(), StopOnTrueCombiner<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// uint32_t(uint32_t original_id): Can modify the returned ID.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalAfterCreateEntity <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span>(<span style=color:#66d9ef>uint32_t</span>), boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>optional_last_value<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>&gt;&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example: Entity Destruction
</span></span></span><span style=display:flex><span><span style=color:#75715e>// bool(uint32_t entity_id): Return true to skip destruction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalBeforeDestroyEntity <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span>(<span style=color:#66d9ef>uint32_t</span>), StopOnTrueCombiner<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// void(uint32_t entity_id): Just a notification.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalAfterDestroyEntity <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>(<span style=color:#66d9ef>uint32_t</span>)<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example: Get Name (Complex due to buffer)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// bool(uint32_t id, char* buffer, size_t buffer_len): Can skip original get.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note: WASM slot won&#39;t easily access the host buffer content here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Signature might be simplified in practice.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalBeforeGetName <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span>(<span style=color:#66d9ef>uint32_t</span>, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>, size_t), StopOnTrueCombiner<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// size_t(uint32_t id, char* buffer, size_t buffer_len, size_t original_req_len): Can modify required_len.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> SignalAfterGetName <span style=color:#f92672>=</span> boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal<span style=color:#f92672>&lt;</span>size_t(<span style=color:#66d9ef>uint32_t</span>, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>, size_t, size_t), boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>optional_last_value<span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Define signal types for all relevant host operations ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WasmHost</span>; <span style=color:#75715e>// Forward declaration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SignalManager</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Signals are public members for macros to access easily
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Could be private with accessor methods too.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SignalBeforeCreateEntity signal_before_create_entity;
</span></span><span style=display:flex><span>    SignalAfterCreateEntity signal_after_create_entity;
</span></span><span style=display:flex><span>    SignalBeforeDestroyEntity signal_before_destroy_entity;
</span></span><span style=display:flex><span>    SignalAfterDestroyEntity signal_after_destroy_entity;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Other signal members ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SignalBeforeGetName signal_before_get_name;
</span></span><span style=display:flex><span>    SignalAfterGetName signal_after_get_name;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... and many more ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>SignalManager</span>(WasmHost<span style=color:#f92672>*</span> host);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>SignalManager();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Deleted copy/move constructors/assignment operators
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SignalManager(<span style=color:#66d9ef>const</span> SignalManager<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>    SignalManager<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> SignalManager<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Connects a WASM function (by name) to a specific signal (by name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>connectWasmSlot</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> signal_name, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> wasm_func_name, <span style=color:#66d9ef>int</span> priority);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    WasmHost<span style=color:#f92672>*</span> wasm_host_ptr_; <span style=color:#75715e>// Needed to call back into WASM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Type definition for the factory function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>using</span> WasmSlotConnectorFactory <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span>boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>connection(
</span></span><span style=display:flex><span>        WasmHost<span style=color:#f92672>*</span> host,              <span style=color:#75715e>// Pointer to WasmHost
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>signal_base<span style=color:#f92672>&amp;</span> signal, <span style=color:#75715e>// Reference to the specific signal object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> wasm_func_name,   <span style=color:#75715e>// Name of the WASM function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> priority                     <span style=color:#75715e>// Priority for connection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    )<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Map from signal name (string) to a factory that creates the connection lambda
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, WasmSlotConnectorFactory<span style=color:#f92672>&gt;</span> slot_connector_factories_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initializes the slot_connector_factories_ map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initializeConnectorFactories</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Structure to potentially track connection info (optional)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>WasmSlotInfo</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string wasm_function_name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> priority <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        boost<span style=color:#f92672>::</span>signals2<span style=color:#f92672>::</span>connection connection; <span style=color:#75715e>// Stores the connection object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Store connections grouped by signal name (optional, for management)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>WasmSlotInfo<span style=color:#f92672>&gt;&gt;&gt;</span> wasm_connections_;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// namespace WasmHostSignals
</span></span></span></code></pre></div><p>Several critical design decisions shape the effectiveness of the <code>SignalManager</code>. The choice of combiners is fundamental
to defining the interaction logic for different event types. For instance, we specifically define our custom
<code>StopOnTrueCombiner</code> for signals intended to run <em>before</em> an operation (like <code>before_create_entity</code>), enabling any
connected slot to prevent the original action simply by returning <code>true</code>. For signals emitted <em>after</em> an operation,
especially those where slots might wish to modify a return value (such as <code>after_create_entity</code> potentially altering the
returned ID), we utilize the standard <code>boost::signals2::optional_last_value&lt;T></code> combiner. This combiner has the behavior
of returning the value produced by the very last slot that executed in the sequence, a feature that integrates naturally
with the priority system. In cases where the signal serves purely as a notification (like <code>after_destroy_entity</code>), the
default combiner, which simply returns <code>void</code>, is perfectly adequate.</p><p>The definition of signal signatures, such as <code>bool()</code>, <code>uint32_t(uint32_t)</code>, <code>void(uint32_t)</code>, and so forth, plays a
crucial role in establishing the contract for any slots wishing to connect. These signatures dictate the exact parameter
types and the return type that a compliant slot function must adhere to, which is essential for maintaining type safety
across the system. It&rsquo;s noteworthy that even complex scenarios, like the <code>before_get_name</code> signal, initially include
buffer details (<code>char*</code>, <code>size_t</code>) in their signature to match the underlying C API. However, we recognize the practical
difficulties of WASM slots directly manipulating host memory buffers via these parameters and anticipate that the actual
WASM slot implementation might simplify its approach, perhaps ignoring these buffer arguments and opting to call back
into the host via another FFI function if the buffer content is needed.</p><p>Connecting WASM functions is facilitated by the <code>connectWasmSlot</code> public method. This function serves as the designated
entry point that the WASM module will ultimately invoke, using the intermediary <code>host_connect_signal</code> FFI function, to
register its handlers as slots. <code>connectWasmSlot</code> requires the string name of the target signal on the host and the
string name of the function exported by the WASM module that should be connected to it.</p><p>Internally, the setup relies heavily on the <code>initializeConnectorFactories</code> private method, which is executed within the
<code>SignalManager</code>&rsquo;s constructor. This method&rsquo;s responsibility is to populate the <code>slot_connector_factories_</code> map. This map
uses the string name of a signal (e.g., the literal string <code>"before_create_entity"</code>) as its key. The corresponding value
for each key is a C++ lambda function, which we term a &ldquo;lambda factory.&rdquo;</p><p>Each lambda factory stored within the <code>slot_connector_factories_</code> map is precisely engineered to perform a single,
specific task: it knows how to connect a WASM function, identified by its name string, to one particular, hardcoded
<code>Boost.Signals2</code> signal member within the <code>SignalManager</code> instance (e.g., the factory associated with the key
<code>"before_create_entity"</code> knows it must operate on the <code>signal_before_create_entity</code> member). To achieve this, the
factory lambda typically captures the <code>this</code> pointer of the <code>SignalManager</code> or sometimes directly captures the specific
signal member it targets. It&rsquo;s designed to accept several arguments: a pointer to the <code>WasmHost</code> instance (necessary for
invoking WASM functions), a reference to the specific target signal object (passed as a <code>signal_base&</code> for polymorphism
within the factory signature, requiring a <code>static_cast</code> back to the concrete signal type inside), the string name of the
WASM function to connect, and the desired connection priority. The core action within the factory lambda is the call
<code>signal.connect(priority, [host, wasm_func] (...) { ... })</code>. The crucial element here is the <em>second</em> lambda passed to
<code>signal.connect</code> – this inner lambda is the <em>actual slot wrapper</em>. This wrapper lambda is precisely what the
<code>Boost.Signals2</code> framework will execute whenever the specific Boost signal it&rsquo;s connected to is emitted. The logic
embedded within this slot wrapper lambda is responsible for bridging the gap to Wasmtime. It receives arguments directly
from the Boost signal emission, matching the Boost signal&rsquo;s defined signature (for example, the <code>original_id</code> parameter
for <code>signal_after_create_entity</code>). Its first task is to marshal these incoming C++ arguments into the format Wasmtime
expects, typically a <code>std::vector&lt;wasmtime::Val></code>. Next, it invokes the target WASM function by name using the
<code>WasmHost</code> pointer and its <code>callFunction</code> method (e.g., <code>host->callFunction&lt;ReturnType>(wasm_func, args)</code>), carefully
specifying the expected <code>ReturnType</code> based on the WASM function&rsquo;s FFI signature (like <code>int32_t</code> for a WASM function
returning a boolean, or <code>uint32_t</code> for one returning an entity ID). This call inherently involves handling potential
Wasmtime traps, usually by checking the <code>Result</code> returned by <code>callFunction</code>. If the WASM call is successful, the wrapper
then unmarshals the resulting <code>wasmtime::Val</code> back into the C++ data type that is expected by the <em>combiner</em> associated
with the Boost signal (for instance, converting an <code>int32_t</code> result back to a <code>bool</code> for signals using the
<code>StopOnTrueCombiner</code>, or to a <code>uint32_t</code> for those using <code>optional_last_value&lt;uint32_t></code>). Finally, this unmarshalled
C++ value is returned by the slot wrapper lambda, feeding it back into the Boost signal&rsquo;s processing mechanism (
specifically, its combiner).</p><p>To correctly route the connection request, the <code>connectWasmSlot</code> method must determine the actual
<code>boost::signals2::signal</code> member object corresponding to the provided <code>signal_name</code> string. The current implementation
employs a straightforward, albeit potentially lengthy, <code>if/else if</code> cascade to perform this mapping. It compares the
input string against known signal names and, upon finding a match, passes a reference to the appropriate signal member (
like <code>signal_before_create_entity</code>) into the corresponding factory lambda retrieved from the <code>slot_connector_factories_</code>
map.</p><p>Finally, robust connection management is implicitly handled by <code>Boost.Signals2</code>. While the code includes an optional
mechanism to store the <code>boost::signals2::connection</code> object returned by <code>connect</code> within a <code>wasm_connections_</code> map (
keyed by signal name), which could facilitate more granular future management like targeted disconnections, the primary
benefit comes from the <code>SignalManager</code>&rsquo;s destructor. Within the destructor, all stored connections are explicitly
disconnected. More importantly, even without this explicit storage, Boost guarantees that connections are automatically
broken if either the signal or the slot&rsquo;s context (which isn&rsquo;t directly applicable here since our slots are host-side
lambdas calling WASM) is destroyed, significantly mitigating the risk of dangling pointers or callbacks.</p><p><code>WasmHost</code> now creates and owns both the <code>SignalManager</code> and the <code>EnttManager</code>, passing the <code>SignalManager</code> pointer to
the <code>EnttManager</code> constructor. <code>EnttManager</code> itself is simplified – it no longer manages triggers directly but uses its
<code>SignalManager</code> pointer to emit signals where appropriate (primarily in the <code>onEntityDestroyedSignalHook</code>).</p><h3 id=emitting-signals-via-macros-host_macrosh>Emitting Signals via Macros (<code>host_macros.h</code>)<a hidden class=anchor aria-hidden=true href=#emitting-signals-via-macros-host_macrosh>#</a></h3><p>We need to trigger these signals whenever the corresponding host C API functions are called <em>from WASM</em>. We could
manually insert signal emission code into every host function lambda in <code>host.cpp</code>, but that&rsquo;s repetitive and
error-prone. Instead, we use C++ macros defined in <code>host_macros.h</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host_macros.h (Illustrative Snippet)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;entt_api.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;signal_manager.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;wasm_host.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;wasmtime.hh&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;optional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdexcept&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>// For runtime_error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Helper within namespace to avoid polluting global scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>namespace</span> WasmHostUtils {
</span></span><span style=display:flex><span><span style=color:#75715e>// (Keep read_wasm_string_helper, check_result, handle_wasm_trap helpers here)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#75715e>// namespace WasmHostUtils
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Macro to define a host function taking 0 arguments and returning a value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DEFINE_HOST_FUNC_0_ARGS_RET(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE, RET_TYPE, WASM_RET_TYPE, DEFAULT_RET) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    (LINKER).func_new(                                                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        &#34;env&#34;, (NAME), (WASM_TYPE),                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        [(HOST_PTR), (MGR_HANDLE)](                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            wasmtime::Caller caller,                                                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            wasmtime::Span&lt;const wasmtime::Val&gt; args,                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            wasmtime::Span&lt;wasmtime::Val&gt; results                                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        ) -&gt; wasmtime::Result&lt;std::monostate, wasmtime::Trap&gt; {                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            using namespace WasmHostSignals;                                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            using namespace WasmHostUtils;                                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            SignalManager&amp; sig_mgr = (HOST_PTR)-&gt;getSignalManager();                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            RET_TYPE final_result = (DEFAULT_RET); </span><span style=color:#75715e>/* Initialize with default */</span><span style=color:#75715e>      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            try {                                                                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                </span><span style=color:#75715e>/* --- Before Signal --- */</span><span style=color:#75715e>                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                </span><span style=color:#75715e>/* Assuming signal names match: before_NAME */</span><span style=color:#75715e>                         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                bool skip = sig_mgr.signal_##before_##C_API_FUNC();                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                if (skip) {                                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    std::cout &lt;&lt; &#34;[Host Signal] Skipping &#34; &lt;&lt; (NAME) &lt;&lt; &#34; due to before_ signal.&#34; &lt;&lt; std::endl; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                } else {                                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    </span><span style=color:#75715e>/* --- Original C API Call --- */</span><span style=color:#75715e>                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    RET_TYPE original_result = C_API_FUNC((MGR_HANDLE));               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                                                                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    </span><span style=color:#75715e>/* --- After Signal --- */</span><span style=color:#75715e>                                         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    </span><span style=color:#75715e>/* Assuming signal names match: after_NAME */</span><span style=color:#75715e>                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    </span><span style=color:#75715e>/* Pass original result, combiner decides final result */</span><span style=color:#75715e>          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    final_result = sig_mgr.signal_##after_##C_API_FUNC(original_result); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                }                                                                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                </span><span style=color:#75715e>/* --- Marshall result for WASM --- */</span><span style=color:#75715e>                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                results[0] = wasmtime::Val(static_cast&lt;WASM_RET_TYPE&gt;(final_result));  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                return std::monostate();                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            } catch (const wasmtime::Trap&amp; trap) {                                     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 std::cerr &lt;&lt; &#34;[Host Function Error] &#34; &lt;&lt; (NAME) &lt;&lt; &#34; trapped: &#34; &lt;&lt; trap.message() &lt;&lt; std::endl; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 return wasmtime::Trap(trap.message()); </span><span style=color:#75715e>/* Create new trap */</span><span style=color:#75715e>          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            } catch (const std::exception&amp; e) {                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 std::cerr &lt;&lt; &#34;[Host Function Error] &#34; &lt;&lt; (NAME) &lt;&lt; &#34; exception: &#34; &lt;&lt; e.what() &lt;&lt; std::endl; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 return wasmtime::Trap(std::string(&#34;Host function &#34;) + (NAME) + &#34; failed: &#34; + e.what()); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            } catch (...) {                                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 std::cerr &lt;&lt; &#34;[Host Function Error] &#34; &lt;&lt; (NAME) &lt;&lt; &#34; unknown exception.&#34; &lt;&lt; std::endl; \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 return wasmtime::Trap(std::string(&#34;Host function &#34;) + (NAME) + &#34; failed with unknown exception.&#34;); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            }                                                                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }                                                                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ).unwrap() </span><span style=color:#75715e>/* Use unwrap() for example, check Result in prod */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Other macros for different signatures (e.g., U32_VOID, U32_STR_VOID, U32_GET_STR...)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Example: Macro for uint32_t argument, void return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DEFINE_HOST_FUNC_U32_VOID(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    (LINKER).func_new(                                                                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        &#34;env&#34;, (NAME), (WASM_TYPE),                                                      \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        </span><span style=color:#75715e>/* Lambda implementation similar to above */</span><span style=color:#75715e>                                     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        [(HOST_PTR), (MGR_HANDLE)](</span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>) -&gt; wasmtime::Result&lt;std::monostate, wasmtime::Trap&gt; { \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            </span><span style=color:#75715e>/* ... extract uint32_t arg ... */</span><span style=color:#75715e>                                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            uint32_t arg0_u32 = </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>;                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            try {                                                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                bool skip = sig_mgr.signal_##before_##C_API_FUNC(arg0_u32);              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                if (!skip) {                                                             \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    C_API_FUNC((MGR_HANDLE), arg0_u32);                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    sig_mgr.signal_##after_##C_API_FUNC(arg0_u32);                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                } else { </span><span style=color:#75715e>/* Log skip */</span><span style=color:#75715e> }                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                return std::monostate(); </span><span style=color:#75715e>/* Void return */</span><span style=color:#75715e>                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            } catch(</span><span style=color:#75715e>/* ... trap/exception handling ... */</span><span style=color:#75715e>) { </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e> }                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }                                                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ).unwrap()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example: Macro for uint32_t argument, getting a string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define DEFINE_HOST_FUNC_U32_GET_STR(LINKER, HOST_PTR, MGR_HANDLE, NAME, C_API_FUNC, WASM_TYPE) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    (LINKER).func_new(                                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        &#34;env&#34;, (NAME), (WASM_TYPE),                                                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        </span><span style=color:#75715e>/* Lambda implementation */</span><span style=color:#75715e>                                                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        [(HOST_PTR), (MGR_HANDLE)](</span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>) -&gt; wasmtime::Result&lt;std::monostate, wasmtime::Trap&gt; { \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            </span><span style=color:#75715e>/* ... extract uint32_t id, char* buffer_ptr_offset, size_t buffer_len ... */</span><span style=color:#75715e> \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            uint32_t entity_id = </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>;                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            int32_t buffer_offset = </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>;                                            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            size_t buffer_len = </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e>;                                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            char* wasm_buffer = nullptr;                                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            try {                                                                         \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                </span><span style=color:#75715e>/* Get memory and calculate wasm_buffer pointer safely */</span><span style=color:#75715e>                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                auto mem_span_opt = WasmHostUtils::get_wasm_memory_span_helper(caller);   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                if (!mem_span_opt) return wasmtime::Trap(&#34;Failed to get WASM memory&#34;);     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                auto&amp; mem_span = mem_span_opt.value();                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                if (buffer_offset &gt;= 0 &amp;&amp; buffer_len &gt; 0 </span><span style=color:#75715e>/* ... more bounds checks ... */</span><span style=color:#75715e>){ \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    wasm_buffer = reinterpret_cast&lt;char*&gt;(mem_span.data() + buffer_offset);\
</span></span></span><span style=display:flex><span><span style=color:#75715e>                } else if (buffer_offset != 0 || buffer_len &gt; 0) { </span><span style=color:#75715e>/* Invalid buffer args */</span><span style=color:#75715e> } \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                                                                                          \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                size_t final_req_len = 0; </span><span style=color:#75715e>/* Default */</span><span style=color:#75715e>                                   \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                bool skip = sig_mgr.signal_##before_##C_API_FUNC(entity_id, wasm_buffer, buffer_len); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                if (!skip) {                                                              \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    size_t original_req_len = C_API_FUNC((MGR_HANDLE), entity_id, wasm_buffer, buffer_len); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    </span><span style=color:#75715e>/* Pass original_req_len to after signal */</span><span style=color:#75715e>                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                    final_req_len = sig_mgr.signal_##after_##C_API_FUNC(entity_id, wasm_buffer, buffer_len, original_req_len); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                } else { </span><span style=color:#75715e>/* Log skip, return 0 */</span><span style=color:#75715e> final_req_len = 0; }                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                results[0] = wasmtime::Val(static_cast&lt;int32_t&gt;(final_req_len)); </span><span style=color:#75715e>/* Return size_t as i32 */</span><span style=color:#75715e> \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                return std::monostate();                                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            } catch(</span><span style=color:#75715e>/* ... trap/exception handling ... */</span><span style=color:#75715e>) { </span><span style=color:#75715e>/* ... */</span><span style=color:#75715e> }                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }                                                                                 \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    ).unwrap()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... More macros for other patterns ...
</span></span></span></code></pre></div><p>The C++ macros defined in <code>host_macros.h</code> encapsulate several key elements essential for integrating the host&rsquo;s C API
functions with the <code>Boost.Signals2</code> event system when exposing them to the WASM module via Wasmtime. Their primary
function is boilerplate reduction; they conveniently wrap the necessary <code>linker.func_new</code> call required by Wasmtime and
construct the complex lambda function that serves as the actual host function implementation callable by WASM.</p><p>These macros are highly parameterized to handle different function signatures. They typically accept arguments such as
the Wasmtime linker object, a pointer to the <code>WasmHost</code> instance, the opaque handle for the <code>EnttManager</code>, the specific
name the WASM module will use to import the function (referred to as <code>NAME</code>), a pointer to the underlying C API function
being wrapped (<code>C_API_FUNC</code>), the corresponding Wasmtime function type definition, the expected C++ return type of the C
API function, the corresponding WASM ABI type for the return value (e.g., <code>int32_t</code> for a C <code>int</code> or <code>uint32_t</code>), and a
default return value to use if the operation is skipped by a signal.</p><p>Within the lambda generated by the macro, specific captures are essential. The lambda captures the <code>HOST_PTR</code>, which is
crucial for gaining access to the <code>SignalManager</code> instance needed to emit signals, and it also captures the
<code>MGR_HANDLE</code>, the opaque pointer required to invoke the original C API function.</p><p>The lambda implementation handles the intricate details of argument and result marshalling across the WASM boundary.
It&rsquo;s responsible for extracting incoming arguments from the <code>Span&lt;const wasmtime::Val></code> provided by Wasmtime, converting
them to the types expected by the C API function. For functions dealing with buffers or strings, it performs necessary
bounds checking, often using helper functions, to ensure memory safety when interacting with WASM&rsquo;s linear memory. After
the operation and potential signal handling, it marshals the final computed result back into the <code>Span&lt;wasmtime::Val></code>
for the WASM caller.</p><p>A core responsibility of the macro-generated lambda is signal emission. It first retrieves the <code>SignalManager</code> instance
via the captured <code>HOST_PTR</code>. Then, <em>before</em> invoking the wrapped C API function, it emits the corresponding &ldquo;before&rdquo;
signal. This emission uses C++ preprocessor token pasting (<code>##</code>) to dynamically construct the correct signal member name
based on the C API function&rsquo;s name (for example, combining <code>signal_##before_##</code> with <code>entt_manager_create_entity</code>
results in <code>signal_before_entt_manager_create_entity</code>). The lambda carefully checks the return value provided by the "
before" signal&rsquo;s combiner (e.g., the boolean result from <code>StopOnTrueCombiner</code>). If this return value indicates that the
operation should be skipped (typically <code>true</code>), the lambda logs a message and immediately returns the predefined default
value to WASM, bypassing the call to the original C API function and the emission of the &ldquo;after&rdquo; signal. If the &ldquo;before&rdquo;
signal does not indicate a skip, the lambda proceeds to call the original C API function (<code>C_API_FUNC</code>) using the
captured manager handle and extracted arguments. Following the C API call, it emits the corresponding &ldquo;after&rdquo; signal,
passing any relevant original arguments along with the result obtained from the C API call. Finally, it captures the
return value generated by the &ldquo;after&rdquo; signal&rsquo;s combiner (which might have been modified by WASM slots, for example,
using <code>optional_last_value</code>) and uses this value as the <code>final_result</code> that is ultimately marshalled and returned to the
WASM caller.</p><p>Lastly, robust error handling is built into the generated lambda. It includes comprehensive <code>try-catch</code> blocks designed
to catch standard C++ exceptions (<code>std::exception</code>) as well as Wasmtime-specific traps (<code>wasmtime::Trap</code>) that might
occur during the execution of the C API function, the signal emissions, or the slot invocations within WASM. These
caught exceptions or traps are then safely converted into new <code>wasmtime::Trap</code> objects, ensuring that host-side errors
are propagated back to the WASM runtime gracefully without crashing the host process. Special care is taken to correctly
handle the move-only semantics of <code>wasmtime::Trap</code> when re-throwing or constructing new traps.</p><p>In <code>host.cpp</code>, we now replace the direct lambda definitions with calls to these macros for each host function we want to
expose <em>with signal support</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main, illustrative usage)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... includes, setup ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Get pointers and references
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>WasmHost <span style=color:#a6e22e>host</span>(wasm_path);
</span></span><span style=display:flex><span>EnttManager<span style=color:#f92672>*</span> manager_raw_ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>host.getEnttManager();
</span></span><span style=display:flex><span>EnttManagerHandle<span style=color:#f92672>*</span> manager_handle <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>EnttManagerHandle<span style=color:#f92672>*&gt;</span>(manager_raw_ptr);
</span></span><span style=display:flex><span>Linker<span style=color:#f92672>&amp;</span> linker <span style=color:#f92672>=</span> host.getLinker();
</span></span><span style=display:flex><span>Store<span style=color:#f92672>&amp;</span> store <span style=color:#f92672>=</span> host.getStore();
</span></span><span style=display:flex><span>WasmHost<span style=color:#f92672>*</span> host_ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>host; <span style=color:#75715e>// For macro capture
</span></span></span><span style=display:flex><span><span style=color:#75715e>// SignalManager&amp; signal_manager = host.getSignalManager(); // Not directly needed here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>host.setupWasi();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Define function types...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use the macros to define host functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>DEFINE_HOST_FUNC_0_ARGS_RET(linker, host_ptr, manager_handle,
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;host_create_entity&#34;</span>, entt_manager_create_entity, void_to_i32_type,
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>uint32_t</span>, <span style=color:#66d9ef>int32_t</span>, FFI_NULL_ENTITY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEFINE_HOST_FUNC_U32_VOID(linker, host_ptr, manager_handle,
</span></span><span style=display:flex><span>                          <span style=color:#e6db74>&#34;host_destroy_entity&#34;</span>, entt_manager_destroy_entity, i32_to_void_type);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DEFINE_HOST_FUNC_U32_GET_STR(linker, host_ptr, manager_handle,
</span></span><span style=display:flex><span>                             <span style=color:#e6db74>&#34;host_get_name&#34;</span>, entt_manager_get_name, i32ptrlen_to_size_type);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Define ALL other host functions using the appropriate macros ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Define the signal connection function (doesn&#39;t need a macro as it doesn&#39;t wrap a C API call)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>linker.func_new( <span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_connect_signal&#34;</span>, <span style=color:#75715e>/* type */</span> ...,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Capture signal_manager by reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    [<span style=color:#f92672>&amp;</span>signal_manager <span style=color:#f92672>=</span> host.getSignalManager()](...) { <span style=color:#75715e>// Note capture detail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// ... implementation using signal_manager.connectWasmSlot ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>host.initialize(); <span style=color:#75715e>// Instantiate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Call connect_all_signals in WASM ...
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ... Call test_relationships_oo in WASM ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Manual test section calling linker.get() to ensure signal firing ...
</span></span></span></code></pre></div><h3 id=connecting-wasm-slots-host_connect_signal>Connecting WASM Slots: <code>host_connect_signal</code><a hidden class=anchor aria-hidden=true href=#connecting-wasm-slots-host_connect_signal>#</a></h3><p>How does the WASM module tell the host, &ldquo;Please connect my <code>wasm_before_create_entity</code> function to your
<code>before_create_entity</code> signal&rdquo;? We provide <em>one more</em> host function specifically for this: <code>host_connect_signal</code>.</p><p>This specific host function, <code>host_connect_signal</code>, is defined directly within <code>host.cpp</code> using <code>linker.func_new</code> and a
lambda, rather than relying on one of the host function macros, primarily because it doesn&rsquo;t wrap an existing C API
function but instead provides new functionality specific to the signal system. The lambda implementation performs
several distinct steps when invoked by the WASM module.</p><p>First, it receives its necessary input arguments directly from the WASM caller via the <code>Span&lt;const Val> args</code>. These
arguments consist of pointers and lengths representing the signal name (<code>signal_name_ptr</code>, <code>signal_name_len</code>) and the
WASM function name (<code>wasm_func_name_ptr</code>, <code>wasm_func_name_len</code>), along with an integer representing the desired
connection <code>priority</code>.</p><p>Next, to safely retrieve the actual string values from the potentially insecure pointers provided by WASM, the lambda
utilizes the <code>WasmHostUtils::read_wasm_string_helper</code> utility function. This helper reads the specified number of bytes
from the WASM linear memory at the given offsets, performing necessary bounds checks and returning the strings.</p><p>Crucially, the lambda is defined in a way that it captures a reference to the host&rsquo;s central <code>SignalManager</code> instance.
This captured reference provides the context needed to interact with the signal system.</p><p>With the signal and function names successfully read and the <code>SignalManager</code> accessible, the core logic of the lambda is
executed: it invokes the <code>connectWasmSlot</code> method on the captured <code>signal_manager</code>, passing the retrieved <code>signal_name</code>,
<code>wasm_func_name</code>, and <code>priority</code> as arguments. This call delegates the actual task of creating and registering the
signal-slot connection to the <code>SignalManager</code>.</p><p>Finally, after the connection attempt, the lambda returns the outcome back to the WASM module. It takes the boolean
success status returned by <code>connectWasmSlot</code> and marshals it into the expected FFI format, typically an <code>int32_t</code> (1 for
success, 0 for failure), which is placed into the <code>Span&lt;Val> results</code> for the WASM caller to interpret.</p><p>This provides the crucial link, allowing the WASM module to dynamically register its handlers during its initialization
phase.</p><h2 id=wasm-side-adaptation-becoming-a-signal-client>WASM-Side Adaptation: Becoming a Signal Client<a hidden class=anchor aria-hidden=true href=#wasm-side-adaptation-becoming-a-signal-client>#</a></h2><p>The Rust WASM module now needs to adapt to this new signal-based system.</p><p>The first step in adapting the Rust WASM module involves dismantling the previous custom eventing infrastructure. This
cleanup requires removing the remnants of the now-obsolete trigger and patching systems. Specifically, the
<code>src/patch_handler.rs</code> file, along with the <code>PatchHandler</code> trait defined within it, must be entirely deleted from the
project. Correspondingly, within the FFI layer defined in <code>src/ffi.rs</code>, the <code>extern "C"</code> import declarations that
previously brought in the host functions related to registering patches and triggers, namely <code>host_register_patch</code> and
<code>host_register_trigger</code>, need to be removed. Finally, the exported WASM functions that served as the initialization
entry points for these old systems, <code>init_patches</code> and <code>init_triggers</code>, must also be removed from the exports list, as
the host will no longer call them.</p><p>With the old plumbing removed, a new mechanism must be established to allow the WASM module to initiate the connection
of its handlers to the host&rsquo;s signals. This new process involves several coordinated steps within the Rust code. First,
the necessary FFI import declaration for the new host function responsible for handling connections,
<code>host_connect_signal</code>, must be added to the <code>extern "C"</code> block located in <code>src/ffi.rs</code>, mirroring the function signature
defined on the host side. Second, to encapsulate the unsafe FFI interaction, a safe Rust wrapper function,
<code>ffi::connect_signal</code>, needs to be created. This wrapper function should accept standard Rust string slices (<code>&amp;str</code>) for
the signal name and the WASM function name, along with an integer priority. Its implementation will handle the necessary
conversions of these Rust strings into null-terminated CStrings suitable for the FFI call and will contain the <code>unsafe</code>
block required to invoke the imported <code>host_connect_signal</code> function, returning a boolean indicating the success or
failure of the connection attempt. Third, the responsibility for orchestrating all necessary connections from the WASM
side is centralized within a new function, <code>core::connect_all_signals</code>, implemented in <code>src/core.rs</code>. This function&rsquo;s
sole purpose is to repeatedly call the safe <code>ffi::connect_signal</code> wrapper, systematically pairing the known string names
of the signals exposed by the host (such as <code>"before_create_entity"</code>) with the string names of the corresponding
exported WASM functions designed to handle those signals (like <code>"wasm_before_create_entity"</code>), along with their desired
priorities. Fourth and finally, to expose this connection logic to the host, a C-compatible function named
<code>connect_all_signals</code> needs to be exported from <code>src/ffi.rs</code> using <code>#[no_mangle] pub unsafe extern "C"</code>. The
implementation of this exported function simply delegates the actual work by calling <code>core::connect_all_signals()</code>. The
C++ host application will then be responsible for invoking this single exported <code>connect_all_signals</code> function exactly
once, typically right after the WASM module has been successfully instantiated, thereby triggering the registration of
all defined WASM signal handlers with the host&rsquo;s <code>SignalManager</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs (Snippets)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... other imports ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[link(wasm_import_module = </span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- Signal Connection Import (NEW) ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_connect_signal</span>(
</span></span><span style=display:flex><span>        signal_name_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> c_char,
</span></span><span style=display:flex><span>        signal_name_len: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        wasm_func_name_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> c_char,
</span></span><span style=display:flex><span>        wasm_func_name_len: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        priority: <span style=color:#a6e22e>c_int</span>,
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#a6e22e>c_int</span>; <span style=color:#75715e>// Returns bool (0 or 1) for success
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... other host function imports remain ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- Signal Connection Wrapper (NEW) ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connect_signal</span>(
</span></span><span style=display:flex><span>    signal_name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    wasm_func_name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    priority: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... (Implementation as shown previously, using CString::new and unsafe call) ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> success_code <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { host_connect_signal(<span style=color:#f92672>..</span>.) };
</span></span><span style=display:flex><span>    success_code <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- Exported Function for Host to Trigger Connections ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connect_all_signals</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Export] connect_all_signals called. Connecting handlers via core...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>crate</span>::core::connect_all_signals(); <span style=color:#75715e>// Delegate to core logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- Exported Signal Handler Implementations (Slots) ---
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ... (Functions like wasm_before_create_entity as defined previously) ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- Test Runner Export ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_relationships_oo</span>() {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// ... runs core::run_entt_relationship_tests_oo ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/core.rs (Snippet)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::ffi::{connect_signal, <span style=color:#66d9ef>DEFAULT_SIGNAL_PRIORITY</span> <span style=color:#75715e>/* ... */</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Connects all WASM signal handlers (slots) to the corresponding host signals.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// Called by the host via the exported `connect_all_signals` function in ffi.rs.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>connect_all_signals</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] Connecting WASM functions to host signals...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Connect slots for host_create_entity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    success <span style=color:#f92672>&amp;=</span> connect_signal(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;before_create_entity&#34;</span>,      <span style=color:#75715e>// Host signal name (string)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;wasm_before_create_entity&#34;</span>, <span style=color:#75715e>// Exported WASM function name (string)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>DEFAULT_SIGNAL_PRIORITY</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    success <span style=color:#f92672>&amp;=</span> connect_signal(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;after_create_entity&#34;</span>,       <span style=color:#75715e>// Host signal name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;wasm_after_create_entity&#34;</span>,  <span style=color:#75715e>// Exported WASM function name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>DEFAULT_SIGNAL_PRIORITY</span>,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... connect ALL other slots similarly ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     success <span style=color:#f92672>&amp;=</span> connect_signal(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;after_get_profile_for_player&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;wasm_after_get_profile_for_player_high_prio&#34;</span>, <span style=color:#75715e>// Name matches exported function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>DEFAULT_SIGNAL_PRIORITY</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>100</span>,                 <span style=color:#75715e>// Higher priority number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> success { <span style=color:#75715e>/* Log success */</span> } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>/* Log failure */</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... run_entt_relationship_tests_oo() remains largely the same ...
</span></span></span></code></pre></div><h3 id=implementing-wasm-signal-slots>Implementing WASM Signal Slots<a hidden class=anchor aria-hidden=true href=#implementing-wasm-signal-slots>#</a></h3><p>The Rust functions that were previously designated for the custom patching mechanism, such as <code>prefix_create_entity</code>,
are now either repurposed or replaced by new functions specifically designed to serve as the signal slots within the
<code>Boost.Signals2</code> framework. For these functions to correctly receive signals emitted by the host, they must adhere to
two fundamental requirements.</p><p>Firstly, they must be properly exported from the WASM module so that the host&rsquo;s <code>SignalManager</code> (via Wasmtime) can
locate and invoke them when connecting or firing signals. This necessitates marking each slot function with
<code>#[no_mangle]</code> to prevent Rust&rsquo;s name mangling and declaring it as <code>pub unsafe extern "C"</code> to ensure C-compatible
linkage and calling conventions. Critically, the exact name assigned to each exported slot function in the Rust code
must perfectly match the string literal used when connecting it within the <code>core::connect_all_signals</code> function; any
discrepancy will result in a connection failure.</p><p>Secondly, and equally crucial, the function signature of each WASM slot – encompassing both its parameters and its
return type – must precisely align with the expectations hardcoded into the corresponding host-side slot wrapper lambda.
These wrapper lambdas are defined within the <code>SignalManager::initializeConnectorFactories</code> method in the C++ host. Any
mismatch in the number of parameters, their types, or the return type will lead to undefined behavior or runtime traps
when the host attempts to call the WASM slot. For instance, the slot <code>wasm_before_create_entity()</code> is expected by the
host wrapper to take no arguments and return a <code>c_int</code>, where <code>0</code> signifies continuation and <code>1</code> indicates the operation
should be skipped. Similarly, <code>wasm_after_create_entity(original_id: u32)</code> must accept a <code>u32</code> representing the original
entity ID and return a <code>u32</code>, allowing it the opportunity to modify the ID passed back through the signal chain. A slot
like <code>wasm_after_destroy_entity(entity_id: u32)</code> is expected to accept the ID but return <code>void</code>, as it functions purely
as a notification. More complex cases like <code>wasm_before_get_name(entity_id: u32, buffer_len: u32)</code> demonstrate a
simplification in the FFI signature; the host wrapper expects it to receive the entity ID and the intended buffer length
but <em>not</em> the host-side buffer pointer itself, returning a <code>c_int</code> (0 or 1) to potentially veto the <code>get_name</code>
operation. This design choice avoids the complexity and potential unsafety of the WASM slot directly accessing the host
buffer; should the slot require the actual string content during this &ldquo;before&rdquo; phase, it would need to initiate a
separate call back into the host (e.g., using <code>host_get_name</code> itself). Correspondingly, the
<code>wasm_after_get_name(entity_id: u32, buffer_len: u32, original_req_len: u32)</code> slot receives the ID, buffer length, and
the original required length calculated by the C API, and is expected to return a <code>u32</code> representing the potentially
adjusted required length. This pattern of precisely matching the parameter list and return type defined implicitly by
the host&rsquo;s slot wrapper lambda must be rigorously applied to all other WASM functions intended to serve as signal slots
for the various host events.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs (Slot Implementation Snippets)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- host_create_entity ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_before_create_entity</span>() -&gt; <span style=color:#a6e22e>c_int</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Slot] &lt;&lt;&lt; before_create_entity called&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> <span style=color:#75715e>// Allow creation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_after_create_entity</span>(original_id: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Slot] &lt;&lt;&lt; after_create_entity called (Original ID: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, original_id);
</span></span><span style=display:flex><span>    original_id <span style=color:#75715e>// Return original ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- host_get_profile_for_player ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_before_get_profile_for_player</span>(player_id: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#a6e22e>c_int</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Slot] &lt;&lt;&lt; before_get_profile_for_player called (P: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, player_id);
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> <span style=color:#75715e>// Allow get
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Default priority postfix slot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_after_get_profile_for_player</span>(player_id: <span style=color:#66d9ef>u32</span>, original_profile_id: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Slot] &lt;&lt;&lt; after_get_profile_for_player called (P: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, OrigProf: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, player_id, original_profile_id);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This one just observes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    original_profile_id
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// High priority postfix slot (runs AFTER the default one)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_after_get_profile_for_player_high_prio</span>(player_id: <span style=color:#66d9ef>u32</span>, current_profile_id: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    println!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[WASM Slot][HIGH PRIO] &lt;&lt;&lt; after_get_profile_for_player_high_prio called (P: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, CurrentProf: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>,
</span></span><span style=display:flex><span>        player_id, current_profile_id <span style=color:#75715e>// current_profile_id is the result from the previous slot/original call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Example: Override profile ID for player 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> player_id <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;    &gt; [HIGH PRIO] Changing profile for player 2 to 888!&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>888</span>; <span style=color:#75715e>// Override the value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    current_profile_id <span style=color:#75715e>// Otherwise, return the value passed in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Implement ALL other exported slot functions ...
</span></span></span></code></pre></div><p>Now, when the host emits <code>signal_before_create_entity</code>, the <code>wasm_before_create_entity</code> function in the WASM module will
be executed. When the host emits <code>signal_after_get_profile_for_player</code>, both <code>wasm_after_get_profile_for_player</code> and
<code>wasm_after_get_profile_for_player_high_prio</code> will run (in priority order), and the <code>optional_last_value</code> combiner will
ensure the final result seen by the host macro is the value returned by the high-priority slot.</p><h2 id=the-full-picture-execution-flow-with-signals>The Full Picture: Execution Flow with Signals<a hidden class=anchor aria-hidden=true href=#the-full-picture-execution-flow-with-signals>#</a></h2><p>To understand the interplay between the WASM module, the host, and the signal system, let&rsquo;s trace the sequence of events
when the WASM module initiates an entity creation by calling <code>host_create_entity</code>. We assume the WASM slots
<code>wasm_before_create_entity</code> and <code>wasm_after_create_entity</code> have already been successfully connected to the corresponding
host signals via <code>connect_all_signals</code>.</p><p>The process begins within the WASM module. A call to the higher-level <code>entity::create_entity()</code> function occurs, which
in turn invokes the lower-level FFI wrapper <code>ffi::create_entity()</code>. Inside this FFI wrapper, the <code>unsafe</code> block executes
the actual call across the boundary: <code>host_create_entity()</code>.</p><p>Control now transfers to the C++ host. The specific lambda wrapper function, previously generated by the
<code>DEFINE_HOST_FUNC_0_ARGS_RET</code> macro and registered with Wasmtime&rsquo;s linker for the name <code>host_create_entity</code>, receives
this incoming call. The first action within this host lambda is to obtain a reference to the <code>SignalManager</code>. Following
this, the lambda emits the <code>signal_before_create_entity</code> signal, passing no arguments as per the signal&rsquo;s definition.</p><p>The <code>Boost.Signals2</code> framework intercepts this signal emission and proceeds to invoke any slots connected to
<code>signal_before_create_entity</code>. In our scenario, this triggers the execution of the host-side slot wrapper lambda that
was created specifically for the WASM function <code>"wasm_before_create_entity"</code>. This slot wrapper lambda prepares its
arguments (none in this case) and executes a Wasmtime call back into the module:
<code>host->callFunction&lt;int32_t>("wasm_before_create_entity", ...)</code>.</p><p>Execution jumps back to the WASM module, specifically to the <code>wasm_before_create_entity()</code> function. This function runs
its logic, typically printing a log message indicating it was called, and then returns its result, which is <code>0</code> (
representing false in C ABI boolean convention), signaling that the operation should proceed.</p><p>Back in the host, the slot wrapper lambda receives the <code>int32_t</code> result (<code>0</code>) from the Wasmtime call and unmarshals it
into a C++ <code>bool</code> (<code>false</code>). This boolean result is then passed back to the <code>Boost.Signals2</code> framework. The
<code>StopOnTrueCombiner</code> associated with <code>signal_before_create_entity</code> receives this <code>false</code> value. Since it&rsquo;s not <code>true</code>,
the combiner allows processing to continue (if other slots were connected, they would run now). Ultimately, the combiner
returns <code>false</code> to the original host function lambda that emitted the signal.</p><p>The host lambda checks the <code>skip</code> flag returned by the combiner. Since it&rsquo;s <code>false</code>, the lambda determines that the
operation should not be skipped and proceeds with the core logic. It now calls the underlying C API function:
<code>entt_manager_create_entity(manager_handle)</code>. This C API function, in turn, calls the <code>EnttManager::createEntity()</code>
method on the C++ manager object. Inside the manager, <code>registry_.create()</code> is invoked, a new EnTT entity is created, its
ID is converted to <code>uint32_t</code>, a creation log message is printed, and this <code>uint32_t</code> ID is returned.</p><p>The ID (<code>original_result</code>) travels back up the call stack from <code>EnttManager</code> to the C API function, and then to the host
lambda. Now, the host lambda emits the second signal: <code>signal_after_create_entity(original_result)</code>, passing the newly
created entity&rsquo;s ID.</p><p>Again, <code>Boost.Signals2</code> takes over, invoking the slots connected to <code>signal_after_create_entity</code>. This leads to the
execution of the slot wrapper lambda associated with <code>"wasm_after_create_entity"</code>, which is called with the
<code>original_id</code>. This wrapper lambda prepares its arguments (packing the <code>original_id</code> into a <code>wasmtime::Val</code>) and calls
back into the module: <code>host->callFunction&lt;int32_t>("wasm_after_create_entity", ...)</code>. Note the expected return is
<code>int32_t</code> because the WASM function returns <code>u32</code>, which fits in <code>i32</code>.</p><p>Execution returns to WASM&rsquo;s <code>wasm_after_create_entity(original_id)</code> function. It executes its logic (e.g., logging) and,
in this example, simply returns the <code>original_id</code> it received.</p><p>The host slot wrapper receives this ID as an <code>int32_t</code> result from Wasmtime and unmarshals it back into a <code>uint32_t</code>.
This value is passed to the <code>Boost.Signals2</code> framework. The <code>optional_last_value&lt;uint32_t></code> combiner associated with
<code>signal_after_create_entity</code> receives this result. As it&rsquo;s the only (or the last) slot executed, the combiner wraps this
value and returns <code>boost::optional&lt;uint32_t>(result)</code> to the host lambda.</p><p>The host lambda receives the combiner&rsquo;s result (<code>boost::optional&lt;uint32_t></code>). It extracts the contained value (or would
use a default if the optional were empty, though not expected here). This extracted value becomes the <code>final_result</code>.
The lambda then marshals this <code>final_result</code> (the entity ID) into the <code>results</code> span as a <code>wasmtime::Val</code> of kind <code>I32</code>
for the original WASM caller.</p><p>Finally, the host lambda completes its execution by returning success (<code>std::monostate()</code>) to the Wasmtime runtime.
Wasmtime then returns control back to the point where the initial <code>host_create_entity()</code> call was made within WASM&rsquo;s
<code>ffi::create_entity</code> function. This function receives the ID and returns it up to <code>entity::create_entity</code>, which then
uses <code>Entity::new(id)</code> to create the final Rust wrapper object for the newly created entity. This completes the entire
cross-boundary call sequence, including signal interceptions.</p><p>This detailed flow illustrates the powerful orchestration provided by <code>Boost.Signals2</code>, handling slot invocation,
argument passing (from signal to slot wrapper), return value combination, and allowing interception points before and
after the core C API logic, all while integrating with Wasmtime calls across the FFI boundary.</p><h2 id=benefits-and-considerations-revisited>Benefits and Considerations Revisited<a hidden class=anchor aria-hidden=true href=#benefits-and-considerations-revisited>#</a></h2><p>This significant refactoring effort yields substantial benefits for the overall architecture and maintainability of the
C++/Rust/WASM integration. Foremost among these is the establishment of a unified mechanism; the <code>Boost.Signals2</code> system
now replaces both the previous custom trigger implementation and the separate patching framework, providing a single,
consistent model for handling events between the host and the plugin. This contributes significantly to the system&rsquo;s
robustness. <code>Boost.Signals2</code> inherently manages signal-slot connections automatically, effectively preventing the common
issue of dangling callbacks that could arise in manual systems. Furthermore, its built-in combiner concept offers
standard and predictable methods for aggregating or processing results when multiple listeners (WASM slots) respond to
the same host signal. The refactoring also promotes better decoupling within the host application. The C API
implementation layer (<code>entt_api.cpp</code>), for instance, becomes considerably simpler as it no longer needs any intrinsic
awareness of the trigger or patching logic. The <code>EnttManager</code> class is similarly streamlined, offloading event
management responsibilities. Instead, the newly introduced C++ macros and the dedicated <code>SignalManager</code> now cleanly
encapsulate the logic related to signal emission and connection management. The system gains considerable flexibility
through the features offered by Boost.Signals2; assignable priorities allow for precise control over the execution order
of different WASM slots connected to the same signal, while the availability of various combiners enables the
implementation of diverse interaction patterns, such as allowing WASM to veto host actions, modify return values, or
simply receive notifications. Ultimately, this leads to improved maintainability. The clearer separation of concerns
between core logic, the C API, the signal management infrastructure, and the WASM FFI/slot implementation, combined with
the reliance on a well-established standard library like Boost.Signals2, makes the entire codebase easier for developers
to understand, debug, and modify safely over time.</p><p>However, adopting this approach also introduces several considerations that must be acknowledged. The most obvious is
the introduction of a new external dependency on the Boost library, specifically requiring <code>Boost.Signals2</code> which,
depending on the build system and configuration, might implicitly pull in other Boost components. There is also an
inherent increase in conceptual complexity; developers working with the system now need to understand the core concepts
of <code>Boost.Signals2</code>, including signals, slots, combiners, connection management, and the specific factory pattern used
within our <code>SignalManager</code>, which represents an initial learning curve compared to the simpler, albeit less robust,
custom solutions. Additionally, the C++ macro magic employed in <code>host_macros.h</code>, while effective at reducing repetitive
boilerplate code for signal emission, can also introduce a layer of opacity, potentially making it harder to debug the
exact flow of control within the host function wrappers without understanding the macro expansions. A critical point of
potential fragility remains in the FFI signature matching: the contract between the C++ host&rsquo;s slot wrapper lambda (
defined within the signal connector factory) and the signature of the exported Rust WASM slot function it intends to
call must be manually synchronized with extreme care. Any mismatch in parameter types, number of parameters, or return
types will not be caught at compile time but will manifest as difficult-to-diagnose runtime traps or undefined behavior.
Lastly, the reliance on string-based names persists during the crucial connection phase. Both the host-side
<code>connectWasmSlot</code> method and the WASM-side <code>connect_signal</code> wrapper function operate using string literals to identify
signals and WASM functions. Simple typographical errors in these string names will result in silent connection failures,
which can be challenging to track down without careful logging or debugging procedures on both sides of the FFI
boundary.</p><h2 id=conclusion-a-more-elegant-bridge>Conclusion: A More Elegant Bridge<a hidden class=anchor aria-hidden=true href=#conclusion-a-more-elegant-bridge>#</a></h2><p>By replacing our custom eventing system with <code>Boost.Signals2</code>, we&rsquo;ve significantly elevated the sophistication and
robustness of the interaction between our C++ EnTT host and the Rust WASM plugin. We now have a unified, flexible, and
more maintainable mechanism for the host and plugin to react to each other&rsquo;s actions, intercept operations, and modify
results in a controlled manner.</p><p>The <code>SignalManager</code> centralizes signal definition and connection logic, while the C++ macros provide a clean way to
instrument our existing host C API functions with signal emissions. On the WASM side, exporting dedicated slot functions
and using a single host call (<code>host_connect_signal</code>) to register them simplifies the plugin&rsquo;s responsibility. Features
like combiners (<code>StopOnTrueCombiner</code>, <code>optional_last_value</code>) and priorities unlock powerful patterns like vetoing
actions or overriding results, all managed by the <code>Boost.Signals2</code> framework.</p><p>While it introduces a Boost dependency and requires understanding its concepts, the payoff in terms of reduced custom
code complexity, automatic connection management, and standardized event handling is substantial. This architecture
provides a solid foundation for building even more intricate and dynamic interactions across the WASM boundary, proving
that even complex event-driven communication is achievable with the right tools and design patterns.</p><p>Our journey continues, but this refactoring marks a significant step towards a more mature and production-ready
C++/Rust/WASM integration.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/cpp/>Cpp</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/rust/>Rust</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/wasm/>Wasm</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/webassembly/>Webassembly</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/wasmtime/>Wasmtime</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/entt/>Entt</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/boost-signals2/>Boost-Signals2</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ffi/>Ffi</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/host-plugin/>Host-Plugin</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/plugin-architecture/>Plugin-Architecture</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ecs/>Ecs</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/entity-component-system/>Entity-Component-System</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/event-handling/>Event-Handling</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/signals-and-slots/>Signals-and-Slots</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/decoupling/>Decoupling</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/refactoring/>Refactoring</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/cross-language-communication/>Cross-Language-Communication</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-development/>Game-Development</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/simulation/>Simulation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/interoperability/>Interoperability</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/c-api/>C-Api</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/bridge/>Bridge</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/matrix-multiplication-performance-benchmark-from-triple-loops-to-100-plus-gflops-on-amd-ryzen-ai-radeon/><span class=title>« Prev</span><br><span>Matrix Multiplication Performance Benchmark: from Triple Loops to 100+ GFLOPS on AMD Ryzen AI + Radeon</span>
</a><a class=next href=https://tategotoazarasi.github.io/en/posts/bridging-the-gap-flexible-relationship-management-between-cpp-host-and-rust-wasm-plugins-using-entt/><span class=title>Next »</span><br><span>Bridging the Gap: Flexible Relationship Management Between C++ Host and Rust WASM Plugins using EnTT</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>