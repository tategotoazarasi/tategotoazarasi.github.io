<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python | Tategoto Azarasi</title>
<meta name=keywords content="python,geopandas,folium,data-visualization,gis,urban-planning,spatial-analysis,smart-city,data-science,hackathon"><meta name=description content="This post details how to build an interactive urban planning visualization system using Python, Geopandas, and Folium by integrating housing pipelines, crime data, and socioeconomic metrics."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tategotoazarasi.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tategotoazarasi.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tategotoazarasi.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tategotoazarasi.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.tategotoazarasi.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/><link rel=alternate hreflang=zh href=https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python"><meta property="og:description" content="This post details how to build an interactive urban planning visualization system using Python, Geopandas, and Folium by integrating housing pipelines, crime data, and socioeconomic metrics."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-03T20:32:25+00:00"><meta property="article:modified_time" content="2025-12-03T20:32:25+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Geopandas"><meta property="article:tag" content="Folium"><meta property="article:tag" content="Data-Visualization"><meta property="article:tag" content="Gis"><meta property="article:tag" content="Urban-Planning"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python"><meta name=twitter:description content="This post details how to build an interactive urban planning visualization system using Python, Geopandas, and Folium by integrating housing pipelines, crime data, and socioeconomic metrics."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tategotoazarasi.me/en/posts/"},{"@type":"ListItem","position":2,"name":"Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python","item":"https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python","name":"Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python","description":"This post details how to build an interactive urban planning visualization system using Python, Geopandas, and Folium by integrating housing pipelines, crime data, and socioeconomic metrics.","keywords":["python","geopandas","folium","data-visualization","gis","urban-planning","spatial-analysis","smart-city","data-science","hackathon"],"articleBody":"Recently, I had the opportunity to participate in a hackathon organized jointly by the Liverpool City Region Combined Authority (LCR CA) and Homes England. The context was both ambitious and pragmatic: the government holds a housing pipeline list containing approximately 350 sites, totalling over 57,000 new homes. However, this data was sitting quietly in Excel spreadsheets, existing merely as cold numbers.\nOur task was: How do we make this data “come alive”?\nAs developers, we know that simply plotting “here is a house” on a map is far from sufficient. Urban planning is a complex systemic engineering challenge. Where are we building? Is that area safe? What is the fuel poverty rate there? Is there social deprivation? Should we prioritize developing abandoned “Brownfield” sites?\nTo answer these questions, my team and I built a geospatial analysis and visualization system based on Python. We didn’t stop at simple data display; instead, we deeply integrated crime statistics, deprivation indices, brownfield data, and housing plans. Furthermore, we implemented a “vulnerability heatmap” with dynamic weighting using custom JavaScript.\nThis post will review the entire technical implementation process, hopefully providing some insights for those interested in GIS (Geographic Information Systems) and data visualization.\nData Silos and Bridges Before writing a single line of code, our biggest challenge was the heterogeneity of our data sources. We had five completely different formats:\nHousing Pipeline Data: The core dataset, in Excel format, containing project names, developers, postcodes, unit counts, etc. Boundaries: GeoJSON format, defining the geographic boundaries of the Liverpool City Region. LSOA Data: Lower Layer Super Output Areas (LSOA) are small geographic units defined by the UK Office for National Statistics, serving as our baseline for spatial analysis. Index of Multiple Deprivation (IMD) \u0026 Fuel Poverty: Excel format, providing socioeconomic indicators for each LSOA. Police Crime Data: The trickiest part. Hundreds of CSV files stored in monthly folders, containing specific latitude/longitude coordinates. Brownfield Data: GeoJSON format, containing the location and area of abandoned land. Our goal was to map these “siloed” datasets from different dimensions onto a unified geographic unit: the LSOA.\nData Cleaning and Geocoding The housing pipeline data only contained postcodes, not coordinates. This is a common issue in geospatial analysis. We used the pgeocode library to solve this. It relies on the GeoNames database, offering extremely fast queries without the need for expensive API calls like Google Maps.\nimport pgeocode import pandas as pd # Initialize UK postcode query object nomi = pgeocode.Nominatim(\"GB\") def batch_geocode(df, postcode_col): # Clean postcode format clean_postcodes = df[postcode_col].astype(str).str.strip() unique_pcs = clean_postcodes.unique() # Batch query for efficiency geo_results = nomi.query_postal_code(unique_pcs) # Create mapping dictionaries pc_to_lat = dict(zip(unique_pcs, geo_results.latitude)) pc_to_lon = dict(zip(unique_pcs, geo_results.longitude)) df[\"lat\"] = clean_postcodes.map(pc_to_lat) df[\"lon\"] = clean_postcodes.map(pc_to_lon) return df.dropna(subset=[\"lat\", \"lon\"]) This step was crucial as it converted business data (Excel) into spatial data (Points).\nHandling Massive Police Data The data provided by the police was exhaustive, covering every month of crime records for the past three years, including coordinates for “Stop \u0026 Search” events. There were hundreds of files.\nIf we tried to read all CSVs and plot every point on a map, the browser would crash instantly. Therefore, Spatial Aggregation was the only way forward. We needed to calculate how many crimes occurred within each LSOA.\nWe used pathlib for recursive file searching combined with Pandas for cleaning:\nfrom pathlib import Path # Recursively find all CSV files all_csvs = list(Path(\"police_data\").rglob(\"*.csv\")) stop_search_points = [] for csv_file in all_csvs: try: # Read only necessary coordinate columns to save memory df = pd.read_csv(csv_file, usecols=[\"Latitude\", \"Longitude\"]) df = df.dropna() # Roughly filter points outside Liverpool to speed up processing mask = (df['Latitude'].between(53.0, 54.0)) \u0026 \\ (df['Longitude'].between(-3.5, -2.0)) stop_search_points.append(df[mask]) except: continue # Concatenate all dataframes all_stops = pd.concat(stop_search_points, ignore_index=True) Spatial Join Now we had a pile of “points” (crime locations) and a pile of “polygons” (LSOA communities). The question we needed to answer was: Which polygon does this point belong to?\nIn geopandas, the sjoin (Spatial Join) function is the ultimate tool for this. It performs a database join operation based on geometric relationships.\nimport geopandas as gpd # Convert police data to GeoDataFrame gdf_stops = gpd.GeoDataFrame( all_stops, geometry=gpd.points_from_xy(all_stops.Longitude, all_stops.Latitude), crs=\"EPSG:4326\" ) # Core operation: Check which polygon contains the point (predicate='within') # lsoa_lcr is our administrative boundary polygon data stops_with_lsoa = gpd.sjoin(gdf_stops, lsoa_lcr[['LSOA21CD', 'geometry']], predicate='within') # Aggregation: Count crimes per LSOA stop_counts = stops_with_lsoa['LSOA21CD'].value_counts().reset_index() stop_counts.columns = ['LSOA21CD', 'StopSearch_Count'] Through this step, we transformed tens of thousands of discrete coordinate points into a single statistical metric for each community. This is the key to dimensionality reduction in spatial data.\nSimilarly, we merged Fuel Poverty data and Index of Multiple Deprivation (IMD) data into our master GeoDataFrame using the LSOA21CD code.\nConstructing a “Vulnerability Score” \u0026 Dynamic Normalization With the raw data in hand, we faced a new problem: the dimensions of the metrics were completely different. Crime counts might range from 0 to 500, poverty rates from 0% to 100%, and IMD is a rank from 1 to 10. To display these comprehensively on a single map, we needed Normalization.\nWe used Min-Max normalization to map all metrics to a range between 0 and 1. Notably, for IMD (where 1 represents the most deprived), we needed to invert it so that 1.0 represents “High Risk/Vulnerability”.\n# Normalize Fuel Poverty Rate f_min, f_max = master_gdf[\"Fuel_Poverty_Rate\"].min(), master_gdf[\"Fuel_Poverty_Rate\"].max() master_gdf[\"norm_fuel\"] = (master_gdf[\"Fuel_Poverty_Rate\"] - f_min) / (f_max - f_min) # Normalize IMD (Invert: 10 is least deprived, 1 is most -\u003e mapped so 1.0 is high risk) master_gdf[\"norm_imd\"] = (11 - master_gdf[\"IMD_Decile\"]) / 10.0 # Normalize Crime Data (Use 95th percentile as max to prevent outliers skewing the scale) c_max = master_gdf[\"Crime_Count\"].quantile(0.95) master_gdf[\"norm_crime\"] = (master_gdf[\"Crime_Count\"] / c_max).clip(upper=1.0) Why use the 95th percentile? In real-world urban data, crime rates in the City Centre are often orders of magnitude higher than in the suburbs. If we normalized using the absolute maximum, the City Centre would be deep red, while everywhere else would wash out to white, making suburban variations invisible. Clipping outliers preserves contrast for the majority of the region.\nVisualization A static chart generated by matplotlib is of limited use to decision-makers. We needed interactivity. We chose Folium (based on Leaflet.js), but native Folium functionality is limited—it doesn’t support “dragging a slider to change weights in real-time.”\nTo solve this, I adopted a strategy of injecting custom JavaScript.\nLayer Z-Index Management When overlaying multiple layers on a map, occlusion is the enemy. We strictly controlled layer hierarchy by creating custom Panes and setting z-index:\nLSOA Base Layer (z=400): Bottom layer, displaying the vulnerability heatmap. Housing Project Layer (z=620): Middle layer, displaying planned new homes (bubble chart). Brownfield Layer (z=650): Top layer, displaying available abandoned land points. import folium m = folium.Map(location=[centre_lat, centre_lon], zoom_start=11, tiles=\"CartoDB positron\") # Create custom panes folium.map.CustomPane(\"poly_pane\", z_index=400).add_to(m) folium.map.CustomPane(\"housing_pane\", z_index=620).add_to(m) folium.map.CustomPane(\"brownfield_pane\", z_index=650).add_to(m) Injecting JavaScript for Dynamic Weighting This was the core innovation of the project. We didn’t want to show a rigid map; we wanted to let users (like police chiefs, urban planners, or social workers) adjust weights based on their priorities.\nWe wrote the processed GeoJSON data and frontend logic directly into the HTML.\nfrom branca.element import Element # Convert Python processed data to JSON string for frontend injection geojson_str = master_gdf.to_json() custom_ui = f\"\"\" Layer Weights (LSOA Scoring) Fuel Poverty Crime Density \"\"\" m.get_root().html.add_child(Element(custom_ui)) This code implements a fully frontend-based interaction logic: once the data is processed by the Python backend, the browser handles real-time rendering and mathematical calculation. This ensures fluidity; when users drag sliders, the map colors transition smoothly, visually revealing high-risk areas under different priorities.\nVisualization Details for Housing \u0026 Brownfields For housing projects, we used CircleMarker.\nSize: Represents the number of planned homes (using square root scaling to keep bubble sizes sane). Fill Color: Represents development stage (Short, Medium, Long term). Border Color: Represents site area size. For Brownfields, we displayed them as small black dots on the topmost layer. Clicking them reveals details about planning permission status and prior use. This design allows planners to see at a glance: In this high-risk (red) area, are there available brownfield sites (black dots) that could be used to build new homes, thereby catalyzing urban regeneration?\n","wordCount":"1444","inLanguage":"en","datePublished":"2025-12-03T20:32:25Z","dateModified":"2025-12-03T20:32:25Z","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://blog.tategotoazarasi.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tategotoazarasi.me/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.tategotoazarasi.me/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.tategotoazarasi.me/en/ title=Home><span>Home</span></a></li><li><a href=https://blog.tategotoazarasi.me/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tategotoazarasi.me/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.tategotoazarasi.me/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python</h1><div class=post-meta><span title='2025-12-03 20:32:25 +0000 UTC'>December 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1444 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#data-silos-and-bridges>Data Silos and Bridges</a><ol><li><a href=#data-cleaning-and-geocoding>Data Cleaning and Geocoding</a></li><li><a href=#handling-massive-police-data>Handling Massive Police Data</a></li></ol></li><li><a href=#spatial-join>Spatial Join</a></li><li><a href=#constructing-a-vulnerability-score--dynamic-normalization>Constructing a &ldquo;Vulnerability Score&rdquo; & Dynamic Normalization</a></li><li><a href=#visualization>Visualization</a><ol><li><a href=#layer-z-index-management>Layer Z-Index Management</a></li><li><a href=#injecting-javascript-for-dynamic-weighting>Injecting JavaScript for Dynamic Weighting</a></li><li><a href=#visualization-details-for-housing--brownfields>Visualization Details for Housing & Brownfields</a></li></ol></li></ol></nav></div></details></div><div class=post-content><p>Recently, I had the opportunity to participate in a hackathon organized jointly by the Liverpool City Region Combined Authority (LCR CA) and Homes England. The context was both ambitious and pragmatic: the government holds a housing pipeline list containing approximately 350 sites, totalling over 57,000 new homes. However, this data was sitting quietly in Excel spreadsheets, existing merely as cold numbers.</p><p>Our task was: <strong>How do we make this data &ldquo;come alive&rdquo;?</strong></p><p>As developers, we know that simply plotting &ldquo;here is a house&rdquo; on a map is far from sufficient. Urban planning is a complex systemic engineering challenge. Where are we building? Is that area safe? What is the fuel poverty rate there? Is there social deprivation? Should we prioritize developing abandoned &ldquo;Brownfield&rdquo; sites?</p><p>To answer these questions, my team and I built a geospatial analysis and visualization system based on Python. We didn&rsquo;t stop at simple data display; instead, we deeply integrated crime statistics, deprivation indices, brownfield data, and housing plans. Furthermore, we implemented a &ldquo;vulnerability heatmap&rdquo; with dynamic weighting using custom JavaScript.</p><p>This post will review the entire technical implementation process, hopefully providing some insights for those interested in GIS (Geographic Information Systems) and data visualization.</p><hr><h2 id=data-silos-and-bridges>Data Silos and Bridges<a hidden class=anchor aria-hidden=true href=#data-silos-and-bridges>#</a></h2><p>Before writing a single line of code, our biggest challenge was the heterogeneity of our data sources. We had five completely different formats:</p><ol><li><strong>Housing Pipeline Data</strong>: The core dataset, in Excel format, containing project names, developers, postcodes, unit counts, etc.</li><li><strong>Boundaries</strong>: GeoJSON format, defining the geographic boundaries of the Liverpool City Region.</li><li><strong>LSOA Data</strong>: Lower Layer Super Output Areas (LSOA) are small geographic units defined by the UK Office for National Statistics, serving as our baseline for spatial analysis.</li><li><strong>Index of Multiple Deprivation (IMD) & Fuel Poverty</strong>: Excel format, providing socioeconomic indicators for each LSOA.</li><li><strong>Police Crime Data</strong>: The trickiest part. Hundreds of CSV files stored in monthly folders, containing specific latitude/longitude coordinates.</li><li><strong>Brownfield Data</strong>: GeoJSON format, containing the location and area of abandoned land.</li></ol><p>Our goal was to map these &ldquo;siloed&rdquo; datasets from different dimensions onto a unified geographic unit: the <strong>LSOA</strong>.</p><h3 id=data-cleaning-and-geocoding>Data Cleaning and Geocoding<a hidden class=anchor aria-hidden=true href=#data-cleaning-and-geocoding>#</a></h3><p>The housing pipeline data only contained postcodes, not coordinates. This is a common issue in geospatial analysis. We used the <code>pgeocode</code> library to solve this. It relies on the GeoNames database, offering extremely fast queries without the need for expensive API calls like Google Maps.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pgeocode
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Initialize UK postcode query object</span>
</span></span><span style=display:flex><span>nomi <span style=color:#f92672>=</span> pgeocode<span style=color:#f92672>.</span>Nominatim(<span style=color:#e6db74>&#34;GB&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>batch_geocode</span>(df, postcode_col):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Clean postcode format</span>
</span></span><span style=display:flex><span>    clean_postcodes <span style=color:#f92672>=</span> df[postcode_col]<span style=color:#f92672>.</span>astype(str)<span style=color:#f92672>.</span>str<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>    unique_pcs <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>unique()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Batch query for efficiency</span>
</span></span><span style=display:flex><span>    geo_results <span style=color:#f92672>=</span> nomi<span style=color:#f92672>.</span>query_postal_code(unique_pcs)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create mapping dictionaries</span>
</span></span><span style=display:flex><span>    pc_to_lat <span style=color:#f92672>=</span> dict(zip(unique_pcs, geo_results<span style=color:#f92672>.</span>latitude))
</span></span><span style=display:flex><span>    pc_to_lon <span style=color:#f92672>=</span> dict(zip(unique_pcs, geo_results<span style=color:#f92672>.</span>longitude))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;lat&#34;</span>] <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>map(pc_to_lat)
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;lon&#34;</span>] <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>map(pc_to_lon)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> df<span style=color:#f92672>.</span>dropna(subset<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;lat&#34;</span>, <span style=color:#e6db74>&#34;lon&#34;</span>])
</span></span></code></pre></div><p>This step was crucial as it converted business data (Excel) into spatial data (Points).</p><h3 id=handling-massive-police-data>Handling Massive Police Data<a hidden class=anchor aria-hidden=true href=#handling-massive-police-data>#</a></h3><p>The data provided by the police was exhaustive, covering every month of crime records for the past three years, including coordinates for &ldquo;Stop & Search&rdquo; events. There were hundreds of files.</p><p>If we tried to read all CSVs and plot every point on a map, the browser would crash instantly. Therefore, <strong>Spatial Aggregation</strong> was the only way forward. We needed to calculate how many crimes occurred within each LSOA.</p><p>We used <code>pathlib</code> for recursive file searching combined with Pandas for cleaning:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Recursively find all CSV files</span>
</span></span><span style=display:flex><span>all_csvs <span style=color:#f92672>=</span> list(Path(<span style=color:#e6db74>&#34;police_data&#34;</span>)<span style=color:#f92672>.</span>rglob(<span style=color:#e6db74>&#34;*.csv&#34;</span>))
</span></span><span style=display:flex><span>stop_search_points <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> csv_file <span style=color:#f92672>in</span> all_csvs:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Read only necessary coordinate columns to save memory</span>
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(csv_file, usecols<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;Latitude&#34;</span>, <span style=color:#e6db74>&#34;Longitude&#34;</span>])
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>dropna()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Roughly filter points outside Liverpool to speed up processing</span>
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#39;Latitude&#39;</span>]<span style=color:#f92672>.</span>between(<span style=color:#ae81ff>53.0</span>, <span style=color:#ae81ff>54.0</span>)) <span style=color:#f92672>&amp;</span> \
</span></span><span style=display:flex><span>               (df[<span style=color:#e6db74>&#39;Longitude&#39;</span>]<span style=color:#f92672>.</span>between(<span style=color:#f92672>-</span><span style=color:#ae81ff>3.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span>))
</span></span><span style=display:flex><span>        stop_search_points<span style=color:#f92672>.</span>append(df[mask])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Concatenate all dataframes</span>
</span></span><span style=display:flex><span>all_stops <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>concat(stop_search_points, ignore_index<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><hr><h2 id=spatial-join>Spatial Join<a hidden class=anchor aria-hidden=true href=#spatial-join>#</a></h2><p>Now we had a pile of &ldquo;points&rdquo; (crime locations) and a pile of &ldquo;polygons&rdquo; (LSOA communities). The question we needed to answer was: <strong>Which polygon does this point belong to?</strong></p><p>In <code>geopandas</code>, the <code>sjoin</code> (Spatial Join) function is the ultimate tool for this. It performs a database join operation based on geometric relationships.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> geopandas <span style=color:#66d9ef>as</span> gpd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Convert police data to GeoDataFrame</span>
</span></span><span style=display:flex><span>gdf_stops <span style=color:#f92672>=</span> gpd<span style=color:#f92672>.</span>GeoDataFrame(
</span></span><span style=display:flex><span>    all_stops, 
</span></span><span style=display:flex><span>    geometry<span style=color:#f92672>=</span>gpd<span style=color:#f92672>.</span>points_from_xy(all_stops<span style=color:#f92672>.</span>Longitude, all_stops<span style=color:#f92672>.</span>Latitude),
</span></span><span style=display:flex><span>    crs<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;EPSG:4326&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Core operation: Check which polygon contains the point (predicate=&#39;within&#39;)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lsoa_lcr is our administrative boundary polygon data</span>
</span></span><span style=display:flex><span>stops_with_lsoa <span style=color:#f92672>=</span> gpd<span style=color:#f92672>.</span>sjoin(gdf_stops, lsoa_lcr[[<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>, <span style=color:#e6db74>&#39;geometry&#39;</span>]], predicate<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;within&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Aggregation: Count crimes per LSOA</span>
</span></span><span style=display:flex><span>stop_counts <span style=color:#f92672>=</span> stops_with_lsoa[<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>]<span style=color:#f92672>.</span>value_counts()<span style=color:#f92672>.</span>reset_index()
</span></span><span style=display:flex><span>stop_counts<span style=color:#f92672>.</span>columns <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>, <span style=color:#e6db74>&#39;StopSearch_Count&#39;</span>]
</span></span></code></pre></div><p>Through this step, we transformed tens of thousands of discrete coordinate points into a single statistical metric for each community. This is the key to dimensionality reduction in spatial data.</p><p>Similarly, we merged Fuel Poverty data and Index of Multiple Deprivation (IMD) data into our master GeoDataFrame using the <code>LSOA21CD</code> code.</p><hr><h2 id=constructing-a-vulnerability-score--dynamic-normalization>Constructing a &ldquo;Vulnerability Score&rdquo; & Dynamic Normalization<a hidden class=anchor aria-hidden=true href=#constructing-a-vulnerability-score--dynamic-normalization>#</a></h2><p>With the raw data in hand, we faced a new problem: the dimensions of the metrics were completely different. Crime counts might range from 0 to 500, poverty rates from 0% to 100%, and IMD is a rank from 1 to 10. To display these comprehensively on a single map, we needed <strong>Normalization</strong>.</p><p>We used Min-Max normalization to map all metrics to a range between 0 and 1. Notably, for IMD (where 1 represents the most deprived), we needed to invert it so that 1.0 represents &ldquo;High Risk/Vulnerability&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Normalize Fuel Poverty Rate</span>
</span></span><span style=display:flex><span>f_min, f_max <span style=color:#f92672>=</span> master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>]<span style=color:#f92672>.</span>min(), master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_fuel&#34;</span>] <span style=color:#f92672>=</span> (master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>] <span style=color:#f92672>-</span> f_min) <span style=color:#f92672>/</span> (f_max <span style=color:#f92672>-</span> f_min)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Normalize IMD (Invert: 10 is least deprived, 1 is most -&gt; mapped so 1.0 is high risk)</span>
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_imd&#34;</span>] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>11</span> <span style=color:#f92672>-</span> master_gdf[<span style=color:#e6db74>&#34;IMD_Decile&#34;</span>]) <span style=color:#f92672>/</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Normalize Crime Data (Use 95th percentile as max to prevent outliers skewing the scale)</span>
</span></span><span style=display:flex><span>c_max <span style=color:#f92672>=</span> master_gdf[<span style=color:#e6db74>&#34;Crime_Count&#34;</span>]<span style=color:#f92672>.</span>quantile(<span style=color:#ae81ff>0.95</span>)
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_crime&#34;</span>] <span style=color:#f92672>=</span> (master_gdf[<span style=color:#e6db74>&#34;Crime_Count&#34;</span>] <span style=color:#f92672>/</span> c_max)<span style=color:#f92672>.</span>clip(upper<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>)
</span></span></code></pre></div><p><strong>Why use the 95th percentile?</strong>
In real-world urban data, crime rates in the City Centre are often orders of magnitude higher than in the suburbs. If we normalized using the absolute maximum, the City Centre would be deep red, while everywhere else would wash out to white, making suburban variations invisible. Clipping outliers preserves contrast for the majority of the region.</p><hr><h2 id=visualization>Visualization<a hidden class=anchor aria-hidden=true href=#visualization>#</a></h2><p>A static chart generated by <code>matplotlib</code> is of limited use to decision-makers. We needed interactivity. We chose <code>Folium</code> (based on Leaflet.js), but native Folium functionality is limited—it doesn&rsquo;t support &ldquo;dragging a slider to change weights in real-time.&rdquo;</p><p>To solve this, I adopted a strategy of <strong>injecting custom JavaScript</strong>.</p><h3 id=layer-z-index-management>Layer Z-Index Management<a hidden class=anchor aria-hidden=true href=#layer-z-index-management>#</a></h3><p>When overlaying multiple layers on a map, occlusion is the enemy. We strictly controlled layer hierarchy by creating custom Panes and setting <code>z-index</code>:</p><ol><li><strong>LSOA Base Layer (z=400)</strong>: Bottom layer, displaying the vulnerability heatmap.</li><li><strong>Housing Project Layer (z=620)</strong>: Middle layer, displaying planned new homes (bubble chart).</li><li><strong>Brownfield Layer (z=650)</strong>: Top layer, displaying available abandoned land points.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> folium
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> folium<span style=color:#f92672>.</span>Map(location<span style=color:#f92672>=</span>[centre_lat, centre_lon], zoom_start<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>, tiles<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;CartoDB positron&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create custom panes</span>
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;poly_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>400</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;housing_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>620</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;brownfield_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>650</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span></code></pre></div><h3 id=injecting-javascript-for-dynamic-weighting>Injecting JavaScript for Dynamic Weighting<a hidden class=anchor aria-hidden=true href=#injecting-javascript-for-dynamic-weighting>#</a></h3><p>This was the core innovation of the project. We didn&rsquo;t want to show a rigid map; we wanted to let users (like police chiefs, urban planners, or social workers) adjust weights based on their priorities.</p><p>We wrote the processed GeoJSON data and frontend logic directly into the HTML.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> branca.element <span style=color:#f92672>import</span> Element
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Convert Python processed data to JSON string for frontend injection</span>
</span></span><span style=display:flex><span>geojson_str <span style=color:#f92672>=</span> master_gdf<span style=color:#f92672>.</span>to_json()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>custom_ui <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;div id=&#34;controls&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;h4&gt;Layer Weights (LSOA Scoring)&lt;/h4&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;!-- Sliders --&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;div&gt;&lt;label&gt;Fuel Poverty&lt;/label&gt;&lt;input type=&#34;range&#34; id=&#34;w_fuel&#34; oninput=&#34;updateWeights()&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;div&gt;&lt;label&gt;Crime Density&lt;/label&gt;&lt;input type=&#34;range&#34; id=&#34;w_crime&#34; oninput=&#34;updateWeights()&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;!-- ... other sliders ... --&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;script&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    var lsoaData = </span><span style=color:#e6db74>{</span>geojson_str<span style=color:#e6db74>}</span><span style=color:#e6db74>; // Inject data
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    // Function to calculate score dynamically
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    function updateWeights() </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        // Get slider values
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        var w_fuel = parseFloat(document.getElementById(&#39;w_fuel&#39;).value);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        var w_crime = parseFloat(document.getElementById(&#39;w_crime&#39;).value);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        // Iterate through features and recalculate color
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        geojsonLayer.eachLayer(function(layer) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            var p = layer.feature.properties;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            // Weighted average formula
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            var score = (p.norm_fuel * w_fuel + p.norm_crime * w_crime) / (w_fuel + w_crime);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            // Set style dynamically
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            layer.setStyle(</span><span style=color:#ae81ff>{{</span><span style=color:#e6db74> fillColor: getColor(score) </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;/script&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>m<span style=color:#f92672>.</span>get_root()<span style=color:#f92672>.</span>html<span style=color:#f92672>.</span>add_child(Element(custom_ui))
</span></span></code></pre></div><p>This code implements a fully frontend-based interaction logic: once the data is processed by the Python backend, the browser handles real-time rendering and mathematical calculation. This ensures fluidity; when users drag sliders, the map colors transition smoothly, visually revealing high-risk areas under different priorities.</p><h3 id=visualization-details-for-housing--brownfields>Visualization Details for Housing & Brownfields<a hidden class=anchor aria-hidden=true href=#visualization-details-for-housing--brownfields>#</a></h3><p>For housing projects, we used <code>CircleMarker</code>.</p><ul><li><strong>Size</strong>: Represents the number of planned homes (using square root scaling to keep bubble sizes sane).</li><li><strong>Fill Color</strong>: Represents development stage (Short, Medium, Long term).</li><li><strong>Border Color</strong>: Represents site area size.</li></ul><p>For Brownfields, we displayed them as small black dots on the topmost layer. Clicking them reveals details about planning permission status and prior use. This design allows planners to see at a glance: <strong>In this high-risk (red) area, are there available brownfield sites (black dots) that could be used to build new homes, thereby catalyzing urban regeneration?</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tategotoazarasi.me/en/tags/python/>Python</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/geopandas/>Geopandas</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/folium/>Folium</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/data-visualization/>Data-Visualization</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/gis/>Gis</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/urban-planning/>Urban-Planning</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/spatial-analysis/>Spatial-Analysis</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/smart-city/>Smart-City</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/data-science/>Data-Science</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/hackathon/>Hackathon</a></li></ul><nav class=paginav><a class=next href=https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/><span class=title>Next »</span><br><span>Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.tategotoazarasi.me/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>