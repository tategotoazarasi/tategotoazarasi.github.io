<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building New Worlds: A Deep Dive into Procedural Generation for Video Games | Tategoto Azarasi</title>
<meta name=keywords content="procedural-content-generation,video-game-worlds,terrain-generation,noise-functions,perlin-noise,simplex-noise,fractal-noise,heightmaps,plate-tectonics,erosion-simulation,hydraulic-erosion,thermal-erosion,river-networks,climate-simulation,biomes,map-geometry,tiling-systems,data-structures,game-development,world-building,pcg,game-design,procedural-generation,terrain-algorithms,noise,geology-simulation,climate-modeling,biome-distribution,voronoi-diagrams,hex-grids,worldengine,mapgen4,tectonics-js,minecraft,no-mans-sky,dwarf-fortress,cplusplus,future-trends,interactive-worlds,digital-worldsmithing"><meta name=description content="Ever stepped into a vast, sprawling game world and wondered, &ldquo;How did they build all this?&rdquo; From the infinite blocky
landscapes of Minecraft to the galaxy-spanning planets of No Man&rsquo;s Sky or the intricate simulated histories of
Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).
Instead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions –
to generate game content automatically. This isn&rsquo;t just about saving time (though it certainly helps!); it&rsquo;s about
creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that&rsquo;s different
every single time you start a new game, a world generated just for you, with its own unique geography, climate, and
maybe even history. That&rsquo;s the power and allure of PCG."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Building New Worlds: A Deep Dive into Procedural Generation for Video Games"><meta property="og:description" content="Ever stepped into a vast, sprawling game world and wondered, “How did they build all this?” From the infinite blocky landscapes of Minecraft to the galaxy-spanning planets of No Man’s Sky or the intricate simulated histories of Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).
Instead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions – to generate game content automatically. This isn’t just about saving time (though it certainly helps!); it’s about creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that’s different every single time you start a new game, a world generated just for you, with its own unique geography, climate, and maybe even history. That’s the power and allure of PCG."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-28T19:04:14+08:00"><meta property="article:modified_time" content="2025-03-28T19:04:14+08:00"><meta property="article:tag" content="Procedural-Content-Generation"><meta property="article:tag" content="Video-Game-Worlds"><meta property="article:tag" content="Terrain-Generation"><meta property="article:tag" content="Noise-Functions"><meta property="article:tag" content="Perlin-Noise"><meta property="article:tag" content="Simplex-Noise"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building New Worlds: A Deep Dive into Procedural Generation for Video Games"><meta name=twitter:description content="Ever stepped into a vast, sprawling game world and wondered, &ldquo;How did they build all this?&rdquo; From the infinite blocky
landscapes of Minecraft to the galaxy-spanning planets of No Man&rsquo;s Sky or the intricate simulated histories of
Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).
Instead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions –
to generate game content automatically. This isn&rsquo;t just about saving time (though it certainly helps!); it&rsquo;s about
creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that&rsquo;s different
every single time you start a new game, a world generated just for you, with its own unique geography, climate, and
maybe even history. That&rsquo;s the power and allure of PCG."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Building New Worlds: A Deep Dive into Procedural Generation for Video Games","item":"https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building New Worlds: A Deep Dive into Procedural Generation for Video Games","name":"Building New Worlds: A Deep Dive into Procedural Generation for Video Games","description":"Ever stepped into a vast, sprawling game world and wondered, \u0026ldquo;How did they build all this?\u0026rdquo; From the infinite blocky landscapes of Minecraft to the galaxy-spanning planets of No Man\u0026rsquo;s Sky or the intricate simulated histories of Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).\nInstead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions – to generate game content automatically. This isn\u0026rsquo;t just about saving time (though it certainly helps!); it\u0026rsquo;s about creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that\u0026rsquo;s different every single time you start a new game, a world generated just for you, with its own unique geography, climate, and maybe even history. That\u0026rsquo;s the power and allure of PCG.\n","keywords":["procedural-content-generation","video-game-worlds","terrain-generation","noise-functions","perlin-noise","simplex-noise","fractal-noise","heightmaps","plate-tectonics","erosion-simulation","hydraulic-erosion","thermal-erosion","river-networks","climate-simulation","biomes","map-geometry","tiling-systems","data-structures","game-development","world-building","pcg","game-design","procedural-generation","terrain-algorithms","noise","geology-simulation","climate-modeling","biome-distribution","voronoi-diagrams","hex-grids","worldengine","mapgen4","tectonics-js","minecraft","no-mans-sky","dwarf-fortress","cplusplus","future-trends","interactive-worlds","digital-worldsmithing"],"articleBody":"Ever stepped into a vast, sprawling game world and wondered, “How did they build all this?” From the infinite blocky landscapes of Minecraft to the galaxy-spanning planets of No Man’s Sky or the intricate simulated histories of Dwarf Fortress, the answer often lies in a fascinating field: Procedural Content Generation (PCG).\nInstead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions – to generate game content automatically. This isn’t just about saving time (though it certainly helps!); it’s about creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that’s different every single time you start a new game, a world generated just for you, with its own unique geography, climate, and maybe even history. That’s the power and allure of PCG.\nThis post is a deep dive into the technologies, algorithms, and methods used to generate these fictional worlds, focusing primarily on the large-scale environmental aspects: the maps, the terrain, the climate, and the biomes that bring these virtual places to life. We’ll cover:\nThe Fundamentals: What PCG is, the magic of seeds, and the crucial role of noise functions (Perlin, Simplex, and friends). Shaping the World: Different map geometries (flat vs. spherical) and tiling systems (squares, hexes, irregular shapes). Raising the Land: Techniques for creating continents and oceans, from simple noise heightmaps to sophisticated plate tectonics simulations. Carving the Details: How erosion (water and thermal) and river systems turn basic terrain into believable landscapes. Breathing Life into It: Simulating climate (temperature, rainfall, wind) and distributing biomes (deserts, forests, tundras). Under the Hood: The data structures used to represent these complex worlds. Learning from the Masters: Quick looks at how systems like WorldEngine, Mapgen4, and Tectonics.js put these ideas into practice. Code Corner: Practical C++ snippets illustrating core concepts like noise and erosion. The Horizon: Where world generation might be heading next. Whether you’re a seasoned game developer, an aspiring world-builder, or just curious about the magic behind your favorite games, grab a virtual pickaxe, and let’s dig in!\nThe Building Blocks: Fundamentals of Procedural World Generation At its heart, procedural generation is about using algorithms to create content instead of manually authoring every detail. Think of it like giving the computer a recipe rather than a finished cake. The recipe (the algorithm) defines the steps, and the computer follows them to bake a unique cake (the game world) each time, potentially with slight variations based on the ingredients (parameters and randomness).\nThe Seed of Creation A key concept is the seed. Most procedural generation relies on pseudorandom number generators (PRNGs). These algorithms produce sequences of numbers that appear random but are actually deterministic. If you start a PRNG with the same initial value, called the seed, it will always produce the exact same sequence of numbers.\nIn game development, this is incredibly powerful. You can generate a massive, complex world using algorithms driven by a PRNG. Instead of storing gigabytes of map data, you just need to store the generation algorithms and a single seed number (often just a 32-bit or 64-bit integer). When a player wants to play that specific world again or share it with a friend, they just need the seed. This is how games like Minecraft allow players to share specific world layouts [1].\nWhy Go Procedural? The benefits are compelling:\nContent Variety \u0026 Replayability Generate near-infinite unique worlds, levels, or items, keeping the experience fresh [1].\nDevelopment Efficiency \u0026 Scalability Create vast amounts of content with potentially less manual effort, allowing small teams to build large worlds.\nReduced Storage/Download Size Store the generator (code) and a seed, not the massive output data [1].\nEmergent Possibilities Complex interactions between simple procedural rules can lead to unexpected and interesting results.\nThe Challenges Of course, it’s not magic. Getting PCG right involves challenges:\nCoherence and Quality Ensuring generated content makes sense, looks good, and is playable. Randomness needs structure.\nAvoiding Repetition Making sure the generated content doesn’t feel monotonous or obviously algorithmic.\nArtistic Control Giving designers enough control to guide the generation towards a specific vision, rather than accepting whatever the algorithm spits out. This often involves hybrid approaches, where procedural elements are combined with hand-authored content or guided by designer-specified constraints.\nDebugging Finding bugs in content that only appears under certain random seeds can be tricky.\nNoise: The Canvas of Creation One of the most fundamental tools in the procedural generation toolbox, especially for terrain and textures, is **noise **. We’re not talking about audio noise, but rather mathematical functions that generate pseudo-random, yet structured, patterns. Unlike pure rand(), which gives unrelated values at each point, noise functions produce values that vary smoothly across space.\nPerlin Noise Developed by Ken Perlin in the 1980s (earning him an Academy Award!), Perlin noise is a type of gradient noise. It works by setting up a grid and assigning a random gradient (direction) vector to each grid point. To get the noise value at any location within a grid cell, you calculate vectors from the location to the cell’s corners, compute the dot product with the corner gradients, and then smoothly interpolate these values [2]. The result is a smooth, continuous, organic-looking pattern often used for terrain heightmaps, clouds, fire effects, and wood grain textures [1]. However, because it’s based on a square/cubic grid, Perlin noise can sometimes exhibit subtle directional artifacts, especially noticeable at lower frequencies.\nSimplex Noise Also developed by Ken Perlin (in 2001) to address some of Perlin noise’s limitations, Simplex noise uses a simpler lattice structure (triangles in 2D, tetrahedra in 3D) instead of a square/cubic grid [3]. This results in several advantages:\nLower computational complexity, especially in higher dimensions. No significant directional artifacts (more isotropic). Smoother visual appearance. For these reasons, Simplex noise is often preferred for modern terrain generation [4]. Value Noise A simpler approach where random values (not gradients) are assigned to grid points, and the noise value at any location is found by smoothly interpolating the values at the surrounding grid points [5]. It’s computationally cheaper than gradient noise but can sometimes look blockier or less “natural.”\nFractional Brownian Motion (fBm) / Fractal Noise This isn’t a single noise function but a technique for combining multiple layers (called octaves) of a base noise function (like Perlin or Simplex) at different frequencies and amplitudes [6].\nThe first octave (low frequency, high amplitude) creates large, broad features. Subsequent octaves add progressively higher frequencies and lower amplitudes, layering finer and finer details on top. The key parameters are:\nPersistence Controls how much the amplitude decreases for each successive octave (typically \u003c 1).\nLacunarity Controls how much the frequency increases for each successive octave (typically \u003e 1). By summing these layers, you get a “fractal” appearance – statistical self-similarity across different scales, much like real mountains or coastlines. fBm is the workhorse for generating realistic-looking base terrain heightmaps.\nHere’s a conceptual C++ snippet showing how fBm (or “octave noise”) might be implemented using a placeholder noise2D function (which could be Perlin or Simplex):\n#include #include #include // For seeding, though actual noise uses deterministic hashing // Placeholder noise function: returns noise value in [-1,1] for coordinates (x,y). // In reality, this would involve permutation tables, gradient vectors, interpolation etc. // See libraries like FastNoiseLite, libnoise, or implement Perlin/Simplex yourself. double noise2D(double x, double y); // Generate fractal noise (fBm) by summing octaves of noise double fractalBrownianMotion(double x, double y, int octaves, double persistence = 0.5, double lacunarity = 2.0) { double totalValue = 0.0; double frequency = 1.0; double amplitude = 1.0; double maxValue = 0.0; // Used for normalization for (int i = 0; i \u003c octaves; ++i) { totalValue += amplitude * noise2D(x * frequency, y * frequency); maxValue += amplitude; // Accumulate max possible amplitude amplitude *= persistence; // Decrease amplitude for next octave frequency *= lacunarity; // Increase frequency for next octave } // Normalize the result to be roughly in [-1, 1] (assuming noise2D is in [-1, 1]) if (maxValue \u003e 0) { return totalValue / maxValue; } else { return 0.0; // Avoid division by zero if octaves=0 or amplitude=0 } } int main() { const int width = 512, height = 512; std::vector\u003cstd::vector\u003cdouble\u003e\u003e heightmap(height, std::vector\u003cdouble\u003e(width)); // --- Noise Initialization Would Go Here --- // (e.g., seeding the PRNG, setting up permutation tables for Perlin/Simplex) // --- Generate Heightmap using fBm --- int numOctaves = 8; double noisePersistence = 0.5; // Standard 1/f noise characteristic double noiseLacunarity = 2.0; double baseFrequency = 2.0; // Controls the overall scale of the largest features for (int y = 0; y \u003c height; ++y) { for (int x = 0; x \u003c width; ++x) { // Map pixel coordinates to noise input coordinates // Dividing by width/height scales input; baseFrequency adjusts overall scale double nx = (double(x) / width) * baseFrequency; double ny = (double(y) / height) * baseFrequency; // Generate fBm noise value double elevation = fractalBrownianMotion(nx, ny, numOctaves, noisePersistence, noiseLacunarity); // Map the noise value (e.g., [-1, 1]) to your desired height range // Example: Map to [0, 1] heightmap[y][x] = (elevation + 1.0) * 0.5; } } // --- Use the Heightmap --- // (e.g., render it, determine land/water based on a threshold, etc.) // ... return 0; } Noise functions are the fundamental texture, the raw material from which many procedural worlds are sculpted. But just applying noise isn’t enough to create a believable world. We need structure, geology, and the effects of natural processes.\nShaping the Canvas: Map Geometry and Representation Before we can paint mountains and rivers, we need a canvas. How do we represent the game world? The choice of map geometry has profound implications for everything that follows.\nFlat Maps (Planar Worlds) The simplest approach is to treat the world as a 2D plane.\nInfinite Continuous Planes Games like Minecraft conceptually use an infinite plane. The world isn’t pre-generated; chunks are generated on the fly as the player explores, often using noise functions evaluated at the chunk’s coordinates. Techniques like periodic noise or careful coordinate management are needed to ensure chunks stitch together seamlessly [7].\nBounded Planes Simpler maps might just have hard edges (invisible walls or an “edge of the world”). This is easy but can feel artificial.\nWrapped Planes (Toroidal Worlds) To eliminate edges, flat maps can be “wrapped.” Going off the east edge brings you to the west edge, and going off the north edge brings you to the south. Topologically, this creates a torus (a donut shape), not a sphere. This is common in older strategy games or simulations where a finite but borderless world is desired [8].\nSpherical Maps (Planetary Worlds) For simulating planets, strategy games spanning a globe, or space exploration games, a spherical representation is more realistic. However, this introduces complexity. How do you map a sphere onto data structures and display it on a 2D screen?\nChallenges Representing a sphere without significant distortion or awkward singularities (like the poles in latitude-longitude grids) is tricky. An equirectangular projection (mapping latitude/longitude directly to a rectangular grid) is simple but severely stretches areas near the poles and collapses everything to a single point at the poles.\nCommon Solutions Cube Mapping Project the sphere onto the six faces of a cube. Each face can be treated as a regular square grid, minimizing distortion compared to equirectangular. The main challenge is handling the seams/edges between the cube faces smoothly.\nIcosahedral Subdivision (Geodesic Grids) Start with an icosahedron (20 triangular faces) inscribed within the sphere. Project its vertices onto the sphere. Then, recursively subdivide each triangle into smaller triangles, projecting new vertices onto the sphere. This creates a geodesic dome structure. The dual of this triangular mesh (connecting the centers of adjacent triangles) results in a grid composed mostly of hexagons, with exactly 12 pentagons located at the original icosahedron’s vertices (think of a soccer ball pattern) [4]. This hex-pent grid provides relatively uniform cell sizes and shapes across the sphere, making it popular for global climate models and some planetary generators [4]. The main complexity lies in the data structures needed to handle the 12 pentagons and track neighbor relationships.\nFibonacci Lattice / Spiral Points Algorithms exist to distribute points quasi-uniformly on a sphere’s surface using spiral patterns related to the Fibonacci sequence or golden ratio [4]. These points can then be used as centers for Voronoi regions or vertices for a Delaunay triangulation, creating an irregular but relatively even mesh covering the sphere. Amit Patel’s influential planet generation experiments often start by distributing points this way, then slightly “jittering” them to avoid unnatural regularity [4].\nTiling Schemes: Squares vs. Hexes vs. Irregular Whether the map is flat or spherical (represented facet by facet, like a cube map or geodesic grid), we often divide it into discrete units or tiles for gameplay or simulation purposes.\nSquare Tiles The simplest. Easy to address (row, column), easy to map to pixel grids. Neighbors are straightforward (4 cardinal, possibly 4 diagonal). The main drawback, especially for movement or area-of-effect calculations, is the difference between orthogonal and diagonal distances/connectivity.\nHexagonal Tiles A favorite for many strategy games (Civilization V/VI, RimWorld’s planet map). Why?\nUniform Adjacency Each hex has 6 neighbors, all equidistant from the center. This eliminates the diagonal vs. orthogonal awkwardness of squares, making movement costs and distances more consistent.\nConnectivity The 6-way connectivity can lead to more organic-looking shapes for landmasses and region boundaries.\nImplementation Requires slightly more complex coordinate systems (axial or cube coordinates are common) and careful handling of neighbor finding and wrapping, especially on a sphere. Excellent guides exist, notably from Red Blob Games [9] [8].\nIrregular Polygons (Voronoi/Graph-Based) Instead of uniform tiles, partition the map using irregular polygons, often generated via a Voronoi diagram.\nScatter a set of points (seeds) across the map (plane or sphere). For each seed, define its region (cell) as all locations closer to that seed than any other. The result is a tessellation of the map into irregular polygonal cells. Amit Patel’s Polygon Map Generation tutorials are seminal work in this area [10].\nAdvantages Can produce much more natural-looking coastlines, region boundaries, and river paths (which can flow along the edges of the Voronoi graph). The underlying graph structure is great for simulating flows or relationships between regions. It provides a “good skeleton” for placing features [10]. Systems like Mapgen4 and Tectonics.js utilize this approach [4].\nDisadvantages: Computationally more expensive to generate and work with. Geometric operations (like finding neighbors or calculating distances/areas) are more complex than on a regular grid.\nThe choice of map geometry and tiling impacts everything downstream, from how noise is applied to how simulations like erosion or climate are run. A spherical Voronoi mesh arguably offers the highest potential for realism on a planetary scale, but simpler grids (flat or wrapped, square or hex) are often chosen for performance and ease of implementation.\nRaising the Land: Generating Continents and Oceans With a canvas defined, the next step is painting the broad strokes: where is land, and where is sea? How do continents form? Two main paradigms dominate: noise-based heightmaps and plate tectonics simulation.\nFractal Noise Heightmaps: The Quick and Dirty Approach The most common method is to use fractal noise (like fBm described earlier) to generate an elevation map or * heightmap*. This is typically a 2D grid where each cell stores an elevation value.\nGenerate Noise Use multiple octaves of Perlin or Simplex noise to create a heightfield $H(x, y)$. Low frequencies create broad continents/basins, high frequencies add detail.\nSet Sea Level Choose a threshold value. All points on the heightmap below this value become ocean; all points above become land. A common target is ~70% ocean, similar to Earth, which might correspond to picking the 30th percentile of height values as sea level [1].\nThis quickly produces a world with land and sea. However, pure noise has limitations:\nLack of Structure Real continents have long, linear mountain ranges, vast flat plains, and specific shapes dictated by geological history. Noise-based terrain tends to produce more random, blobby, or uniformly hilly landscapes. Mountain ranges don’t align meaningfully [1].\nIsland Problem Naively thresholding noise often results in worlds that are either mostly ocean with scattered small islands, or mostly land with scattered lakes, rather than a few large continents.\nTechniques to Improve Noise-Based Continents Shaping Functions Multiply the noise heightmap by another function (e.g., a radial gradient that lowers elevation near the edges of the map) to force oceans around a central landmass. WorldEngine uses a trick where they normalize the heightmap so the lowest point is at the border and highest is central, then flood from the edges to ensure a central continent [1].\nDomain Warping A clever technique popularized by Inigo Quilez and others. Instead of evaluating noise at (x, y), you evaluate it at coordinates that have been distorted by another noise function. For example: height = noise1(x + offset * noise2(x, y), y + offset * noise3(x, y)). This “warps” the coordinate space, creating swirling, folded, and branching patterns in the output noise [7]. Domain warping can produce features that look remarkably like eroded terrain – twisty ridges, river-like valleys – without actually simulating erosion [7]. It’s computationally cheap (just more noise lookups) and adds significant visual complexity, making basic noise terrain look much more interesting.\nDiamond-Square Algorithm A classic (though somewhat dated) fractal algorithm specifically for generating heightmaps. It works by recursively subdividing squares, setting corner points, then calculating midpoints with random offsets. It tends to produce characteristic square-aligned artifacts but is simple to implement.\nNoise provides the fundamental texture and detail, but for realistic structure, we often need to simulate the processes that build that structure.\nPlate Tectonics Simulation: Building Worlds Geologically On Earth, continents and mountains are formed by the slow dance of tectonic plates. Simulating this process can produce far more plausible large-scale world structures. While full geophysical simulation is complex, simplified models are feasible for world generation. Notable projects exploring this include WorldEngine, Tectonics.js, PyTectonics, and academic work like “Procedural Tectonic Planets” [1] [11] [12].\nA Simplified Tectonic Algorithm Initialize Plates Divide the world (represented as a grid or spherical mesh) into a number of distinct regions, representing tectonic plates (e.g., 6-20 plates). This can be done randomly (e.g., Voronoi partitioning) or based on initial noise patterns. Assign each plate an initial velocity (direction and speed).\nMove Plates Simulate the movement of each plate over a time step according to its velocity. On a sphere, this movement follows great circle paths.\nDetect Interactions Identify where plates are colliding (convergent boundary), pulling apart (divergent boundary), or sliding past each other (transform boundary).\nModify Terrain Convergence (Collision) Where plates collide, uplift the terrain significantly, forming mountain ranges. If one plate is denser (oceanic vs. continental), it might subduct (slide underneath), leading to uplift on the overriding plate and potentially volcanic activity or deep ocean trenches.\nDivergence (Rifting) Where plates pull apart, lower the terrain, creating rift valleys on land or mid-ocean ridges under the sea where new crust forms.\nTransform Minimal vertical change, but can create fault lines.\nIterate Repeat steps 2-4 for many simulated time steps (representing millions of years). Plate velocities might change, plates might merge or break apart.\nMore Sophisticated Models (e.g., Tectonics.js) Tectonics.js implements a more physics-inspired model on a spherical grid [11]:\nIt tracks crust properties like density and age. Oceanic crust becomes denser as it ages [11]. Dense oceanic crust tends to subduct under lighter continental or younger oceanic crust [11]. Plate velocities are calculated based on forces pulling plates towards subduction zones [11]. Plates are dynamically identified by grouping areas with similar velocities. At convergent boundaries, overlapping crust is effectively deleted (simulating subduction). At divergent boundaries, gaps are filled with new crust [11]. This leads to emergent, realistic features: long mountain chains, island arcs, spreading ocean basins [11]. The downside is computational cost – it’s not instantaneous [11]. Benefits of Tectonic Simulation Plausible Structure Generates continents, oceans, and mountain ranges with shapes and alignments that resemble real geology. Features that noise alone struggles with.\nInherent History The generated world has a “story.” You can trace why a mountain range exists (e.g., collision of plates X and Y). This is great for lore and deeper simulation [11] [13].\nEmergent Land/Sea Distribution The amount and shape of land isn’t predefined but emerges naturally from the simulation.\nHybrid Approaches Pure tectonic simulation can sometimes produce terrain that lacks fine detail or looks “bland” between the major features. Many systems, like WorldEngine, use a hybrid approach:\nStart with an initial heightmap generated by noise (providing base detail). Run a plate tectonics simulation to deform this heightmap, creating large-scale structures. Apply more noise afterward to add roughness and smaller features back in. [1]. This combination often yields the best results: realistic large-scale structure with natural-looking small-scale variation. After generating the basic landforms via noise, tectonics, or a hybrid, the next step is often to refine the terrain with processes that shape it over time.\nCarving the Details: Erosion and River Simulation A freshly generated heightmap, even one based on tectonics and noise, often looks too sharp, too uniform, too… computer-generated. Real landscapes are heavily sculpted by erosion – the relentless wearing away of rock and soil by water, wind, ice, and gravity. Simulating erosion is crucial for adding realism and creating features like river valleys, smooth hills, and depositional plains. As the WorldEngine developers state, “If you do not simulate erosion you will never obtain realistic maps.” [1].\nHydraulic Erosion (Water Power) This is the most significant type of erosion for shaping large landscapes. It involves water (rain, rivers) dislodging soil/rock particles, transporting them downhill, and depositing them where the water slows down. There are two main algorithmic approaches [14]:\nEulerian (Grid-Based) Treats water as a fluid layer covering the terrain grid. Each cell tracks water depth and sediment concentration. Water flows between cells based on height differences (pressure gradients), carrying sediment with it. Sediment is eroded from the ground where flow is high and deposited where it’s low. These models often use simplified versions of fluid dynamics equations (like the shallow water equations). They can capture large-scale effects but can be complex and computationally intensive.\nLagrangian (Particle-Based / “Rain Droplet” Model): Simulates the paths of individual water droplets. This is very popular in game development due to its conceptual simplicity and ability to create intricate channel networks. The basic idea:\nSpawn Droplet Create a “raindrop” particle at a random location on the heightmap with a small amount of water and initially no sediment.\nFlow Downhill Move the droplet in the direction of the steepest downhill slope, calculated from the heightmap gradient at its current position. Its velocity increases on steeper slopes.\nErode/Deposit The droplet’s capacity to carry sediment depends on factors like its water volume, velocity, and the slope it’s on.\nIf the droplet is moving fast/downhill (high capacity) and currently holds less sediment than its capacity, it erodes material from the ground, decreasing terrain height and increasing its sediment load. If the droplet slows down (e.g., on flatter ground, low capacity) and holds more sediment than it can carry, it deposits sediment, increasing terrain height and decreasing its load. A simple capacity model might be: capacity = k * velocity * slope [14]. The amount eroded or deposited is then proportional to the difference between capacity and current sediment load [14]. Evaporate The droplet gradually loses water over time/distance.\nTerminate The simulation for that droplet ends when it runs out of water, flows off the map, or gets stuck in a pit.\nRepeat Simulate thousands or millions of these droplets. Each path contributes incrementally to carving channels and building up depositional areas.\nHere’s the C++ pseudocode snippet (adapted from Article 1 and common implementations) illustrating the core loop for a single droplet:\n#include #include #include // For std::max, std::min // Assumes existence of a HeightMap class/struct // with methods like: // double getHeight(double x, double y); // Interpolated height // Vector2 getGradient(double x, double y); // Steepest downhill gradient vector // void addHeight(int gridX, int gridY, double delta); // Modify height at grid cell // int width(); int height(); struct HeightMap { /* ... definition ... */ }; struct Vector2 { double x, y; }; struct Droplet { double x, y; // Current position (continuous) double vx, vy; // Current velocity double water; // Amount of water remaining double sediment; // Amount of sediment carried }; // Simulation parameters (tune these!) const int maxSteps = 64; // Max lifetime of a droplet const double timeStep = 1.0; // Simulation step duration const double friction = 0.1; // Slows down velocity over time const double evaporationRate = 0.01; // Water lost per step const double erosionRate = 0.01; // How readily soil is eroded const double depositRate = 0.01; // How readily sediment is deposited const double sedimentCapacityFactor = 10.0; // Scales overall capacity const double minSlopeForErosion = 0.01; // Don't erode on near-flat ground const double minWater = 0.001; // Stop when droplet is too small void simulateDroplet(Droplet\u0026 d, HeightMap\u0026 H) { for (int step = 0; step \u003c maxSteps; ++step) { // Get current grid cell indices and interpolated position int gridX = static_cast\u003cint\u003e(d.x); int gridY = static_cast\u003cint\u003e(d.y); // Boundary check if (gridX \u003c 0 || gridX \u003e= H.width() - 1 || gridY \u003c 0 || gridY \u003e= H.height() - 1) { break; // Droplet flowed off map } // Calculate height and gradient at the droplet's interpolated position double currentHeight = H.getHeight(d.x, d.y); Vector2 gradient = H.getGradient(d.x, d.y); // Points downhill // Update velocity based on gradient (gravity) and friction d.vx = (d.vx * (1.0 - friction)) + gradient.x * timeStep; d.vy = (d.vy * (1.0 - friction)) + gradient.y * timeStep; // Store old position double oldX = d.x; double oldY = d.y; // Update position based on velocity d.x += d.vx * timeStep; d.y += d.vy * timeStep; // Boundary check again after move if (d.x \u003c 0 || d.x \u003e= H.width() - 1 || d.y \u003c 0 || d.y \u003e= H.height() - 1) { // Deposit remaining sediment at last valid position before leaving map H.addHeight(gridX, gridY, d.sediment); break; } // Calculate height difference between old and new position double newHeight = H.getHeight(d.x, d.y); double deltaHeight = currentHeight - newHeight; // Positive if moving downhill // Calculate sediment capacity // Capacity depends on water volume, speed, and slope (deltaHeight) // Simple model: capacity proportional to water * deltaHeight (steeper drop = more capacity) // Clamp deltaHeight to avoid negative capacity if moving uphill slightly double speed = std::sqrt(d.vx * d.vx + d.vy * d.vy); double capacity = std::max(0.0, deltaHeight) * d.water * sedimentCapacityFactor * speed; // Erode or deposit sediment at the *previous* cell (gridX, gridY) // This prevents digging holes directly under the droplet if (deltaHeight \u003e minSlopeForErosion) { // Only erode/deposit significantly if moving downhill double sedimentDiff = capacity - d.sediment; if (sedimentDiff \u003e 0) { // Can carry more: Erode double amountToErode = std::min(sedimentDiff * erosionRate, deltaHeight); // Don't erode more than available height diff amountToErode = std::min(amountToErode, H.getHeight(gridX + 0.5, gridY + 0.5) * 0.1); // Limit erosion based on current height too amountToErode = std::max(0.0, amountToErode); // Ensure non-negative H.addHeight(gridX, gridY, -amountToErode); // Remove from terrain d.sediment += amountToErode; // Add to droplet } else { // Carrying too much: Deposit double amountToDeposit = std::min(-sedimentDiff * depositRate, d.sediment); // Deposit difference, up to amount carried amountToDeposit = std::max(0.0, amountToDeposit); // Ensure non-negative H.addHeight(gridX, gridY, amountToDeposit); // Add to terrain d.sediment -= amountToDeposit; // Remove from droplet } } // Evaporate water d.water *= (1.0 - evaporationRate); if (d.water \u003c minWater) { // Deposit remaining sediment if droplet evaporates H.addHeight(gridX, gridY, d.sediment); break; } } } // --- In main() or simulation loop --- // HeightMap terrain = ...; // Initial heightmap // int numDroplets = 100000; // std::mt19937 rng(seed); // Random number generator // std::uniform_real_distribution distX(0.0, terrain.width() - 1.0); // std::uniform_real_distribution distY(0.0, terrain.height() - 1.0); // for (int i = 0; i \u003c numDroplets; ++i) { // Droplet drop = { // distX(rng), distY(rng), // Random start position // 0.0, 0.0, // Initial velocity // 1.0, // Initial water // 0.0 // Initial sediment // }; // simulateDroplet(drop, terrain); // } // --- Terrain now contains eroded features --- Performance Note: Simulating millions of droplets can be slow. Optimizations include:\nGPU acceleration (as researched by Mei et al. [1]). Simulating larger “streams” or using grid-based flow accumulation models instead of individual droplets. Thermal Erosion (Weathering / Mass Wasting) This simulates the effect of gravity causing material on steep slopes to crumble and slide downwards, accumulating at the base (forming talus slopes). It’s much simpler than hydraulic erosion.\nA common algorithm:\nIterate through each cell (x, y) of the heightmap. Compare its height H(x, y) to its neighbors H(nx, ny). For each neighbor lower than the current cell, calculate the height difference d = H(x, y) - H(nx, ny). If this difference d exceeds a threshold (representing the material’s “angle of repose” – the steepest angle it can maintain), then move some material from the higher cell (x, y) to the lower neighbor (nx, ny). The amount moved is typically proportional to the excess difference (d - threshold). For example, move c * (d - threshold) amount of height, where c is a small constant [15] [16]. Ensure total height is conserved (or approximately conserved) by distributing the removed height among all lower neighbors exceeding the threshold. Repeat this process for several iterations until the terrain stabilizes (no more slopes exceed the threshold significantly). Thermal erosion is computationally cheap and effective at smoothing out unnaturally sharp peaks and cliffs left by noise generation or tectonic uplift, giving mountains a more weathered look. It’s often applied as a final smoothing pass.\nRiver Network Generation and Watersheds While hydraulic erosion creates river channels, sometimes you want to explicitly define major rivers for gameplay or ensure a realistic drainage network exists.\nFlow Accumulation Analysis: A standard GIS technique adaptable for games.\nFor each cell, determine its flow direction – which neighbor is steepest downhill? Calculate flow accumulation for each cell: how many upstream cells eventually drain through this cell? This is often done recursively or iteratively, passing flow counts downstream. Cells with a high flow accumulation value represent potential river paths. Define a threshold – cells above it are part of a river network. This naturally creates branching tributary systems flowing from highlands to lowlands or oceans. Explicit River Carving Start potential rivers at high points (e.g., mountain springs, areas of high simulated rainfall). Simulate the river flowing downhill, actively lowering the terrain height along its path to “carve” a valley. Rules are needed to handle hitting flat areas (meander) or depressions (form lakes). Amit Patel’s Mapgen4 allows users to draw rivers, and the system then carves them into the terrain [17].\nSimulation-Driven Rivers In systems like WorldEngine, rivers emerge more directly from the coupled simulation. After calculating precipitation and running erosion, they explicitly trace water flow paths from source to sea, calculate water volume in each segment, and designate tiles with significant flow as rivers [1].\nWatersheds The flow direction map also allows identifying watersheds (or drainage basins) – the area of land that drains into a particular river or outlet point. These watersheds, separated by ridges (drainage divides), form natural geographical regions often useful for defining political borders, biome zones, or AI territories.\nIn summary, erosion and river simulation transform a static heightmap into a landscape that feels shaped by natural forces over time. They carve the valleys, create the river networks, and deposit the fertile plains that make a world feel lived-in and geologically plausible. Even simplified erosion or faked effects like domain warping can add significant realism compared to raw noise terrain.\nBreathing Life into the World: Climate, Weather, and Biomes We have land, water, mountains, and rivers. But what makes a desert different from a jungle, or a tundra from a temperate forest? Climate. Simulating climate patterns – temperature, precipitation, wind – allows us to determine which biomes (ecological regions) should exist where.\nSimulating Climate Full global climate modeling (GCM) like that used by climate scientists is computationally prohibitive for most game world generation. Instead, simplified, heuristic models are used to capture the most important factors influencing climate:\nLatitude The primary driver of temperature. Closer to the equator = more direct sunlight = warmer. Temperature generally decreases towards the poles. A simple model might be Temp = BaseTemp - TempDrop * abs(latitude) or using a sine function.\nAltitude Temperature decreases with height (the lapse rate, roughly 6.5°C per 1000m). Mountains are colder than lowlands at the same latitude.\nLand vs. Water Water heats and cools more slowly than land. Coastal areas tend to have more moderate temperatures (less seasonal variation) than continental interiors (continentality). Large bodies of water also act as moisture sources.\nPrevailing Winds Global atmospheric circulation creates dominant wind patterns (e.g., easterly trade winds in the tropics, westerlies in mid-latitudes). Winds transport moisture from oceans over land.\nOcean Currents (Advanced) Warm currents (like the Gulf Stream) can significantly warm coastal regions; cold currents can cool them. Simulating these adds realism but is often skipped in simpler models.\nOrographic Precipitation (Rain Shadows) This is crucial! When moist air carried by wind hits a mountain range, it’s forced upwards. As it rises, it cools, and its capacity to hold moisture decreases. This causes rain or snow to fall on the windward side of the mountains. The air that descends on the leeward side is now dry, creating a rain shadow – an area of low precipitation (often deserts or steppes) [18]. Any plausible climate simulation must account for this effect.\nSimplified Climate Modeling Approach Temperature Map Calculate base temperature based on latitude. Adjust for altitude using the lapse rate. Optionally, add modifications for distance from coast (continentality).\nPrevailing Winds Define basic wind directions for different latitude bands (e.g., West in mid-latitudes, East in tropics).\nMoisture \u0026 Precipitation Simulate moisture transport. A simple way (used in Mapgen4) is to process cells in order along the wind direction [18]. Start with moisture over oceans (evaporation). As air moves over land, it might pick up some moisture (less than ocean) or gradually lose it. When air hits mountains (rising elevation along wind path), reduce its moisture-holding capacity. If capacity drops below current moisture, the excess falls as rain/snow on the windward slope [18]. The air passed to the leeward side is now drier. Incorporate general global patterns (e.g., high rainfall near the equator - ITCZ, dry zones around 30° latitude). Output Generate maps of average annual temperature and average annual precipitation.\nWorldEngine uses a simplified approach: Temperature from latitude/altitude, Precipitation from temperature plus noise, with specific erosion/flow steps calculating river discharge and humidity [1]. They explicitly chose not to simulate seasons to keep complexity manageable, focusing on annual averages [1].\nFor higher fidelity (perhaps for sci-fi games aiming for realism), tools like ExoPlaSim exist. It’s a simplified but physically based 3D global climate model that can simulate atmospheric circulation, heat transport, and precipitation for planets with different parameters (rotation, atmosphere, star type) [19] [20]. Running such a model is more intensive but yields highly realistic climate patterns.\nAssigning Biomes Once you have temperature and precipitation maps, you can classify different regions into biomes. Biomes represent major ecological communities characterized by dominant plant types and adapted to the prevailing climate (e.g., Tropical Rainforest, Temperate Grassland, Arctic Tundra, Subtropical Desert).\nBiome Classification Schemes The simplest way is to use a lookup diagram based on temperature and precipitation.\nWhittaker Biome Diagram A classic ecological chart plotting average annual temperature vs. average annual precipitation, dividing the space into major biome types.\nHoldridge Life Zones A more detailed system used by WorldEngine. It considers temperature, precipitation, and also potential evapotranspiration (related to energy availability) to define a finer set of life zones (~38 zones) [1]. WorldEngine implemented around 40 specific biomes based on this, from “Subpolar Dry Tundra” to “Tropical Rainforest” [1].\nAlgorithm For each land cell on your map, get its calculated temperature and precipitation values. Use the chosen classification scheme (Whittaker, Holdridge, or a custom one) to determine the corresponding biome type. Assign the biome type to the cell. (Optional) Apply smoothing or filtering: A single desert tile in the middle of a rainforest might be a noise artifact. You could use a majority filter or smooth biome boundaries to make transitions look more natural. Adding Nuance More advanced systems might consider:\nSoil Moisture/Drainage A flat, wet area might become a swamp or marsh, even if the temperature/precipitation alone suggest forest. WorldEngine simulates water flow and permeability to identify potentially marshy areas [1].\nSeasonality If seasons were simulated, the variation in temperature and precipitation could influence biomes (e.g., differentiating deciduous from coniferous forests).\nSoil Type/Fertility This could emerge from erosion simulation (sediment deposition = fertile) and influence vegetation density or type.\nBiome generation is often the final step in creating the environmental backdrop. It gives the world its visual character and dictates the types of resources, flora, and fauna players might encounter. The beauty is seeing how the underlying geology (tectonics creating mountains) influences climate (rain shadows) which in turn dictates the biomes (deserts behind mountains).\nUnder the Hood: Map Data Structures How is all this complex world information actually stored in memory or on disk? The choice of data structure impacts performance, flexibility, and the types of simulations that are easy to implement.\nRegular Grids (Raster Data) The most common approach, especially for heightmaps. Use 2D arrays (or 3D for voxels like Minecraft) to store values ( elevation, temperature, biome ID, etc.) for each cell.\nPros: Simple addressing (map[row][col]), efficient neighborhood lookups (crucial for erosion, smoothing, cellular automata), aligns well with texture mapping for rendering. Cons: Can be memory-intensive for large, high-resolution maps. Represents discrete steps, less natural for smooth features (though interpolation helps). Spherical representation using grids suffers from distortion (equirectangular) or edge seams (cube map). Hex grids require special coordinate mapping onto the 2D array. Graph-Based Representations (Irregular Meshes) Store the world as a network of nodes and edges, often based on Voronoi diagrams or Delaunay triangulations.\nNodes (e.g., Voronoi cell centers) store properties (elevation, biome). Edges represent adjacency and can store information like flow rates (for rivers) or boundary types. Red Blob Games’ Polygon Map Generation tutorials detail storing data at corners, edges, and centers of the Voronoi polygons for different purposes [10]. Pros Excellent for representing irregular, natural boundaries. Flexible resolution possible. Good for pathfinding or flow simulations along graph edges.\nCons More complex data structures. Neighborhood operations can be slower/more complex than grid lookups. Physics simulations (like fluid dynamics) are harder to implement on irregular meshes.\nSpherical Subdivisions (DGGS) For true global representation, use specialized structures like icosahedral geodesic grids (hex/pent meshes) or other Discrete Global Grid Systems (DGGS). These aim for near-uniform cell size/shape across the sphere with no singularities.\nPros Best for accurate global simulations (climate, tectonics). Minimal distortion.\nCons Complex implementation, especially handling neighbor relationships and coordinates across the sphere.\nMulti-Layer Data A generated world isn’t just a heightmap. It’s a collection of related data layers. A practical system often stores multiple aligned grids or graphs:\nElevation map Water map (ocean/lake depth, river paths/flow) Temperature map Precipitation map Biome map Tectonic plate ID map Vegetation density map, etc. WorldEngine, for example, explicitly stores many such layers per tile [1]. This allows different systems (rendering, AI, gameplay logic) to access the specific information they need. It also allows exporting different map views (like a climate map or political map).\nImplicit/Functional Representation For truly infinite or extremely detailed worlds, storing everything explicitly is impossible. Instead, use functions ( like noise functions) to calculate terrain properties on demand at any given coordinate (x, y, z). Games like No Man’s Sky rely heavily on generating planet surfaces locally from mathematical formulas as the player approaches, rather than storing the entire planet’s geometry.\nThe ideal data structure depends on the scale of the world, the required level of detail, the types of simulations being run, and performance constraints. Many systems use a combination – perhaps a coarse graph for global structure and finer grids for local detail.\nLearning from the Masters: Quick Case Studies Let’s briefly look at how some notable projects and games combine these techniques:\nWorldEngine (Open Source Generator) A prime example of a full pipeline [1]. Its steps roughly follow our discussion:\nInitial heightmap (Simplex noise). Plate tectonics simulation (deforms heightmap, creates mountains). Flooding to set sea level. Climate simulation (temperature based on latitude/altitude, precipitation based on temp + noise). Hydraulic erosion (droplet model, carving rivers). Hydrology (calculating river flow, humidity). Biome assignment (Holdridge life zones). It emphasizes the synergy: noise for detail, tectonics for structure, erosion for realism. It outputs multiple data layers exportable to game engines or GIS tools. Mapgen4 (Red Blob Games - Web Tool) Focuses on interactive fantasy map generation [17]. Uses a Voronoi graph structure. Key features:\nFast, interactive updates (user paints features, map regenerates). Achieved via optimized data structures (e.g., spatial partitioning for rivers) and possibly multithreading. Simplified climate simulation (wind, orographic rain) driving river formation and biomes. Height calculation uses distance fields for smooth blending of user-painted mountains. Stylized rendering to look like hand-drawn maps. It shows how core concepts can be implemented efficiently even in a web browser for interactive use. Tectonics.js / PyTectonics (Carl Davidson et al.) Focuses specifically on high-fidelity plate tectonics simulation on a sphere [11]. Uses spherical Voronoi meshes and simulates crust properties, subduction, and velocity fields based on physical principles. Produces very realistic continental configurations but is computationally intensive. Often used as a starting point – generate the tectonic base map, then use other tools for erosion and detailing.\nDwarf Fortress (Bay 12 Games) Famous for its incredibly deep simulation. World generation involves:\nGenerating a base fractal heightmap. Simulating geology (mineral distribution). Simulating rainfall, drainage, rivers, and lakes. Simulating temperature and biomes. Crucially, simulating thousands of years of history: rise and fall of civilizations, wars, mythical beasts, heroes – all leaving traces on the world and creating rich, unique lore tied to the generated geography [1]. It highlights how procedural generation can extend far beyond just terrain into history and culture. Minecraft (Mojang Studios) Uses chunk-based generation on a conceptually infinite plane. Core terrain uses layered 3D Perlin/Simplex noise. Biomes influence terrain height variation, decorations (trees, structures), and block types. Features like caves, ravines, and ore veins are added using separate procedural algorithms within each chunk. Focuses on exploration and emergence from relatively simple block-based rules.\nNo Man’s Sky (Hello Games) Generates an entire galaxy of planets using deterministic procedural formulas from a single seed. Planet surfaces are generated on the fly using noise functions and other algorithms as the player approaches. Emphasizes scale, variety, and seamless exploration from space to ground.\nThese examples show there’s no single “right” way. The best approach depends on the game’s goals: deep simulation vs. fast interaction, realism vs. stylized appearance, planetary scale vs. local detail. Often, the most successful systems are hybrids, carefully combining noise, simulation, and heuristics.\nPeeking into the Future: Where World Generation is Headed The field is constantly evolving. Here are some exciting directions and possibilities:\nTighter Integration \u0026 Coupling Simulating feedback loops. How does massive erosion affect tectonic uplift over millions of years? How does climate change (e.g., an ice age simulated historically) impact erosion rates and biome distribution? Current systems often run steps sequentially; future ones might have more interplay.\nMore Sophisticated Simulation Incorporating more physics: advanced fluid dynamics for erosion and rivers, better atmospheric modeling for climate ( including seasons, dynamic weather), simulation of volcanism (hotspots like Hawaii), ecological succession modeling (how biomes evolve and compete over time).\nAI and Machine Learning Generative Models: Training AI (like GANs or diffusion models) on real-world terrain or climate data to produce plausible fictional outputs (e.g., “generate a landscape in the style of the Scottish Highlands”).\nParameter Tuning Using ML to automatically find generation parameters that produce worlds meeting specific design criteria (e.g., “a world with 3 continents, mostly temperate forests, and navigable rivers”).\nSmart Content Placement AI could learn plausible locations for resources, settlements, or points of interest based on the generated environment.\nReal-Time \u0026 Interactive Generation Moving beyond pre-computation. Imagine worlds that visibly evolve based on player actions (e.g., a magical cataclysm triggers tectonic shifts, large-scale engineering projects alter river flows and climate). This requires highly efficient, incremental algorithms. Cortial et al.’s “Procedural Tectonic Planets” explored interactive design using tectonics [12].\nBridging Scales (Procedural Zoom) Seamlessly connecting large-scale planetary generation with fine-grained local detail. Generate the planet coarsely, then use different, higher-frequency procedural techniques (or even rule-based systems) to add detail dynamically as the player zooms in or moves closer, ensuring consistency across scales.\nHistory and Culture Simulation Expanding on the Dwarf Fortress model. Tightly integrating the generation of civilizations, historical events, ruins, and lore with the physical world generation, so the environment shapes the history, and the history leaves visible marks on the environment.\nUnified \u0026 Modular Frameworks Creating flexible pipelines where developers can easily swap different modules (e.g., choose between fast fake erosion or slow physical simulation, plug in different climate models) based on project needs. The framework passes world data layers between modules.\nThe ultimate goal? To generate worlds that feel not just visually plausible but alive, with depth, history, and internal consistency – worlds that tell stories through their very landscapes.\nConclusion: The Art and Science of WorldSmithing Procedural world generation is a captivating blend of art and science. It draws on mathematical noise, geological simulation, climate science, and ecological principles, all orchestrated by algorithms to conjure digital universes from little more than a seed value.\nWe’ve journeyed from the basic concepts of noise and seeds through the intricacies of shaping continents with tectonics, carving details with erosion, breathing life with climate and biomes, and storing it all efficiently. We’ve seen that the most compelling results often come from a synthesis of techniques: the raw detail of noise, the structural foundation of simulation, and the refining touch of processes like erosion.\nThe tools and algorithms are becoming increasingly sophisticated, allowing even small teams or solo developers to create worlds of staggering scale and complexity. While challenges remain in achieving perfect realism, controllability, and performance, the future points towards even more powerful and integrated systems, potentially leveraging AI and real-time dynamics.\nUltimately, procedural generation empowers creators not just to build worlds, but to become digital worldsmiths, crafting universes that surprise, delight, and immerse players in ways previously unimaginable. By understanding the algorithms and harnessing the processes that shape our own planet, we unlock the potential to create countless others, each waiting to be explored.\nReferences [1] F. Tomassetti, ‘Diving Into Procedural Content Generation, With WorldEngine’, Smashing Magazine. [Online]. Available: https://www.smashingmagazine.com/2016/03/procedural-content-generation-introduction/ [2] ‘Perlin noise’, Wikipedia. [Online]. Available: https://en.wikipedia.org/wiki/Perlin_noise [3] ‘Simplex noise’, Wikipedia. [Online]. Available: https://en.wikipedia.org/wiki/Simplex_noise [4] A. J. Patel, ‘Procedural map generation on a sphere’, Red Blob Games. [Online]. Available: https://www.redblobgames.com/x/1843-planet-generation/ [5] ‘Value noise’, Wikipedia. May 21, 2021. [Online]. Available: https://en.wikipedia.org/w/index.php?title=Value_noise\u0026oldid=1024311499 [6] ‘Brownian surface’, Wikipedia. Oct. 16, 2024. [Online]. Available: https://en.wikipedia.org/w/index.php?title=Brownian_surface\u0026oldid=1251552796 [7] F. Gennari, ‘3DWorld: Domain Warping Noise’, 3DWorld. [Online]. Available: https://3dworldgen.blogspot.com/2017/05/domain-warping-noise.html [8] A. J. Patel, ‘Wraparound hexagon tile maps on a sphere’, Red Blob Games. [Online]. Available: https://www.redblobgames.com/x/1640-hexagon-tiling-of-sphere/ [9] A. J. Patel, ‘Hexagonal Grids’, Red Blob Games, 2013. [Online]. Available: https://www.redblobgames.com/grids/hexagons/ [10] A. J. Patel, ‘Polygonal Map Generation, HTML5 version’, Red Blob Games. [Online]. Available: https://simblob.blogspot.com/2017/09/mapgen2-html5.html [11] C. Davidson, ‘Tectonics.js: 3D Plate Tectonics in your web browser’. [Online]. Available: https://davidson16807.github.io/tectonics.js/blog/ [12] Y. Cortial, A. Peytavie, E. Galin, and E. Guérin, ‘Procedural Tectonic Planets’, Computer Graphics Forum, vol. 38, no. 2, pp. 1–11, May 2019, doi: 10.1111/cgf.13614. [13] ‘Unless it’s modeling islands, I find most terrain generators unnatural, at least…’, Hacker News. [Online]. Available: https://news.ycombinator.com/item?id=14794095 [14] M. Mujtaba, ‘Simulating Hydraulic Erosion of Terrain’, gameidea. [Online]. Available: https://gameidea.org/2023/12/22/simulating-hydraulic-erosion-of-terrain/ [15] A. Paris, ‘Terrain Erosion on the GPU’, Make it Shaded. [Online]. Available: https://makeitshaded.github.io/terrain-erosion/ [16] B. Benes and R. Forsbach, ‘Layered data representation for visual simulation of terrain erosion’, in Proceedings Spring Conference on Computer Graphics, IEEE, 2001, pp. 80–86. [Online]. Available: https://ieeexplore.ieee.org/abstract/document/945341/ [17] A. J. Patel, mapgen4. (Apr. 2023). TypeScript. [Online]. Available: https://github.com/redblobgames/mapgen4 [18] A. J. Patel, ‘Mapgen4: rainfall’, Red Blob Games. [Online]. Available: https://simblob.blogspot.com/2018/09/mapgen4-rainfall.html [19] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. Fan, ‘Enabling new science with the ExoPlaSim 3D climate model’, Bulletin of the American Astronomical Society, vol. 53, no. 3, p. 1140, 2021. [20] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. L. Fan, ‘ExoPlaSim: Extending the planet simulator for exoplanets’, Monthly Notices of the Royal Astronomical Society, vol. 511, no. 3, pp. 3272–3303, 2022. [21] X. Mei, P. Decaudin, and B.-G. Hu, ‘Fast hydraulic erosion simulation and visualization on GPU’, in 15th Pacific Conference on Computer Graphics and Applications (PG’07), IEEE, 2007, pp. 47–56. Accessed: Mar. 30, 2025. [Online]. Available: https://ieeexplore.ieee.org/abstract/document/4392715/ [22] K. F. Fraedrich, H. Jansen, E. Kirk, U. Luksch, and F. Lunkeit, ‘The Planet Simulator: Towards a user friendly model’, Meteorologische Zeitschrift, vol. 14, no. 3, pp. 299–304, 2005. [23] J. Olsen, ‘Realtime procedural terrain generation’, 2004, Accessed: Mar. 30, 2025. [Online]. Available: https://citeseerx.ist.psu.edu/document?repid=rep1\u0026type=pdf\u0026doi=5961c577478f21707dad53905362e0ec4e6ec644 [24] L. Viitanen, ‘Physically based terrain generation: Procedural heightmap generation using plate tectonics’, 2012, Accessed: Mar. 30, 2025. [Online]. Available: https://www.theseus.fi/bitstream/handle/10024/40422/Viitanen_Lauri_2012_03_30.pdf [25] G. Cordonnier et al., ‘Large Scale Terrain Generation from Tectonic Uplift and Fluvial Erosion’, Computer Graphics Forum, vol. 35, no. 2, pp. 165–175, May 2016, doi: 10.1111/cgf.12820. ","wordCount":"8249","inLanguage":"en","datePublished":"2025-03-28T19:04:14+08:00","dateModified":"2025-03-28T19:04:14+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building New Worlds: A Deep Dive into Procedural Generation for Video Games</h1><div class=post-meta><span title='2025-03-28 19:04:14 +0800 +0800'>March 28, 2025</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;8249 words&nbsp;·&nbsp;Tategoto Azarasi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#the-building-blocks-fundamentals-of-procedural-world-generation>The Building Blocks: Fundamentals of Procedural World Generation</a><ol><li><a href=#the-seed-of-creation>The Seed of Creation</a></li><li><a href=#why-go-procedural>Why Go Procedural?</a><ol><li><a href=#content-variety--replayability>Content Variety & Replayability</a></li><li><a href=#development-efficiency--scalability>Development Efficiency & Scalability</a></li><li><a href=#reduced-storagedownload-size>Reduced Storage/Download Size</a></li><li><a href=#emergent-possibilities>Emergent Possibilities</a></li></ol></li><li><a href=#the-challenges>The Challenges</a><ol><li><a href=#coherence-and-quality>Coherence and Quality</a></li><li><a href=#avoiding-repetition>Avoiding Repetition</a></li><li><a href=#artistic-control>Artistic Control</a></li><li><a href=#debugging>Debugging</a></li></ol></li><li><a href=#noise-the-canvas-of-creation>Noise: The Canvas of Creation</a><ol><li><a href=#perlin-noise>Perlin Noise</a></li><li><a href=#simplex-noise>Simplex Noise</a></li><li><a href=#value-noise>Value Noise</a></li><li><a href=#fractional-brownian-motion-fbm--fractal-noise>Fractional Brownian Motion (fBm) / Fractal Noise</a><ol><li><a href=#persistence>Persistence</a></li><li><a href=#lacunarity>Lacunarity</a></li></ol></li></ol></li></ol></li><li><a href=#shaping-the-canvas-map-geometry-and-representation>Shaping the Canvas: Map Geometry and Representation</a><ol><li><a href=#flat-maps-planar-worlds>Flat Maps (Planar Worlds)</a><ol><li><a href=#infinite-continuous-planes>Infinite Continuous Planes</a></li><li><a href=#bounded-planes>Bounded Planes</a></li><li><a href=#wrapped-planes-toroidal-worlds>Wrapped Planes (Toroidal Worlds)</a></li></ol></li><li><a href=#spherical-maps-planetary-worlds>Spherical Maps (Planetary Worlds)</a><ol><li><a href=#challenges>Challenges</a></li><li><a href=#common-solutions>Common Solutions</a><ol><li><a href=#cube-mapping>Cube Mapping</a></li><li><a href=#icosahedral-subdivision-geodesic-grids>Icosahedral Subdivision (Geodesic Grids)</a></li><li><a href=#fibonacci-lattice--spiral-points>Fibonacci Lattice / Spiral Points</a></li></ol></li></ol></li><li><a href=#tiling-schemes-squares-vs-hexes-vs-irregular>Tiling Schemes: Squares vs. Hexes vs. Irregular</a><ol><li><a href=#square-tiles>Square Tiles</a></li><li><a href=#hexagonal-tiles>Hexagonal Tiles</a><ol><li><a href=#uniform-adjacency>Uniform Adjacency</a></li><li><a href=#connectivity>Connectivity</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#irregular-polygons-voronoigraph-based>Irregular Polygons (Voronoi/Graph-Based)</a><ol><li><a href=#advantages>Advantages</a></li><li><a href=#disadvantages>Disadvantages:</a></li></ol></li></ol></li></ol></li></ol></li><li><a href=#raising-the-land-generating-continents-and-oceans>Raising the Land: Generating Continents and Oceans</a><ol><li><a href=#fractal-noise-heightmaps-the-quick-and-dirty-approach>Fractal Noise Heightmaps: The Quick and Dirty Approach</a><ol><li><a href=#generate-noise>Generate Noise</a></li><li><a href=#set-sea-level>Set Sea Level</a></li><li><a href=#lack-of-structure>Lack of Structure</a></li><li><a href=#island-problem>Island Problem</a></li><li><a href=#techniques-to-improve-noise-based-continents>Techniques to Improve Noise-Based Continents</a><ol><li><a href=#shaping-functions>Shaping Functions</a></li><li><a href=#domain-warping>Domain Warping</a></li><li><a href=#diamond-square-algorithm>Diamond-Square Algorithm</a></li></ol></li></ol></li><li><a href=#plate-tectonics-simulation-building-worlds-geologically>Plate Tectonics Simulation: Building Worlds Geologically</a><ol><li><a href=#a-simplified-tectonic-algorithm>A Simplified Tectonic Algorithm</a><ol><li><a href=#initialize-plates>Initialize Plates</a></li><li><a href=#move-plates>Move Plates</a></li><li><a href=#detect-interactions>Detect Interactions</a></li><li><a href=#modify-terrain>Modify Terrain</a><ol><li><a href=#convergence-collision>Convergence (Collision)</a></li><li><a href=#divergence-rifting>Divergence (Rifting)</a></li><li><a href=#transform>Transform</a></li></ol></li><li><a href=#iterate>Iterate</a></li></ol></li><li><a href=#more-sophisticated-models-eg-tectonicsjs>More Sophisticated Models (e.g., Tectonics.js)</a></li><li><a href=#benefits-of-tectonic-simulation>Benefits of Tectonic Simulation</a><ol><li><a href=#plausible-structure>Plausible Structure</a></li><li><a href=#inherent-history>Inherent History</a></li><li><a href=#emergent-landsea-distribution>Emergent Land/Sea Distribution</a></li></ol></li><li><a href=#hybrid-approaches>Hybrid Approaches</a></li></ol></li></ol></li><li><a href=#carving-the-details-erosion-and-river-simulation>Carving the Details: Erosion and River Simulation</a><ol><li><a href=#hydraulic-erosion-water-power>Hydraulic Erosion (Water Power)</a><ol><li><a href=#eulerian-grid-based>Eulerian (Grid-Based)</a></li><li><a href=#lagrangian-particle-based--rain-droplet-model>Lagrangian (Particle-Based / &ldquo;Rain Droplet&rdquo; Model):</a><ol><li><a href=#spawn-droplet>Spawn Droplet</a></li><li><a href=#flow-downhill>Flow Downhill</a></li><li><a href=#erodedeposit>Erode/Deposit</a></li><li><a href=#evaporate>Evaporate</a></li><li><a href=#terminate>Terminate</a></li><li><a href=#repeat>Repeat</a></li></ol></li></ol></li><li><a href=#thermal-erosion-weathering--mass-wasting>Thermal Erosion (Weathering / Mass Wasting)</a></li><li><a href=#river-network-generation-and-watersheds>River Network Generation and Watersheds</a><ol><li><a href=#flow-accumulation-analysis>Flow Accumulation Analysis:</a></li><li><a href=#explicit-river-carving>Explicit River Carving</a></li><li><a href=#simulation-driven-rivers>Simulation-Driven Rivers</a></li><li><a href=#watersheds>Watersheds</a></li></ol></li></ol></li><li><a href=#breathing-life-into-the-world-climate-weather-and-biomes>Breathing Life into the World: Climate, Weather, and Biomes</a><ol><li><a href=#simulating-climate>Simulating Climate</a><ol><li><a href=#latitude>Latitude</a></li><li><a href=#altitude>Altitude</a></li><li><a href=#land-vs-water>Land vs. Water</a></li><li><a href=#prevailing-winds>Prevailing Winds</a></li><li><a href=#ocean-currents-advanced>Ocean Currents (Advanced)</a></li><li><a href=#orographic-precipitation-rain-shadows>Orographic Precipitation (Rain Shadows)</a></li><li><a href=#simplified-climate-modeling-approach>Simplified Climate Modeling Approach</a><ol><li><a href=#temperature-map>Temperature Map</a></li><li><a href=#prevailing-winds-1>Prevailing Winds</a></li></ol></li><li><a href=#moisture--precipitation>Moisture & Precipitation</a></li><li><a href=#output>Output</a></li></ol></li><li><a href=#assigning-biomes>Assigning Biomes</a><ol><li><a href=#biome-classification-schemes>Biome Classification Schemes</a><ol><li><a href=#whittaker-biome-diagram>Whittaker Biome Diagram</a></li><li><a href=#holdridge-life-zones>Holdridge Life Zones</a></li></ol></li><li><a href=#algorithm>Algorithm</a></li><li><a href=#adding-nuance>Adding Nuance</a><ol><li><a href=#soil-moisturedrainage>Soil Moisture/Drainage</a></li><li><a href=#seasonality>Seasonality</a></li><li><a href=#soil-typefertility>Soil Type/Fertility</a></li></ol></li></ol></li></ol></li><li><a href=#under-the-hood-map-data-structures>Under the Hood: Map Data Structures</a><ol><li><a href=#regular-grids-raster-data>Regular Grids (Raster Data)</a></li><li><a href=#graph-based-representations-irregular-meshes>Graph-Based Representations (Irregular Meshes)</a><ol><li><a href=#pros>Pros</a></li><li><a href=#cons>Cons</a></li></ol></li><li><a href=#spherical-subdivisions-dggs>Spherical Subdivisions (DGGS)</a><ol><li><a href=#pros-1>Pros</a></li><li><a href=#cons-1>Cons</a></li></ol></li><li><a href=#multi-layer-data>Multi-Layer Data</a></li><li><a href=#implicitfunctional-representation>Implicit/Functional Representation</a></li></ol></li><li><a href=#learning-from-the-masters-quick-case-studies>Learning from the Masters: Quick Case Studies</a><ol><li><a href=#worldengine-open-source-generator>WorldEngine (Open Source Generator)</a></li><li><a href=#mapgen4-red-blob-games---web-tool>Mapgen4 (Red Blob Games - Web Tool)</a></li><li><a href=#tectonicsjs--pytectonics-carl-davidson-et-al>Tectonics.js / PyTectonics (Carl Davidson et al.)</a></li><li><a href=#dwarf-fortress-bay-12-games>Dwarf Fortress (Bay 12 Games)</a></li><li><a href=#minecraft-mojang-studios>Minecraft (Mojang Studios)</a></li><li><a href=#no-mans-sky-hello-games>No Man&rsquo;s Sky (Hello Games)</a></li></ol></li><li><a href=#peeking-into-the-future-where-world-generation-is-headed>Peeking into the Future: Where World Generation is Headed</a><ol><li><a href=#tighter-integration--coupling>Tighter Integration & Coupling</a></li><li><a href=#more-sophisticated-simulation>More Sophisticated Simulation</a></li><li><a href=#ai-and-machine-learning>AI and Machine Learning</a><ol><li><a href=#generative-models>Generative Models:</a></li><li><a href=#parameter-tuning>Parameter Tuning</a></li><li><a href=#smart-content-placement>Smart Content Placement</a></li></ol></li><li><a href=#real-time--interactive-generation>Real-Time & Interactive Generation</a></li><li><a href=#bridging-scales-procedural-zoom>Bridging Scales (Procedural Zoom)</a></li><li><a href=#history-and-culture-simulation>History and Culture Simulation</a></li><li><a href=#unified--modular-frameworks>Unified & Modular Frameworks</a></li></ol></li><li><a href=#conclusion-the-art-and-science-of-worldsmithing>Conclusion: The Art and Science of WorldSmithing</a></li><li><a href=#references>References</a></li></ol></nav></div></details></div><div class=post-content><p>Ever stepped into a vast, sprawling game world and wondered, &ldquo;How did they <em>build</em> all this?&rdquo; From the infinite blocky
landscapes of <em>Minecraft</em> to the galaxy-spanning planets of <em>No Man&rsquo;s Sky</em> or the intricate simulated histories of
<em>Dwarf Fortress</em>, the answer often lies in a fascinating field: <strong>Procedural Content Generation (PCG)</strong>.</p><p>Instead of hand-crafting every mountain, river, and cave, developers use algorithms – sets of rules and instructions –
to generate game content automatically. This isn&rsquo;t just about saving time (though it certainly helps!); it&rsquo;s about
creating experiences that feel boundless, unique, and endlessly replayable. Imagine exploring a world that&rsquo;s different
every single time you start a new game, a world generated just for you, with its own unique geography, climate, and
maybe even history. That&rsquo;s the power and allure of PCG.</p><p>This post is a deep dive into the technologies, algorithms, and methods used to generate these fictional worlds,
focusing primarily on the large-scale environmental aspects: the maps, the terrain, the climate, and the biomes that
bring these virtual places to life. We&rsquo;ll cover:</p><ul><li><strong>The Fundamentals:</strong> What PCG is, the magic of seeds, and the crucial role of noise functions (Perlin, Simplex, and
friends).</li><li><strong>Shaping the World:</strong> Different map geometries (flat vs. spherical) and tiling systems (squares, hexes, irregular
shapes).</li><li><strong>Raising the Land:</strong> Techniques for creating continents and oceans, from simple noise heightmaps to sophisticated
plate tectonics simulations.</li><li><strong>Carving the Details:</strong> How erosion (water and thermal) and river systems turn basic terrain into believable
landscapes.</li><li><strong>Breathing Life into It:</strong> Simulating climate (temperature, rainfall, wind) and distributing biomes (deserts,
forests, tundras).</li><li><strong>Under the Hood:</strong> The data structures used to represent these complex worlds.</li><li><strong>Learning from the Masters:</strong> Quick looks at how systems like WorldEngine, Mapgen4, and Tectonics.js put these ideas
into practice.</li><li><strong>Code Corner:</strong> Practical C++ snippets illustrating core concepts like noise and erosion.</li><li><strong>The Horizon:</strong> Where world generation might be heading next.</li></ul><p>Whether you&rsquo;re a seasoned game developer, an aspiring world-builder, or just curious about the magic behind your
favorite games, grab a virtual pickaxe, and let&rsquo;s dig in!</p><h2 id=the-building-blocks-fundamentals-of-procedural-world-generation>The Building Blocks: Fundamentals of Procedural World Generation<a hidden class=anchor aria-hidden=true href=#the-building-blocks-fundamentals-of-procedural-world-generation>#</a></h2><p>At its heart, procedural generation is about using algorithms to create content instead of manually authoring every
detail. Think of it like giving the computer a recipe rather than a finished cake. The recipe (the algorithm) defines
the steps, and the computer follows them to bake a unique cake (the game world) each time, potentially with slight
variations based on the ingredients (parameters and randomness).</p><h3 id=the-seed-of-creation>The Seed of Creation<a hidden class=anchor aria-hidden=true href=#the-seed-of-creation>#</a></h3><p>A key concept is the <strong>seed</strong>. Most procedural generation relies on pseudorandom number generators (PRNGs). These
algorithms produce sequences of numbers that <em>appear</em> random but are actually deterministic. If you start a PRNG with
the same initial value, called the <em>seed</em>, it will always produce the exact same sequence of numbers.</p><p>In game development, this is incredibly powerful. You can generate a massive, complex world using algorithms driven by a
PRNG. Instead of storing gigabytes of map data, you just need to store the generation algorithms and a single seed
number (often just a 32-bit or 64-bit integer). When a player wants to play that specific world again or share it with a
friend, they just need the seed. This is how games like <em>Minecraft</em> allow players to share specific world layouts [1].</p><h3 id=why-go-procedural>Why Go Procedural?<a hidden class=anchor aria-hidden=true href=#why-go-procedural>#</a></h3><p>The benefits are compelling:</p><h4 id=content-variety--replayability>Content Variety & Replayability<a hidden class=anchor aria-hidden=true href=#content-variety--replayability>#</a></h4><p>Generate near-infinite unique worlds, levels, or items, keeping the experience fresh [1].</p><h4 id=development-efficiency--scalability>Development Efficiency & Scalability<a hidden class=anchor aria-hidden=true href=#development-efficiency--scalability>#</a></h4><p>Create vast amounts of content with potentially less manual effort, allowing small teams to build large worlds.</p><h4 id=reduced-storagedownload-size>Reduced Storage/Download Size<a hidden class=anchor aria-hidden=true href=#reduced-storagedownload-size>#</a></h4><p>Store the generator (code) and a seed, not the massive output data [1].</p><h4 id=emergent-possibilities>Emergent Possibilities<a hidden class=anchor aria-hidden=true href=#emergent-possibilities>#</a></h4><p>Complex interactions between simple procedural rules can lead to unexpected and interesting results.</p><h3 id=the-challenges>The Challenges<a hidden class=anchor aria-hidden=true href=#the-challenges>#</a></h3><p>Of course, it&rsquo;s not magic. Getting PCG right involves challenges:</p><h4 id=coherence-and-quality>Coherence and Quality<a hidden class=anchor aria-hidden=true href=#coherence-and-quality>#</a></h4><p>Ensuring generated content makes sense, looks good, and is playable. Randomness needs structure.</p><h4 id=avoiding-repetition>Avoiding Repetition<a hidden class=anchor aria-hidden=true href=#avoiding-repetition>#</a></h4><p>Making sure the generated content doesn&rsquo;t feel monotonous or obviously algorithmic.</p><h4 id=artistic-control>Artistic Control<a hidden class=anchor aria-hidden=true href=#artistic-control>#</a></h4><p>Giving designers enough control to guide the generation towards a specific vision, rather than accepting whatever the
algorithm spits out. This often involves hybrid approaches, where procedural elements are combined with hand-authored
content or guided by designer-specified constraints.</p><h4 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h4><p>Finding bugs in content that only appears under certain random seeds can be tricky.</p><h3 id=noise-the-canvas-of-creation>Noise: The Canvas of Creation<a hidden class=anchor aria-hidden=true href=#noise-the-canvas-of-creation>#</a></h3><p>One of the most fundamental tools in the procedural generation toolbox, especially for terrain and textures, is **noise
**. We&rsquo;re not talking about audio noise, but rather mathematical functions that generate pseudo-random, yet structured,
patterns. Unlike pure <code>rand()</code>, which gives unrelated values at each point, noise functions produce values that vary
smoothly across space.</p><h4 id=perlin-noise>Perlin Noise<a hidden class=anchor aria-hidden=true href=#perlin-noise>#</a></h4><p>Developed by Ken Perlin in the 1980s (earning him an Academy Award!), Perlin noise is a type of <em>gradient noise</em>. It
works by setting up a grid and assigning a random gradient (direction) vector to each grid point. To get the noise value
at any location <em>within</em> a grid cell, you calculate vectors from the location to the cell&rsquo;s corners, compute the dot
product with the corner gradients, and then smoothly interpolate these values [2]. The result is a smooth, continuous,
organic-looking pattern often used for terrain heightmaps, clouds, fire effects, and wood grain textures [1]. However,
because it&rsquo;s based on a square/cubic grid, Perlin noise can sometimes exhibit subtle directional artifacts, especially
noticeable at lower frequencies.</p><h4 id=simplex-noise>Simplex Noise<a hidden class=anchor aria-hidden=true href=#simplex-noise>#</a></h4><p>Also developed by Ken Perlin (in 2001) to address some of Perlin noise&rsquo;s limitations, Simplex noise uses a simpler
lattice structure (triangles in 2D, tetrahedra in 3D) instead of a square/cubic grid [3]. This results in several
advantages:</p><ul><li>Lower computational complexity, especially in higher dimensions.</li><li>No significant directional artifacts (more isotropic).</li><li>Smoother visual appearance.
For these reasons, Simplex noise is often preferred for modern terrain generation [4].</li></ul><h4 id=value-noise>Value Noise<a hidden class=anchor aria-hidden=true href=#value-noise>#</a></h4><p>A simpler approach where random <em>values</em> (not gradients) are assigned to grid points, and the noise value at any
location is found by smoothly interpolating the values at the surrounding grid points [5]. It&rsquo;s computationally cheaper
than gradient noise but can sometimes look blockier or less &ldquo;natural.&rdquo;</p><h4 id=fractional-brownian-motion-fbm--fractal-noise>Fractional Brownian Motion (fBm) / Fractal Noise<a hidden class=anchor aria-hidden=true href=#fractional-brownian-motion-fbm--fractal-noise>#</a></h4><p>This isn&rsquo;t a single noise function but a technique for combining multiple layers (called <em>octaves</em>) of a base noise
function (like Perlin or Simplex) at different frequencies and amplitudes [6].</p><ul><li>The first octave (low frequency, high amplitude) creates large, broad features.</li><li>Subsequent octaves add progressively higher frequencies and lower amplitudes, layering finer and finer details on top.</li></ul><p>The key parameters are:</p><h5 id=persistence>Persistence<a hidden class=anchor aria-hidden=true href=#persistence>#</a></h5><p>Controls how much the amplitude decreases for each successive octave (typically &lt; 1).</p><h5 id=lacunarity>Lacunarity<a hidden class=anchor aria-hidden=true href=#lacunarity>#</a></h5><p>Controls how much the frequency increases for each successive octave (typically > 1). By summing these layers, you get
a &ldquo;fractal&rdquo; appearance – statistical self-similarity across different scales, much like real mountains or coastlines.
fBm is the workhorse for generating realistic-looking base terrain heightmaps.</p><p>Here&rsquo;s a conceptual C++ snippet showing how fBm (or &ldquo;octave noise&rdquo;) might be implemented using a placeholder <code>noise2D</code>
function (which could be Perlin or Simplex):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;random&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>// For seeding, though actual noise uses deterministic hashing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Placeholder noise function: returns noise value in [-1,1] for coordinates (x,y).
</span></span></span><span style=display:flex><span><span style=color:#75715e>// In reality, this would involve permutation tables, gradient vectors, interpolation etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// See libraries like FastNoiseLite, libnoise, or implement Perlin/Simplex yourself.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>noise2D</span>(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>double</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Generate fractal noise (fBm) by summing octaves of noise
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>fractalBrownianMotion</span>(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>double</span> y, <span style=color:#66d9ef>int</span> octaves, <span style=color:#66d9ef>double</span> persistence <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>, <span style=color:#66d9ef>double</span> lacunarity <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> totalValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> frequency <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> amplitude <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> maxValue <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>; <span style=color:#75715e>// Used for normalization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> octaves; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        totalValue <span style=color:#f92672>+=</span> amplitude <span style=color:#f92672>*</span> noise2D(x <span style=color:#f92672>*</span> frequency, y <span style=color:#f92672>*</span> frequency);
</span></span><span style=display:flex><span>        maxValue <span style=color:#f92672>+=</span> amplitude; <span style=color:#75715e>// Accumulate max possible amplitude
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        amplitude <span style=color:#f92672>*=</span> persistence; <span style=color:#75715e>// Decrease amplitude for next octave
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        frequency <span style=color:#f92672>*=</span> lacunarity;  <span style=color:#75715e>// Increase frequency for next octave
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Normalize the result to be roughly in [-1, 1] (assuming noise2D is in [-1, 1])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (maxValue <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> totalValue <span style=color:#f92672>/</span> maxValue;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.0</span>; <span style=color:#75715e>// Avoid division by zero if octaves=0 or amplitude=0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>512</span>, height <span style=color:#f92672>=</span> <span style=color:#ae81ff>512</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;&gt;</span> heightmap(height, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span>(width));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- Noise Initialization Would Go Here ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (e.g., seeding the PRNG, setting up permutation tables for Perlin/Simplex)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- Generate Heightmap using fBm ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> numOctaves <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> noisePersistence <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>; <span style=color:#75715e>// Standard 1/f noise characteristic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> noiseLacunarity <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> baseFrequency <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>; <span style=color:#75715e>// Controls the overall scale of the largest features
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; y <span style=color:#f92672>&lt;</span> height; <span style=color:#f92672>++</span>y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; x <span style=color:#f92672>&lt;</span> width; <span style=color:#f92672>++</span>x) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map pixel coordinates to noise input coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Dividing by width/height scales input; baseFrequency adjusts overall scale
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>double</span> nx <span style=color:#f92672>=</span> (<span style=color:#66d9ef>double</span>(x) <span style=color:#f92672>/</span> width) <span style=color:#f92672>*</span> baseFrequency;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>double</span> ny <span style=color:#f92672>=</span> (<span style=color:#66d9ef>double</span>(y) <span style=color:#f92672>/</span> height) <span style=color:#f92672>*</span> baseFrequency;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Generate fBm noise value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>double</span> elevation <span style=color:#f92672>=</span> fractalBrownianMotion(nx, ny, numOctaves, noisePersistence, noiseLacunarity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Map the noise value (e.g., [-1, 1]) to your desired height range
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Example: Map to [0, 1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            heightmap[y][x] <span style=color:#f92672>=</span> (elevation <span style=color:#f92672>+</span> <span style=color:#ae81ff>1.0</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- Use the Heightmap ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (e.g., render it, determine land/water based on a threshold, etc.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Noise functions are the fundamental texture, the raw material from which many procedural worlds are sculpted. But just
applying noise isn&rsquo;t enough to create a believable world. We need structure, geology, and the effects of natural
processes.</p><h2 id=shaping-the-canvas-map-geometry-and-representation>Shaping the Canvas: Map Geometry and Representation<a hidden class=anchor aria-hidden=true href=#shaping-the-canvas-map-geometry-and-representation>#</a></h2><p>Before we can paint mountains and rivers, we need a canvas. How do we represent the game world? The choice of map
geometry has profound implications for everything that follows.</p><h3 id=flat-maps-planar-worlds>Flat Maps (Planar Worlds)<a hidden class=anchor aria-hidden=true href=#flat-maps-planar-worlds>#</a></h3><p>The simplest approach is to treat the world as a 2D plane.</p><h4 id=infinite-continuous-planes>Infinite Continuous Planes<a hidden class=anchor aria-hidden=true href=#infinite-continuous-planes>#</a></h4><p>Games like <em>Minecraft</em> conceptually use an infinite plane. The world isn&rsquo;t pre-generated; chunks are generated on the
fly as the player explores, often using noise functions evaluated at the chunk&rsquo;s coordinates. Techniques like <em>periodic
noise</em> or careful coordinate management are needed to ensure chunks stitch together seamlessly [7].</p><h4 id=bounded-planes>Bounded Planes<a hidden class=anchor aria-hidden=true href=#bounded-planes>#</a></h4><p>Simpler maps might just have hard edges (invisible walls or an &ldquo;edge of the world&rdquo;). This is easy but can feel
artificial.</p><h4 id=wrapped-planes-toroidal-worlds>Wrapped Planes (Toroidal Worlds)<a hidden class=anchor aria-hidden=true href=#wrapped-planes-toroidal-worlds>#</a></h4><p>To eliminate edges, flat maps can be &ldquo;wrapped.&rdquo; Going off the east edge brings you to the west edge, and going off the
north edge brings you to the south. Topologically, this creates a <em>torus</em> (a donut shape), not a sphere. This is common
in older strategy games or simulations where a finite but borderless world is desired [8].</p><h3 id=spherical-maps-planetary-worlds>Spherical Maps (Planetary Worlds)<a hidden class=anchor aria-hidden=true href=#spherical-maps-planetary-worlds>#</a></h3><p>For simulating planets, strategy games spanning a globe, or space exploration games, a spherical representation is more
realistic. However, this introduces complexity. How do you map a sphere onto data structures and display it on a 2D
screen?</p><h4 id=challenges>Challenges<a hidden class=anchor aria-hidden=true href=#challenges>#</a></h4><p>Representing a sphere without significant distortion or awkward singularities (like the poles in latitude-longitude
grids) is tricky. An <em>equirectangular projection</em> (mapping latitude/longitude directly to a rectangular grid) is simple
but severely stretches areas near the poles and collapses everything to a single point <em>at</em> the poles.</p><h4 id=common-solutions>Common Solutions<a hidden class=anchor aria-hidden=true href=#common-solutions>#</a></h4><h5 id=cube-mapping>Cube Mapping<a hidden class=anchor aria-hidden=true href=#cube-mapping>#</a></h5><p>Project the sphere onto the six faces of a cube. Each face can be treated as a regular square grid, minimizing
distortion compared to equirectangular. The main challenge is handling the seams/edges between the cube faces smoothly.</p><h5 id=icosahedral-subdivision-geodesic-grids>Icosahedral Subdivision (Geodesic Grids)<a hidden class=anchor aria-hidden=true href=#icosahedral-subdivision-geodesic-grids>#</a></h5><p>Start with an icosahedron (20 triangular faces) inscribed within the sphere. Project its vertices onto the sphere. Then,
recursively subdivide each triangle into smaller triangles, projecting new vertices onto the sphere. This creates a
<em>geodesic dome</em> structure. The dual of this triangular mesh (connecting the centers of adjacent triangles) results in a
grid composed mostly of hexagons, with exactly 12 pentagons located at the original icosahedron&rsquo;s vertices (think of a
soccer ball pattern) [4]. This <strong>hex-pent grid</strong> provides relatively uniform cell sizes and shapes across the sphere,
making it popular for global climate models and some planetary generators [4]. The main complexity lies in the data
structures needed to handle the 12 pentagons and track neighbor relationships.</p><h5 id=fibonacci-lattice--spiral-points>Fibonacci Lattice / Spiral Points<a hidden class=anchor aria-hidden=true href=#fibonacci-lattice--spiral-points>#</a></h5><p>Algorithms exist to distribute points quasi-uniformly on a sphere&rsquo;s surface using spiral patterns related to the
Fibonacci sequence or golden ratio [4]. These points can then be used as centers for Voronoi regions or vertices for a
Delaunay triangulation, creating an irregular but relatively even mesh covering the sphere. Amit Patel&rsquo;s influential
planet generation experiments often start by distributing points this way, then slightly &ldquo;jittering&rdquo; them to avoid
unnatural regularity [4].</p><h3 id=tiling-schemes-squares-vs-hexes-vs-irregular>Tiling Schemes: Squares vs. Hexes vs. Irregular<a hidden class=anchor aria-hidden=true href=#tiling-schemes-squares-vs-hexes-vs-irregular>#</a></h3><p>Whether the map is flat or spherical (represented facet by facet, like a cube map or geodesic grid), we often divide it
into discrete units or <em>tiles</em> for gameplay or simulation purposes.</p><h4 id=square-tiles>Square Tiles<a hidden class=anchor aria-hidden=true href=#square-tiles>#</a></h4><p>The simplest. Easy to address (row, column), easy to map to pixel grids. Neighbors are straightforward (4 cardinal,
possibly 4 diagonal). The main drawback, especially for movement or area-of-effect calculations, is the difference
between orthogonal and diagonal distances/connectivity.</p><h4 id=hexagonal-tiles>Hexagonal Tiles<a hidden class=anchor aria-hidden=true href=#hexagonal-tiles>#</a></h4><p>A favorite for many strategy games (<em>Civilization V/VI</em>, <em>RimWorld</em>&rsquo;s planet map). Why?</p><h5 id=uniform-adjacency>Uniform Adjacency<a hidden class=anchor aria-hidden=true href=#uniform-adjacency>#</a></h5><p>Each hex has 6 neighbors, all equidistant from the center. This eliminates the diagonal vs. orthogonal awkwardness of
squares, making movement costs and distances more consistent.</p><h5 id=connectivity>Connectivity<a hidden class=anchor aria-hidden=true href=#connectivity>#</a></h5><p>The 6-way connectivity can lead to more organic-looking shapes for landmasses and region boundaries.</p><h5 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h5><p>Requires slightly more complex coordinate systems (axial or cube coordinates are common) and careful handling of
neighbor finding and wrapping, especially on a sphere. Excellent guides exist, notably from Red Blob Games [9] [8].</p><h5 id=irregular-polygons-voronoigraph-based>Irregular Polygons (Voronoi/Graph-Based)<a hidden class=anchor aria-hidden=true href=#irregular-polygons-voronoigraph-based>#</a></h5><p>Instead of uniform tiles, partition the map using irregular polygons, often generated via a <strong>Voronoi diagram</strong>.</p><ol><li>Scatter a set of points (seeds) across the map (plane or sphere).</li><li>For each seed, define its region (cell) as all locations closer to that seed than any other.</li><li>The result is a tessellation of the map into irregular polygonal cells.</li></ol><p>Amit Patel&rsquo;s <em>Polygon Map Generation</em> tutorials are seminal work in this area [10].</p><h6 id=advantages>Advantages<a hidden class=anchor aria-hidden=true href=#advantages>#</a></h6><p>Can produce much more natural-looking coastlines, region boundaries, and river paths (which can flow along the edges of
the Voronoi graph). The underlying graph structure is great for simulating flows or relationships between regions. It
provides a &ldquo;good skeleton&rdquo; for placing features [10]. Systems like <em>Mapgen4</em> and <em>Tectonics.js</em> utilize this
approach [4].</p><h6 id=disadvantages>Disadvantages:<a hidden class=anchor aria-hidden=true href=#disadvantages>#</a></h6><p>Computationally more expensive to generate and work with. Geometric operations (like finding neighbors or calculating
distances/areas) are more complex than on a regular grid.</p><p>The choice of map geometry and tiling impacts everything downstream, from how noise is applied to how simulations like
erosion or climate are run. A <strong>spherical Voronoi mesh</strong> arguably offers the highest potential for realism on a
planetary scale, but simpler grids (flat or wrapped, square or hex) are often chosen for performance and ease of
implementation.</p><h2 id=raising-the-land-generating-continents-and-oceans>Raising the Land: Generating Continents and Oceans<a hidden class=anchor aria-hidden=true href=#raising-the-land-generating-continents-and-oceans>#</a></h2><p>With a canvas defined, the next step is painting the broad strokes: where is land, and where is sea? How do continents
form? Two main paradigms dominate: noise-based heightmaps and plate tectonics simulation.</p><h3 id=fractal-noise-heightmaps-the-quick-and-dirty-approach>Fractal Noise Heightmaps: The Quick and Dirty Approach<a hidden class=anchor aria-hidden=true href=#fractal-noise-heightmaps-the-quick-and-dirty-approach>#</a></h3><p>The most common method is to use fractal noise (like fBm described earlier) to generate an <strong>elevation map</strong> or *
<em>heightmap</em>*. This is typically a 2D grid where each cell stores an elevation value.</p><h4 id=generate-noise>Generate Noise<a hidden class=anchor aria-hidden=true href=#generate-noise>#</a></h4><p>Use multiple octaves of Perlin or Simplex noise to create a heightfield $H(x, y)$. Low frequencies create broad
continents/basins, high frequencies add detail.</p><h4 id=set-sea-level>Set Sea Level<a hidden class=anchor aria-hidden=true href=#set-sea-level>#</a></h4><p>Choose a threshold value. All points on the heightmap below this value become ocean; all points above become land. A
common target is ~70% ocean, similar to Earth, which might correspond to picking the 30th percentile of height values as
sea level [1].</p><p>This quickly produces a world with land and sea. However, pure noise has limitations:</p><h4 id=lack-of-structure>Lack of Structure<a hidden class=anchor aria-hidden=true href=#lack-of-structure>#</a></h4><p>Real continents have long, linear mountain ranges, vast flat plains, and specific shapes dictated by geological history.
Noise-based terrain tends to produce more random, blobby, or uniformly hilly landscapes. Mountain ranges don&rsquo;t align
meaningfully [1].</p><h4 id=island-problem>Island Problem<a hidden class=anchor aria-hidden=true href=#island-problem>#</a></h4><p>Naively thresholding noise often results in worlds that are either mostly ocean with scattered small islands, or mostly
land with scattered lakes, rather than a few large continents.</p><h4 id=techniques-to-improve-noise-based-continents>Techniques to Improve Noise-Based Continents<a hidden class=anchor aria-hidden=true href=#techniques-to-improve-noise-based-continents>#</a></h4><h5 id=shaping-functions>Shaping Functions<a hidden class=anchor aria-hidden=true href=#shaping-functions>#</a></h5><p>Multiply the noise heightmap by another function (e.g., a radial gradient that lowers elevation near the edges of the
map) to force oceans around a central landmass. WorldEngine uses a trick where they normalize the heightmap so the
lowest point is at the border and highest is central, then flood from the edges to ensure a central continent [1].</p><h5 id=domain-warping>Domain Warping<a hidden class=anchor aria-hidden=true href=#domain-warping>#</a></h5><p>A clever technique popularized by Inigo Quilez and others. Instead of evaluating noise at <code>(x, y)</code>, you evaluate it at
coordinates that have been distorted by <em>another</em> noise function. For example:
<code>height = noise1(x + offset * noise2(x, y), y + offset * noise3(x, y))</code>. This &ldquo;warps&rdquo; the coordinate space, creating
swirling, folded, and branching patterns in the output noise [7]. Domain warping can produce features that <em>look</em>
remarkably like eroded terrain – twisty ridges, river-like valleys – without actually simulating erosion [7]. It&rsquo;s
computationally cheap (just more noise lookups) and adds significant visual complexity, making basic noise terrain look
much more interesting.</p><h5 id=diamond-square-algorithm>Diamond-Square Algorithm<a hidden class=anchor aria-hidden=true href=#diamond-square-algorithm>#</a></h5><p>A classic (though somewhat dated) fractal algorithm specifically for generating heightmaps. It works by recursively
subdividing squares, setting corner points, then calculating midpoints with random offsets. It tends to produce
characteristic square-aligned artifacts but is simple to implement.</p><p>Noise provides the fundamental texture and detail, but for realistic <em>structure</em>, we often need to simulate the
processes that build that structure.</p><h3 id=plate-tectonics-simulation-building-worlds-geologically>Plate Tectonics Simulation: Building Worlds Geologically<a hidden class=anchor aria-hidden=true href=#plate-tectonics-simulation-building-worlds-geologically>#</a></h3><p>On Earth, continents and mountains are formed by the slow dance of tectonic plates. Simulating this process can produce
far more plausible large-scale world structures. While full geophysical simulation is complex, simplified models are
feasible for world generation. Notable projects exploring this include <em>WorldEngine</em>, <em>Tectonics.js</em>, <em>PyTectonics</em>, and
academic work like &ldquo;Procedural Tectonic Planets&rdquo; [1] [11] [12].</p><h4 id=a-simplified-tectonic-algorithm>A Simplified Tectonic Algorithm<a hidden class=anchor aria-hidden=true href=#a-simplified-tectonic-algorithm>#</a></h4><h5 id=initialize-plates>Initialize Plates<a hidden class=anchor aria-hidden=true href=#initialize-plates>#</a></h5><p>Divide the world (represented as a grid or spherical mesh) into a number of distinct regions, representing tectonic
plates (e.g., 6-20 plates). This can be done randomly (e.g., Voronoi partitioning) or based on initial noise patterns.
Assign each plate an initial velocity (direction and speed).</p><h5 id=move-plates>Move Plates<a hidden class=anchor aria-hidden=true href=#move-plates>#</a></h5><p>Simulate the movement of each plate over a time step according to its velocity. On a sphere, this movement follows great
circle paths.</p><h5 id=detect-interactions>Detect Interactions<a hidden class=anchor aria-hidden=true href=#detect-interactions>#</a></h5><p>Identify where plates are colliding (convergent boundary), pulling apart (divergent boundary), or sliding past each
other (transform boundary).</p><h5 id=modify-terrain>Modify Terrain<a hidden class=anchor aria-hidden=true href=#modify-terrain>#</a></h5><h6 id=convergence-collision>Convergence (Collision)<a hidden class=anchor aria-hidden=true href=#convergence-collision>#</a></h6><p>Where plates collide, uplift the terrain significantly, forming mountain ranges. If one plate is denser (oceanic vs.
continental), it might <em>subduct</em> (slide underneath), leading to uplift on the overriding plate and potentially volcanic
activity or deep ocean trenches.</p><h6 id=divergence-rifting>Divergence (Rifting)<a hidden class=anchor aria-hidden=true href=#divergence-rifting>#</a></h6><p>Where plates pull apart, lower the terrain, creating rift valleys on land or mid-ocean ridges under the sea where new
crust forms.</p><h6 id=transform>Transform<a hidden class=anchor aria-hidden=true href=#transform>#</a></h6><p>Minimal vertical change, but can create fault lines.</p><h5 id=iterate>Iterate<a hidden class=anchor aria-hidden=true href=#iterate>#</a></h5><p>Repeat steps 2-4 for many simulated time steps (representing millions of years). Plate velocities might change, plates
might merge or break apart.</p><h4 id=more-sophisticated-models-eg-tectonicsjs>More Sophisticated Models (e.g., Tectonics.js)<a hidden class=anchor aria-hidden=true href=#more-sophisticated-models-eg-tectonicsjs>#</a></h4><p><em>Tectonics.js</em> implements a more physics-inspired model on a spherical grid [11]:</p><ul><li>It tracks crust properties like density and age. Oceanic crust becomes denser as it ages [11].</li><li>Dense oceanic crust tends to subduct under lighter continental or younger oceanic crust [11].</li><li>Plate velocities are calculated based on forces pulling plates towards subduction zones [11]. Plates are dynamically
identified by grouping areas with similar velocities.</li><li>At convergent boundaries, overlapping crust is effectively deleted (simulating subduction). At divergent boundaries,
gaps are filled with new crust [11].
This leads to emergent, realistic features: long mountain chains, island arcs, spreading ocean basins [11]. The
downside is computational cost – it&rsquo;s not instantaneous [11].</li></ul><h4 id=benefits-of-tectonic-simulation>Benefits of Tectonic Simulation<a hidden class=anchor aria-hidden=true href=#benefits-of-tectonic-simulation>#</a></h4><h5 id=plausible-structure>Plausible Structure<a hidden class=anchor aria-hidden=true href=#plausible-structure>#</a></h5><p>Generates continents, oceans, and mountain ranges with shapes and alignments that resemble real geology. Features that
noise alone struggles with.</p><h5 id=inherent-history>Inherent History<a hidden class=anchor aria-hidden=true href=#inherent-history>#</a></h5><p>The generated world has a &ldquo;story.&rdquo; You can trace why a mountain range exists (e.g., collision of plates X and Y). This
is great for lore and deeper simulation [11] [13].</p><h5 id=emergent-landsea-distribution>Emergent Land/Sea Distribution<a hidden class=anchor aria-hidden=true href=#emergent-landsea-distribution>#</a></h5><p>The amount and shape of land isn&rsquo;t predefined but emerges naturally from the simulation.</p><h4 id=hybrid-approaches>Hybrid Approaches<a hidden class=anchor aria-hidden=true href=#hybrid-approaches>#</a></h4><p>Pure tectonic simulation can sometimes produce terrain that lacks fine detail or looks &ldquo;bland&rdquo; between the major
features. Many systems, like <em>WorldEngine</em>, use a hybrid approach:</p><ol><li>Start with an initial heightmap generated by noise (providing base detail).</li><li>Run a plate tectonics simulation to deform this heightmap, creating large-scale structures.</li><li>Apply <em>more</em> noise afterward to add roughness and smaller features back in.
[1]. This combination often yields the best results: realistic large-scale structure with natural-looking small-scale
variation.</li></ol><p>After generating the basic landforms via noise, tectonics, or a hybrid, the next step is often to refine the terrain
with processes that shape it over time.</p><h2 id=carving-the-details-erosion-and-river-simulation>Carving the Details: Erosion and River Simulation<a hidden class=anchor aria-hidden=true href=#carving-the-details-erosion-and-river-simulation>#</a></h2><p>A freshly generated heightmap, even one based on tectonics and noise, often looks too sharp, too uniform, too&mldr;
<em>computer-generated</em>. Real landscapes are heavily sculpted by erosion – the relentless wearing away of rock and soil by
water, wind, ice, and gravity. Simulating erosion is crucial for adding realism and creating features like river
valleys, smooth hills, and depositional plains. As the WorldEngine developers state, <em>&ldquo;If you do not simulate erosion
you will never obtain realistic maps.&rdquo;</em> [1].</p><h3 id=hydraulic-erosion-water-power>Hydraulic Erosion (Water Power)<a hidden class=anchor aria-hidden=true href=#hydraulic-erosion-water-power>#</a></h3><p>This is the most significant type of erosion for shaping large landscapes. It involves water (rain, rivers) dislodging
soil/rock particles, transporting them downhill, and depositing them where the water slows down. There are two main
algorithmic approaches [14]:</p><h4 id=eulerian-grid-based>Eulerian (Grid-Based)<a hidden class=anchor aria-hidden=true href=#eulerian-grid-based>#</a></h4><p>Treats water as a fluid layer covering the terrain grid. Each cell tracks water depth and sediment concentration. Water
flows between cells based on height differences (pressure gradients), carrying sediment with it. Sediment is eroded from
the ground where flow is high and deposited where it&rsquo;s low. These models often use simplified versions of fluid dynamics
equations (like the shallow water equations). They can capture large-scale effects but can be complex and
computationally intensive.</p><h4 id=lagrangian-particle-based--rain-droplet-model>Lagrangian (Particle-Based / &ldquo;Rain Droplet&rdquo; Model):<a hidden class=anchor aria-hidden=true href=#lagrangian-particle-based--rain-droplet-model>#</a></h4><p>Simulates the paths of individual water droplets. This is very popular in game development due to its conceptual
simplicity and ability to create intricate channel networks. The basic idea:</p><h5 id=spawn-droplet>Spawn Droplet<a hidden class=anchor aria-hidden=true href=#spawn-droplet>#</a></h5><p>Create a &ldquo;raindrop&rdquo; particle at a random location on the heightmap with a small amount of water and initially no
sediment.</p><h5 id=flow-downhill>Flow Downhill<a hidden class=anchor aria-hidden=true href=#flow-downhill>#</a></h5><p>Move the droplet in the direction of the steepest downhill slope, calculated from the heightmap gradient at its current
position. Its velocity increases on steeper slopes.</p><h5 id=erodedeposit>Erode/Deposit<a hidden class=anchor aria-hidden=true href=#erodedeposit>#</a></h5><p>The droplet&rsquo;s capacity to carry sediment depends on factors like its water volume, velocity, and the slope it&rsquo;s on.</p><ul><li>If the droplet is moving fast/downhill (high capacity) and currently holds less sediment than its capacity, it
<em>erodes</em> material from the ground, decreasing terrain height and increasing its sediment load.</li><li>If the droplet slows down (e.g., on flatter ground, low capacity) and holds more sediment than it can carry, it
<em>deposits</em> sediment, increasing terrain height and decreasing its load.
A simple capacity model might be: <code>capacity = k * velocity * slope</code> [14]. The amount eroded or deposited is then
proportional to the difference between capacity and current sediment load [14].</li></ul><h5 id=evaporate>Evaporate<a hidden class=anchor aria-hidden=true href=#evaporate>#</a></h5><p>The droplet gradually loses water over time/distance.</p><h5 id=terminate>Terminate<a hidden class=anchor aria-hidden=true href=#terminate>#</a></h5><p>The simulation for that droplet ends when it runs out of water, flows off the map, or gets stuck in a pit.</p><h5 id=repeat>Repeat<a hidden class=anchor aria-hidden=true href=#repeat>#</a></h5><p>Simulate thousands or millions of these droplets. Each path contributes incrementally to carving channels and building
up depositional areas.</p><p>Here&rsquo;s the C++ pseudocode snippet (adapted from Article 1 and common implementations) illustrating the core loop for a
single droplet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>// For std::max, std::min
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Assumes existence of a HeightMap class/struct
</span></span></span><span style=display:flex><span><span style=color:#75715e>// with methods like:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// double getHeight(double x, double y); // Interpolated height
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Vector2 getGradient(double x, double y); // Steepest downhill gradient vector
</span></span></span><span style=display:flex><span><span style=color:#75715e>// void addHeight(int gridX, int gridY, double delta); // Modify height at grid cell
</span></span></span><span style=display:flex><span><span style=color:#75715e>// int width(); int height();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HeightMap</span> { <span style=color:#75715e>/* ... definition ... */</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Vector2</span> { <span style=color:#66d9ef>double</span> x, y; };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Droplet</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x, y;      <span style=color:#75715e>// Current position (continuous)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> vx, vy;    <span style=color:#75715e>// Current velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> water;     <span style=color:#75715e>// Amount of water remaining
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> sediment;  <span style=color:#75715e>// Amount of sediment carried
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Simulation parameters (tune these!)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> maxSteps <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;         <span style=color:#75715e>// Max lifetime of a droplet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> timeStep <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;     <span style=color:#75715e>// Simulation step duration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> friction <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>;     <span style=color:#75715e>// Slows down velocity over time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> evaporationRate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>; <span style=color:#75715e>// Water lost per step
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> erosionRate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>;  <span style=color:#75715e>// How readily soil is eroded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> depositRate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>; <span style=color:#75715e>// How readily sediment is deposited
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> sedimentCapacityFactor <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>; <span style=color:#75715e>// Scales overall capacity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> minSlopeForErosion <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>; <span style=color:#75715e>// Don&#39;t erode on near-flat ground
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>double</span> minWater <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.001</span>;    <span style=color:#75715e>// Stop when droplet is too small
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>simulateDroplet</span>(Droplet<span style=color:#f92672>&amp;</span> d, HeightMap<span style=color:#f92672>&amp;</span> H) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; step <span style=color:#f92672>&lt;</span> maxSteps; <span style=color:#f92672>++</span>step) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Get current grid cell indices and interpolated position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> gridX <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(d.x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> gridY <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(d.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Boundary check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (gridX <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> gridX <span style=color:#f92672>&gt;=</span> H.width() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> gridY <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> gridY <span style=color:#f92672>&gt;=</span> H.height() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>; <span style=color:#75715e>// Droplet flowed off map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate height and gradient at the droplet&#39;s interpolated position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> currentHeight <span style=color:#f92672>=</span> H.getHeight(d.x, d.y);
</span></span><span style=display:flex><span>        Vector2 gradient <span style=color:#f92672>=</span> H.getGradient(d.x, d.y); <span style=color:#75715e>// Points downhill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update velocity based on gradient (gravity) and friction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        d.vx <span style=color:#f92672>=</span> (d.vx <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> friction)) <span style=color:#f92672>+</span> gradient.x <span style=color:#f92672>*</span> timeStep;
</span></span><span style=display:flex><span>        d.vy <span style=color:#f92672>=</span> (d.vy <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> friction)) <span style=color:#f92672>+</span> gradient.y <span style=color:#f92672>*</span> timeStep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Store old position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> oldX <span style=color:#f92672>=</span> d.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> oldY <span style=color:#f92672>=</span> d.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Update position based on velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        d.x <span style=color:#f92672>+=</span> d.vx <span style=color:#f92672>*</span> timeStep;
</span></span><span style=display:flex><span>        d.y <span style=color:#f92672>+=</span> d.vy <span style=color:#f92672>*</span> timeStep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Boundary check again after move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (d.x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> d.x <span style=color:#f92672>&gt;=</span> H.width() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> d.y <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> d.y <span style=color:#f92672>&gt;=</span> H.height() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>             <span style=color:#75715e>// Deposit remaining sediment at last valid position before leaving map
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             H.addHeight(gridX, gridY, d.sediment);
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate height difference between old and new position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> newHeight <span style=color:#f92672>=</span> H.getHeight(d.x, d.y);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> deltaHeight <span style=color:#f92672>=</span> currentHeight <span style=color:#f92672>-</span> newHeight; <span style=color:#75715e>// Positive if moving downhill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate sediment capacity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Capacity depends on water volume, speed, and slope (deltaHeight)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Simple model: capacity proportional to water * deltaHeight (steeper drop = more capacity)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Clamp deltaHeight to avoid negative capacity if moving uphill slightly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> speed <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>sqrt(d.vx <span style=color:#f92672>*</span> d.vx <span style=color:#f92672>+</span> d.vy <span style=color:#f92672>*</span> d.vy);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> capacity <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0.0</span>, deltaHeight) <span style=color:#f92672>*</span> d.water <span style=color:#f92672>*</span> sedimentCapacityFactor <span style=color:#f92672>*</span> speed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Erode or deposit sediment at the *previous* cell (gridX, gridY)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This prevents digging holes directly under the droplet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (deltaHeight <span style=color:#f92672>&gt;</span> minSlopeForErosion) { <span style=color:#75715e>// Only erode/deposit significantly if moving downhill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#66d9ef>double</span> sedimentDiff <span style=color:#f92672>=</span> capacity <span style=color:#f92672>-</span> d.sediment;
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span> (sedimentDiff <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                 <span style=color:#75715e>// Can carry more: Erode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 <span style=color:#66d9ef>double</span> amountToErode <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(sedimentDiff <span style=color:#f92672>*</span> erosionRate, deltaHeight); <span style=color:#75715e>// Don&#39;t erode more than available height diff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 amountToErode <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(amountToErode, H.getHeight(gridX <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>, gridY <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>); <span style=color:#75715e>// Limit erosion based on current height too
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 amountToErode <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0.0</span>, amountToErode); <span style=color:#75715e>// Ensure non-negative
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                 H.addHeight(gridX, gridY, <span style=color:#f92672>-</span>amountToErode); <span style=color:#75715e>// Remove from terrain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 d.sediment <span style=color:#f92672>+=</span> amountToErode;              <span style=color:#75715e>// Add to droplet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                 <span style=color:#75715e>// Carrying too much: Deposit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 <span style=color:#66d9ef>double</span> amountToDeposit <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(<span style=color:#f92672>-</span>sedimentDiff <span style=color:#f92672>*</span> depositRate, d.sediment); <span style=color:#75715e>// Deposit difference, up to amount carried
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 amountToDeposit <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0.0</span>, amountToDeposit); <span style=color:#75715e>// Ensure non-negative
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                 H.addHeight(gridX, gridY, amountToDeposit); <span style=color:#75715e>// Add to terrain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                 d.sediment <span style=color:#f92672>-=</span> amountToDeposit;           <span style=color:#75715e>// Remove from droplet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Evaporate water
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        d.water <span style=color:#f92672>*=</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> evaporationRate);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (d.water <span style=color:#f92672>&lt;</span> minWater) {
</span></span><span style=display:flex><span>             <span style=color:#75715e>// Deposit remaining sediment if droplet evaporates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             H.addHeight(gridX, gridY, d.sediment);
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// --- In main() or simulation loop ---
</span></span></span><span style=display:flex><span><span style=color:#75715e>// HeightMap terrain = ...; // Initial heightmap
</span></span></span><span style=display:flex><span><span style=color:#75715e>// int numDroplets = 100000;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// std::mt19937 rng(seed); // Random number generator
</span></span></span><span style=display:flex><span><span style=color:#75715e>// std::uniform_real_distribution&lt;double&gt; distX(0.0, terrain.width() - 1.0);
</span></span></span><span style=display:flex><span><span style=color:#75715e>// std::uniform_real_distribution&lt;double&gt; distY(0.0, terrain.height() - 1.0);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// for (int i = 0; i &lt; numDroplets; ++i) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     Droplet drop = {
</span></span></span><span style=display:flex><span><span style=color:#75715e>//         distX(rng), distY(rng), // Random start position
</span></span></span><span style=display:flex><span><span style=color:#75715e>//         0.0, 0.0,             // Initial velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e>//         1.0,                  // Initial water
</span></span></span><span style=display:flex><span><span style=color:#75715e>//         0.0                   // Initial sediment
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     };
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     simulateDroplet(drop, terrain);
</span></span></span><span style=display:flex><span><span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e>// --- Terrain now contains eroded features ---
</span></span></span></code></pre></div><p><strong>Performance Note:</strong> Simulating millions of droplets can be slow. Optimizations include:</p><ul><li>GPU acceleration (as researched by Mei et al. [1]).</li><li>Simulating larger &ldquo;streams&rdquo; or using grid-based flow accumulation models instead of individual droplets.</li></ul><h3 id=thermal-erosion-weathering--mass-wasting>Thermal Erosion (Weathering / Mass Wasting)<a hidden class=anchor aria-hidden=true href=#thermal-erosion-weathering--mass-wasting>#</a></h3><p>This simulates the effect of gravity causing material on steep slopes to crumble and slide downwards, accumulating at
the base (forming <em>talus slopes</em>). It&rsquo;s much simpler than hydraulic erosion.</p><p>A common algorithm:</p><ol><li>Iterate through each cell <code>(x, y)</code> of the heightmap.</li><li>Compare its height <code>H(x, y)</code> to its neighbors <code>H(nx, ny)</code>.</li><li>For each neighbor <em>lower</em> than the current cell, calculate the height difference <code>d = H(x, y) - H(nx, ny)</code>.</li><li>If this difference <code>d</code> exceeds a <em>threshold</em> (representing the material&rsquo;s &ldquo;angle of repose&rdquo; – the steepest angle it
can maintain), then move some material from the higher cell <code>(x, y)</code> to the lower neighbor <code>(nx, ny)</code>.</li><li>The amount moved is typically proportional to the excess difference <code>(d - threshold)</code>. For example, move
<code>c * (d - threshold)</code> amount of height, where <code>c</code> is a small constant [15] [16]. Ensure total height is conserved (or
approximately conserved) by distributing the removed height among all lower neighbors exceeding the threshold.</li><li>Repeat this process for several iterations until the terrain stabilizes (no more slopes exceed the threshold
significantly).</li></ol><p>Thermal erosion is computationally cheap and effective at smoothing out unnaturally sharp peaks and cliffs left by noise
generation or tectonic uplift, giving mountains a more weathered look. It&rsquo;s often applied as a final smoothing pass.</p><h3 id=river-network-generation-and-watersheds>River Network Generation and Watersheds<a hidden class=anchor aria-hidden=true href=#river-network-generation-and-watersheds>#</a></h3><p>While hydraulic erosion <em>creates</em> river channels, sometimes you want to explicitly define major rivers for gameplay or
ensure a realistic drainage network exists.</p><h4 id=flow-accumulation-analysis>Flow Accumulation Analysis:<a hidden class=anchor aria-hidden=true href=#flow-accumulation-analysis>#</a></h4><p>A standard GIS technique adaptable for games.</p><ol><li>For each cell, determine its <em>flow direction</em> – which neighbor is steepest downhill?</li><li>Calculate <em>flow accumulation</em> for each cell: how many upstream cells eventually drain <em>through</em> this cell? This is
often done recursively or iteratively, passing flow counts downstream.</li><li>Cells with a high flow accumulation value represent potential river paths. Define a threshold – cells above it are
part of a river network. This naturally creates branching tributary systems flowing from highlands to lowlands or
oceans.</li></ol><h4 id=explicit-river-carving>Explicit River Carving<a hidden class=anchor aria-hidden=true href=#explicit-river-carving>#</a></h4><p>Start potential rivers at high points (e.g., mountain springs, areas of high simulated rainfall). Simulate the river
flowing downhill, actively lowering the terrain height along its path to &ldquo;carve&rdquo; a valley. Rules are needed to handle
hitting flat areas (meander) or depressions (form lakes). Amit Patel&rsquo;s Mapgen4 allows users to <em>draw</em> rivers, and the
system then carves them into the terrain [17].</p><h4 id=simulation-driven-rivers>Simulation-Driven Rivers<a hidden class=anchor aria-hidden=true href=#simulation-driven-rivers>#</a></h4><p>In systems like WorldEngine, rivers emerge more directly from the coupled simulation. After calculating precipitation
and running erosion, they explicitly trace water flow paths from source to sea, calculate water volume in each segment,
and designate tiles with significant flow as rivers [1].</p><h4 id=watersheds>Watersheds<a hidden class=anchor aria-hidden=true href=#watersheds>#</a></h4><p>The flow direction map also allows identifying <em>watersheds</em> (or drainage basins) – the area of land that drains into a
particular river or outlet point. These watersheds, separated by ridges (drainage divides), form natural geographical
regions often useful for defining political borders, biome zones, or AI territories.</p><p>In summary, erosion and river simulation transform a static heightmap into a landscape that feels shaped by natural
forces over time. They carve the valleys, create the river networks, and deposit the fertile plains that make a world
feel lived-in and geologically plausible. Even simplified erosion or faked effects like domain warping can add
significant realism compared to raw noise terrain.</p><h2 id=breathing-life-into-the-world-climate-weather-and-biomes>Breathing Life into the World: Climate, Weather, and Biomes<a hidden class=anchor aria-hidden=true href=#breathing-life-into-the-world-climate-weather-and-biomes>#</a></h2><p>We have land, water, mountains, and rivers. But what makes a desert different from a jungle, or a tundra from a
temperate forest? Climate. Simulating climate patterns – temperature, precipitation, wind – allows us to determine which
<strong>biomes</strong> (ecological regions) should exist where.</p><h3 id=simulating-climate>Simulating Climate<a hidden class=anchor aria-hidden=true href=#simulating-climate>#</a></h3><p>Full global climate modeling (GCM) like that used by climate scientists is computationally prohibitive for most game
world generation. Instead, simplified, heuristic models are used to capture the most important factors influencing
climate:</p><h4 id=latitude>Latitude<a hidden class=anchor aria-hidden=true href=#latitude>#</a></h4><p>The primary driver of temperature. Closer to the equator = more direct sunlight = warmer. Temperature generally
decreases towards the poles. A simple model might be <code>Temp = BaseTemp - TempDrop * abs(latitude)</code> or using a sine
function.</p><h4 id=altitude>Altitude<a hidden class=anchor aria-hidden=true href=#altitude>#</a></h4><p>Temperature decreases with height (the <em>lapse rate</em>, roughly 6.5°C per 1000m). Mountains are colder than lowlands at the
same latitude.</p><h4 id=land-vs-water>Land vs. Water<a hidden class=anchor aria-hidden=true href=#land-vs-water>#</a></h4><p>Water heats and cools more slowly than land. Coastal areas tend to have more moderate temperatures (less seasonal
variation) than continental interiors (<em>continentality</em>). Large bodies of water also act as moisture sources.</p><h4 id=prevailing-winds>Prevailing Winds<a hidden class=anchor aria-hidden=true href=#prevailing-winds>#</a></h4><p>Global atmospheric circulation creates dominant wind patterns (e.g., easterly trade winds in the tropics, westerlies in
mid-latitudes). Winds transport moisture from oceans over land.</p><h4 id=ocean-currents-advanced>Ocean Currents (Advanced)<a hidden class=anchor aria-hidden=true href=#ocean-currents-advanced>#</a></h4><p>Warm currents (like the Gulf Stream) can significantly warm coastal regions; cold currents can cool them. Simulating
these adds realism but is often skipped in simpler models.</p><h4 id=orographic-precipitation-rain-shadows>Orographic Precipitation (Rain Shadows)<a hidden class=anchor aria-hidden=true href=#orographic-precipitation-rain-shadows>#</a></h4><p>This is crucial! When moist air carried by wind hits a mountain range, it&rsquo;s forced upwards. As it rises, it cools, and
its capacity to hold moisture decreases. This causes rain or snow to fall on the <em>windward</em> side of the mountains. The
air that descends on the <em>leeward</em> side is now dry, creating a <strong>rain shadow</strong> – an area of low precipitation (often
deserts or steppes) [18]. Any plausible climate simulation <em>must</em> account for this effect.</p><h4 id=simplified-climate-modeling-approach>Simplified Climate Modeling Approach<a hidden class=anchor aria-hidden=true href=#simplified-climate-modeling-approach>#</a></h4><h5 id=temperature-map>Temperature Map<a hidden class=anchor aria-hidden=true href=#temperature-map>#</a></h5><p>Calculate base temperature based on latitude. Adjust for altitude using the lapse rate. Optionally, add modifications
for distance from coast (continentality).</p><h5 id=prevailing-winds-1>Prevailing Winds<a hidden class=anchor aria-hidden=true href=#prevailing-winds-1>#</a></h5><p>Define basic wind directions for different latitude bands (e.g., West in mid-latitudes, East in tropics).</p><h4 id=moisture--precipitation>Moisture & Precipitation<a hidden class=anchor aria-hidden=true href=#moisture--precipitation>#</a></h4><ul><li>Simulate moisture transport. A simple way (used in Mapgen4) is to process cells in order along the wind
direction [18].</li><li>Start with moisture over oceans (evaporation).</li><li>As air moves over land, it might pick up some moisture (less than ocean) or gradually lose it.</li><li>When air hits mountains (rising elevation along wind path), reduce its moisture-holding capacity. If capacity drops
below current moisture, the excess falls as rain/snow on the windward slope [18]. The air passed to the leeward side
is now drier.</li><li>Incorporate general global patterns (e.g., high rainfall near the equator - ITCZ, dry zones around 30° latitude).</li></ul><h4 id=output>Output<a hidden class=anchor aria-hidden=true href=#output>#</a></h4><p>Generate maps of average annual temperature and average annual precipitation.</p><p><em>WorldEngine</em> uses a simplified approach: Temperature from latitude/altitude, Precipitation from temperature plus noise,
with specific erosion/flow steps calculating river discharge and humidity [1]. They explicitly chose <em>not</em> to simulate
seasons to keep complexity manageable, focusing on annual averages [1].</p><p>For higher fidelity (perhaps for sci-fi games aiming for realism), tools like <strong>ExoPlaSim</strong> exist. It&rsquo;s a simplified but
physically based 3D global climate model that can simulate atmospheric circulation, heat transport, and precipitation
for planets with different parameters (rotation, atmosphere, star type) [19] [20]. Running such a model is more
intensive but yields highly realistic climate patterns.</p><h3 id=assigning-biomes>Assigning Biomes<a hidden class=anchor aria-hidden=true href=#assigning-biomes>#</a></h3><p>Once you have temperature and precipitation maps, you can classify different regions into <strong>biomes</strong>. Biomes represent
major ecological communities characterized by dominant plant types and adapted to the prevailing climate (e.g., Tropical
Rainforest, Temperate Grassland, Arctic Tundra, Subtropical Desert).</p><h4 id=biome-classification-schemes>Biome Classification Schemes<a hidden class=anchor aria-hidden=true href=#biome-classification-schemes>#</a></h4><p>The simplest way is to use a lookup diagram based on temperature and precipitation.</p><h5 id=whittaker-biome-diagram>Whittaker Biome Diagram<a hidden class=anchor aria-hidden=true href=#whittaker-biome-diagram>#</a></h5><p>A classic ecological chart plotting average annual temperature vs. average annual precipitation, dividing the space into
major biome types.</p><h5 id=holdridge-life-zones>Holdridge Life Zones<a hidden class=anchor aria-hidden=true href=#holdridge-life-zones>#</a></h5><p>A more detailed system used by <em>WorldEngine</em>. It considers temperature, precipitation, and also <em>potential
evapotranspiration</em> (related to energy availability) to define a finer set of life zones (~38 zones) [1]. WorldEngine
implemented around 40 specific biomes based on this, from &ldquo;Subpolar Dry Tundra&rdquo; to &ldquo;Tropical Rainforest&rdquo; [1].</p><h4 id=algorithm>Algorithm<a hidden class=anchor aria-hidden=true href=#algorithm>#</a></h4><ol><li>For each land cell on your map, get its calculated temperature and precipitation values.</li><li>Use the chosen classification scheme (Whittaker, Holdridge, or a custom one) to determine the corresponding biome
type.</li><li>Assign the biome type to the cell.</li><li>(Optional) Apply smoothing or filtering: A single desert tile in the middle of a rainforest might be a noise
artifact. You could use a majority filter or smooth biome boundaries to make transitions look more natural.</li></ol><h4 id=adding-nuance>Adding Nuance<a hidden class=anchor aria-hidden=true href=#adding-nuance>#</a></h4><p>More advanced systems might consider:</p><h5 id=soil-moisturedrainage>Soil Moisture/Drainage<a hidden class=anchor aria-hidden=true href=#soil-moisturedrainage>#</a></h5><p>A flat, wet area might become a swamp or marsh, even if the temperature/precipitation alone suggest forest. WorldEngine
simulates water flow and permeability to identify potentially marshy areas [1].</p><h5 id=seasonality>Seasonality<a hidden class=anchor aria-hidden=true href=#seasonality>#</a></h5><p>If seasons were simulated, the <em>variation</em> in temperature and precipitation could influence biomes (e.g.,
differentiating deciduous from coniferous forests).</p><h5 id=soil-typefertility>Soil Type/Fertility<a hidden class=anchor aria-hidden=true href=#soil-typefertility>#</a></h5><p>This could emerge from erosion simulation (sediment deposition = fertile) and influence vegetation density or type.</p><p>Biome generation is often the final step in creating the environmental backdrop. It gives the world its visual character
and dictates the types of resources, flora, and fauna players might encounter. The beauty is seeing how the underlying
geology (tectonics creating mountains) influences climate (rain shadows) which in turn dictates the biomes (deserts
behind mountains).</p><h2 id=under-the-hood-map-data-structures>Under the Hood: Map Data Structures<a hidden class=anchor aria-hidden=true href=#under-the-hood-map-data-structures>#</a></h2><p>How is all this complex world information actually stored in memory or on disk? The choice of data structure impacts
performance, flexibility, and the types of simulations that are easy to implement.</p><h3 id=regular-grids-raster-data>Regular Grids (Raster Data)<a hidden class=anchor aria-hidden=true href=#regular-grids-raster-data>#</a></h3><p>The most common approach, especially for heightmaps. Use 2D arrays (or 3D for voxels like <em>Minecraft</em>) to store values (
elevation, temperature, biome ID, etc.) for each cell.</p><ul><li><strong>Pros:</strong> Simple addressing (<code>map[row][col]</code>), efficient neighborhood lookups (crucial for erosion, smoothing,
cellular automata), aligns well with texture mapping for rendering.</li><li><strong>Cons:</strong> Can be memory-intensive for large, high-resolution maps. Represents discrete steps, less natural for smooth
features (though interpolation helps). Spherical representation using grids suffers from distortion (equirectangular)
or edge seams (cube map). Hex grids require special coordinate mapping onto the 2D array.</li></ul><h3 id=graph-based-representations-irregular-meshes>Graph-Based Representations (Irregular Meshes)<a hidden class=anchor aria-hidden=true href=#graph-based-representations-irregular-meshes>#</a></h3><p>Store the world as a network of nodes and edges, often based on Voronoi diagrams or Delaunay triangulations.</p><ul><li>Nodes (e.g., Voronoi cell centers) store properties (elevation, biome).</li><li>Edges represent adjacency and can store information like flow rates (for rivers) or boundary types.</li><li>Red Blob Games&rsquo; Polygon Map Generation tutorials detail storing data at corners, edges, <em>and</em> centers of the Voronoi
polygons for different purposes [10].</li></ul><h4 id=pros>Pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h4><p>Excellent for representing irregular, natural boundaries. Flexible resolution possible. Good for pathfinding or flow
simulations along graph edges.</p><h4 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h4><p>More complex data structures. Neighborhood operations can be slower/more complex than grid lookups. Physics
simulations (like fluid dynamics) are harder to implement on irregular meshes.</p><h3 id=spherical-subdivisions-dggs>Spherical Subdivisions (DGGS)<a hidden class=anchor aria-hidden=true href=#spherical-subdivisions-dggs>#</a></h3><p>For true global representation, use specialized structures like icosahedral geodesic grids (hex/pent meshes) or other
Discrete Global Grid Systems (DGGS). These aim for near-uniform cell size/shape across the sphere with no singularities.</p><h4 id=pros-1>Pros<a hidden class=anchor aria-hidden=true href=#pros-1>#</a></h4><p>Best for accurate global simulations (climate, tectonics). Minimal distortion.</p><h4 id=cons-1>Cons<a hidden class=anchor aria-hidden=true href=#cons-1>#</a></h4><p>Complex implementation, especially handling neighbor relationships and coordinates across the sphere.</p><h3 id=multi-layer-data>Multi-Layer Data<a hidden class=anchor aria-hidden=true href=#multi-layer-data>#</a></h3><p>A generated world isn&rsquo;t just a heightmap. It&rsquo;s a collection of related data layers. A practical system often stores
multiple aligned grids or graphs:</p><ul><li>Elevation map</li><li>Water map (ocean/lake depth, river paths/flow)</li><li>Temperature map</li><li>Precipitation map</li><li>Biome map</li><li>Tectonic plate ID map</li><li>Vegetation density map, etc.</li></ul><p><em>WorldEngine</em>, for example, explicitly stores many such layers per tile [1]. This allows different systems (rendering,
AI, gameplay logic) to access the specific information they need. It also allows exporting different map views (like a
climate map or political map).</p><h3 id=implicitfunctional-representation>Implicit/Functional Representation<a hidden class=anchor aria-hidden=true href=#implicitfunctional-representation>#</a></h3><p>For truly infinite or extremely detailed worlds, storing everything explicitly is impossible. Instead, use functions (
like noise functions) to <em>calculate</em> terrain properties on demand at any given coordinate <code>(x, y, z)</code>. Games like <em>No
Man&rsquo;s Sky</em> rely heavily on generating planet surfaces locally from mathematical formulas as the player approaches,
rather than storing the entire planet&rsquo;s geometry.</p><p>The ideal data structure depends on the scale of the world, the required level of detail, the types of simulations being
run, and performance constraints. Many systems use a combination – perhaps a coarse graph for global structure and finer
grids for local detail.</p><h2 id=learning-from-the-masters-quick-case-studies>Learning from the Masters: Quick Case Studies<a hidden class=anchor aria-hidden=true href=#learning-from-the-masters-quick-case-studies>#</a></h2><p>Let&rsquo;s briefly look at how some notable projects and games combine these techniques:</p><h3 id=worldengine-open-source-generator>WorldEngine (Open Source Generator)<a hidden class=anchor aria-hidden=true href=#worldengine-open-source-generator>#</a></h3><p>A prime example of a full pipeline [1]. Its steps roughly follow our discussion:</p><ol><li>Initial heightmap (Simplex noise).</li><li>Plate tectonics simulation (deforms heightmap, creates mountains).</li><li>Flooding to set sea level.</li><li>Climate simulation (temperature based on latitude/altitude, precipitation based on temp + noise).</li><li>Hydraulic erosion (droplet model, carving rivers).</li><li>Hydrology (calculating river flow, humidity).</li><li>Biome assignment (Holdridge life zones).
It emphasizes the synergy: noise for detail, tectonics for structure, erosion for realism. It outputs multiple data
layers exportable to game engines or GIS tools.</li></ol><h3 id=mapgen4-red-blob-games---web-tool>Mapgen4 (Red Blob Games - Web Tool)<a hidden class=anchor aria-hidden=true href=#mapgen4-red-blob-games---web-tool>#</a></h3><p>Focuses on interactive fantasy map generation [17]. Uses a Voronoi graph structure. Key features:</p><ul><li>Fast, interactive updates (user paints features, map regenerates). Achieved via optimized data structures (e.g.,
spatial partitioning for rivers) and possibly multithreading.</li><li>Simplified climate simulation (wind, orographic rain) driving river formation and biomes.</li><li>Height calculation uses distance fields for smooth blending of user-painted mountains.</li><li>Stylized rendering to look like hand-drawn maps.
It shows how core concepts can be implemented efficiently even in a web browser for interactive use.</li></ul><h3 id=tectonicsjs--pytectonics-carl-davidson-et-al>Tectonics.js / PyTectonics (Carl Davidson et al.)<a hidden class=anchor aria-hidden=true href=#tectonicsjs--pytectonics-carl-davidson-et-al>#</a></h3><p>Focuses specifically on high-fidelity plate tectonics simulation on a sphere [11]. Uses spherical Voronoi meshes and
simulates crust properties, subduction, and velocity fields based on physical principles. Produces very realistic
continental configurations but is computationally intensive. Often used as a <em>starting point</em> – generate the tectonic
base map, then use other tools for erosion and detailing.</p><h3 id=dwarf-fortress-bay-12-games>Dwarf Fortress (Bay 12 Games)<a hidden class=anchor aria-hidden=true href=#dwarf-fortress-bay-12-games>#</a></h3><p>Famous for its incredibly deep simulation. World generation involves:</p><ul><li>Generating a base fractal heightmap.</li><li>Simulating geology (mineral distribution).</li><li>Simulating rainfall, drainage, rivers, and lakes.</li><li>Simulating temperature and biomes.</li><li>Crucially, simulating <em>thousands of years of history</em>: rise and fall of civilizations, wars, mythical beasts, heroes –
all leaving traces on the world and creating rich, unique lore tied to the generated geography [1]. It highlights how
procedural generation can extend far beyond just terrain into history and culture.</li></ul><h3 id=minecraft-mojang-studios>Minecraft (Mojang Studios)<a hidden class=anchor aria-hidden=true href=#minecraft-mojang-studios>#</a></h3><p>Uses chunk-based generation on a conceptually infinite plane. Core terrain uses layered 3D Perlin/Simplex noise. Biomes
influence terrain height variation, decorations (trees, structures), and block types. Features like caves, ravines, and
ore veins are added using separate procedural algorithms within each chunk. Focuses on exploration and emergence from
relatively simple block-based rules.</p><h3 id=no-mans-sky-hello-games>No Man&rsquo;s Sky (Hello Games)<a hidden class=anchor aria-hidden=true href=#no-mans-sky-hello-games>#</a></h3><p>Generates an entire galaxy of planets using deterministic procedural formulas from a single seed. Planet surfaces are
generated on the fly using noise functions and other algorithms as the player approaches. Emphasizes scale, variety, and
seamless exploration from space to ground.</p><p>These examples show there&rsquo;s no single &ldquo;right&rdquo; way. The best approach depends on the game&rsquo;s goals: deep simulation vs.
fast interaction, realism vs. stylized appearance, planetary scale vs. local detail. Often, the most successful systems
are hybrids, carefully combining noise, simulation, and heuristics.</p><h2 id=peeking-into-the-future-where-world-generation-is-headed>Peeking into the Future: Where World Generation is Headed<a hidden class=anchor aria-hidden=true href=#peeking-into-the-future-where-world-generation-is-headed>#</a></h2><p>The field is constantly evolving. Here are some exciting directions and possibilities:</p><h3 id=tighter-integration--coupling>Tighter Integration & Coupling<a hidden class=anchor aria-hidden=true href=#tighter-integration--coupling>#</a></h3><p>Simulating feedback loops. How does massive erosion affect tectonic uplift over millions of years? How does climate
change (e.g., an ice age simulated historically) impact erosion rates and biome distribution? Current systems often run
steps sequentially; future ones might have more interplay.</p><h3 id=more-sophisticated-simulation>More Sophisticated Simulation<a hidden class=anchor aria-hidden=true href=#more-sophisticated-simulation>#</a></h3><p>Incorporating more physics: advanced fluid dynamics for erosion and rivers, better atmospheric modeling for climate (
including seasons, dynamic weather), simulation of volcanism (hotspots like Hawaii), ecological succession modeling (how
biomes evolve and compete over time).</p><h3 id=ai-and-machine-learning>AI and Machine Learning<a hidden class=anchor aria-hidden=true href=#ai-and-machine-learning>#</a></h3><h4 id=generative-models>Generative Models:<a hidden class=anchor aria-hidden=true href=#generative-models>#</a></h4><p>Training AI (like GANs or diffusion models) on real-world terrain or climate data to produce plausible fictional
outputs (e.g., &ldquo;generate a landscape in the style of the Scottish Highlands&rdquo;).</p><h4 id=parameter-tuning>Parameter Tuning<a hidden class=anchor aria-hidden=true href=#parameter-tuning>#</a></h4><p>Using ML to automatically find generation parameters that produce worlds meeting specific design criteria (e.g., &ldquo;a
world with 3 continents, mostly temperate forests, and navigable rivers&rdquo;).</p><h4 id=smart-content-placement>Smart Content Placement<a hidden class=anchor aria-hidden=true href=#smart-content-placement>#</a></h4><p>AI could learn plausible locations for resources, settlements, or points of interest based on the generated environment.</p><h3 id=real-time--interactive-generation>Real-Time & Interactive Generation<a hidden class=anchor aria-hidden=true href=#real-time--interactive-generation>#</a></h3><p>Moving beyond pre-computation. Imagine worlds that visibly evolve based on player actions (e.g., a magical cataclysm
triggers tectonic shifts, large-scale engineering projects alter river flows and climate). This requires highly
efficient, incremental algorithms. Cortial et al.&rsquo;s &ldquo;Procedural Tectonic Planets&rdquo; explored interactive <em>design</em> using
tectonics [12].</p><h3 id=bridging-scales-procedural-zoom>Bridging Scales (Procedural Zoom)<a hidden class=anchor aria-hidden=true href=#bridging-scales-procedural-zoom>#</a></h3><p>Seamlessly connecting large-scale planetary generation with fine-grained local detail. Generate the planet coarsely,
then use different, higher-frequency procedural techniques (or even rule-based systems) to add detail dynamically as the
player zooms in or moves closer, ensuring consistency across scales.</p><h3 id=history-and-culture-simulation>History and Culture Simulation<a hidden class=anchor aria-hidden=true href=#history-and-culture-simulation>#</a></h3><p>Expanding on the <em>Dwarf Fortress</em> model. Tightly integrating the generation of civilizations, historical events, ruins,
and lore with the physical world generation, so the environment shapes the history, and the history leaves visible marks
on the environment.</p><h3 id=unified--modular-frameworks>Unified & Modular Frameworks<a hidden class=anchor aria-hidden=true href=#unified--modular-frameworks>#</a></h3><p>Creating flexible pipelines where developers can easily swap different modules (e.g., choose between fast fake erosion
or slow physical simulation, plug in different climate models) based on project needs. The framework passes world data
layers between modules.</p><p>The ultimate goal? To generate worlds that feel not just visually plausible but <em>alive</em>, with depth, history, and
internal consistency – worlds that tell stories through their very landscapes.</p><h2 id=conclusion-the-art-and-science-of-worldsmithing>Conclusion: The Art and Science of WorldSmithing<a hidden class=anchor aria-hidden=true href=#conclusion-the-art-and-science-of-worldsmithing>#</a></h2><p>Procedural world generation is a captivating blend of art and science. It draws on mathematical noise, geological
simulation, climate science, and ecological principles, all orchestrated by algorithms to conjure digital universes from
little more than a seed value.</p><p>We&rsquo;ve journeyed from the basic concepts of noise and seeds through the intricacies of shaping continents with tectonics,
carving details with erosion, breathing life with climate and biomes, and storing it all efficiently. We&rsquo;ve seen that
the most compelling results often come from a <strong>synthesis of techniques</strong>: the raw detail of noise, the structural
foundation of simulation, and the refining touch of processes like erosion.</p><p>The tools and algorithms are becoming increasingly sophisticated, allowing even small teams or solo developers to create
worlds of staggering scale and complexity. While challenges remain in achieving perfect realism, controllability, and
performance, the future points towards even more powerful and integrated systems, potentially leveraging AI and
real-time dynamics.</p><p>Ultimately, procedural generation empowers creators not just to build worlds, but to become digital worldsmiths,
crafting universes that surprise, delight, and immerse players in ways previously unimaginable. By understanding the
algorithms and harnessing the processes that shape our own planet, we unlock the potential to create countless others,
each waiting to be explored.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>[1] F. Tomassetti, ‘Diving Into Procedural Content Generation, With WorldEngine’, Smashing Magazine. [Online].
Available: <a href=https://www.smashingmagazine.com/2016/03/procedural-content-generation-introduction/>https://www.smashingmagazine.com/2016/03/procedural-content-generation-introduction/</a></li><li>[2] ‘Perlin noise’, Wikipedia. [Online]. Available: <a href=https://en.wikipedia.org/wiki/Perlin_noise>https://en.wikipedia.org/wiki/Perlin_noise</a></li><li>[3] ‘Simplex noise’, Wikipedia. [Online]. Available: <a href=https://en.wikipedia.org/wiki/Simplex_noise>https://en.wikipedia.org/wiki/Simplex_noise</a></li><li>[4] A. J. Patel, ‘Procedural map generation on a sphere’, Red Blob Games. [Online].
Available: <a href=https://www.redblobgames.com/x/1843-planet-generation/>https://www.redblobgames.com/x/1843-planet-generation/</a></li><li>[5] ‘Value noise’, Wikipedia. May 21, 2021. [Online].
Available: <a href="https://en.wikipedia.org/w/index.php?title=Value_noise&amp;oldid=1024311499">https://en.wikipedia.org/w/index.php?title=Value_noise&oldid=1024311499</a></li><li>[6] ‘Brownian surface’, Wikipedia. Oct. 16, 2024. [Online].
Available: <a href="https://en.wikipedia.org/w/index.php?title=Brownian_surface&amp;oldid=1251552796">https://en.wikipedia.org/w/index.php?title=Brownian_surface&oldid=1251552796</a></li><li>[7] F. Gennari, ‘3DWorld: Domain Warping Noise’, 3DWorld. [Online].
Available: <a href=https://3dworldgen.blogspot.com/2017/05/domain-warping-noise.html>https://3dworldgen.blogspot.com/2017/05/domain-warping-noise.html</a></li><li>[8] A. J. Patel, ‘Wraparound hexagon tile maps on a sphere’, Red Blob Games. [Online].
Available: <a href=https://www.redblobgames.com/x/1640-hexagon-tiling-of-sphere/>https://www.redblobgames.com/x/1640-hexagon-tiling-of-sphere/</a></li><li>[9] A. J. Patel, ‘Hexagonal Grids’, Red Blob Games, 2013. [Online].
Available: <a href=https://www.redblobgames.com/grids/hexagons/>https://www.redblobgames.com/grids/hexagons/</a></li><li>[10] A. J. Patel, ‘Polygonal Map Generation, HTML5 version’, Red Blob Games. [Online].
Available: <a href=https://simblob.blogspot.com/2017/09/mapgen2-html5.html>https://simblob.blogspot.com/2017/09/mapgen2-html5.html</a></li><li>[11] C. Davidson, ‘Tectonics.js: 3D Plate Tectonics in your web browser’. [Online].
Available: <a href=https://davidson16807.github.io/tectonics.js/blog/>https://davidson16807.github.io/tectonics.js/blog/</a></li><li>[12] Y. Cortial, A. Peytavie, E. Galin, and E. Guérin, ‘Procedural Tectonic Planets’, Computer Graphics Forum, vol.
38, no. 2, pp. 1–11, May 2019, doi: 10.1111/cgf.13614.</li><li>[13] ‘Unless it’s modeling islands, I find most terrain generators unnatural, at least&mldr;’, Hacker News. [Online].
Available: <a href="https://news.ycombinator.com/item?id=14794095">https://news.ycombinator.com/item?id=14794095</a></li><li>[14] M. Mujtaba, ‘Simulating Hydraulic Erosion of Terrain’, gameidea. [Online].
Available: <a href=https://gameidea.org/2023/12/22/simulating-hydraulic-erosion-of-terrain/>https://gameidea.org/2023/12/22/simulating-hydraulic-erosion-of-terrain/</a></li><li>[15] A. Paris, ‘Terrain Erosion on the GPU’, Make it Shaded. [Online].
Available: <a href=https://makeitshaded.github.io/terrain-erosion/>https://makeitshaded.github.io/terrain-erosion/</a></li><li>[16] B. Benes and R. Forsbach, ‘Layered data representation for visual simulation of terrain erosion’, in Proceedings
Spring Conference on Computer Graphics, IEEE, 2001, pp. 80–86. [Online].
Available: <a href=https://ieeexplore.ieee.org/abstract/document/945341/>https://ieeexplore.ieee.org/abstract/document/945341/</a></li><li>[17] A. J. Patel, mapgen4. (Apr. 2023). TypeScript. [Online]. Available: <a href=https://github.com/redblobgames/mapgen4>https://github.com/redblobgames/mapgen4</a></li><li>[18] A. J. Patel, ‘Mapgen4: rainfall’, Red Blob Games. [Online].
Available: <a href=https://simblob.blogspot.com/2018/09/mapgen4-rainfall.html>https://simblob.blogspot.com/2018/09/mapgen4-rainfall.html</a></li><li>[19] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. Fan, ‘Enabling new science with the ExoPlaSim 3D climate
model’, Bulletin of the American Astronomical Society, vol. 53, no. 3, p. 1140, 2021.</li><li>[20] A. Paradise, E. Macdonald, K. Menou, C. Lee, and B. L. Fan, ‘ExoPlaSim: Extending the planet simulator for
exoplanets’, Monthly Notices of the Royal Astronomical Society, vol. 511, no. 3, pp. 3272–3303, 2022.</li><li>[21] X. Mei, P. Decaudin, and B.-G. Hu, ‘Fast hydraulic erosion simulation and visualization on GPU’, in 15th Pacific
Conference on Computer Graphics and Applications (PG’07), IEEE, 2007, pp. 47–56. Accessed: Mar. 30, 2025. [Online].
Available: <a href=https://ieeexplore.ieee.org/abstract/document/4392715/>https://ieeexplore.ieee.org/abstract/document/4392715/</a></li><li>[22] K. F. Fraedrich, H. Jansen, E. Kirk, U. Luksch, and F. Lunkeit, ‘The Planet Simulator: Towards a user friendly
model’, Meteorologische Zeitschrift, vol. 14, no. 3, pp. 299–304, 2005.</li><li>[23] J. Olsen, ‘Realtime procedural terrain generation’, 2004, Accessed: Mar. 30, 2025. [Online].
Available: <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5961c577478f21707dad53905362e0ec4e6ec644">https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=5961c577478f21707dad53905362e0ec4e6ec644</a></li><li>[24] L. Viitanen, ‘Physically based terrain generation: Procedural heightmap generation using plate tectonics’, 2012,
Accessed: Mar. 30, 2025. [Online].
Available: <a href=https://www.theseus.fi/bitstream/handle/10024/40422/Viitanen_Lauri_2012_03_30.pdf>https://www.theseus.fi/bitstream/handle/10024/40422/Viitanen_Lauri_2012_03_30.pdf</a></li><li>[25] G. Cordonnier et al., ‘Large Scale Terrain Generation from Tectonic Uplift and Fluvial Erosion’, Computer
Graphics Forum, vol. 35, no. 2, pp. 165–175, May 2016, doi: 10.1111/cgf.12820.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/procedural-content-generation/>Procedural-Content-Generation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/video-game-worlds/>Video-Game-Worlds</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/terrain-generation/>Terrain-Generation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/noise-functions/>Noise-Functions</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/perlin-noise/>Perlin-Noise</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/simplex-noise/>Simplex-Noise</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/fractal-noise/>Fractal-Noise</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/heightmaps/>Heightmaps</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/plate-tectonics/>Plate-Tectonics</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/erosion-simulation/>Erosion-Simulation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/hydraulic-erosion/>Hydraulic-Erosion</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/thermal-erosion/>Thermal-Erosion</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/river-networks/>River-Networks</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/climate-simulation/>Climate-Simulation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/biomes/>Biomes</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/map-geometry/>Map-Geometry</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/tiling-systems/>Tiling-Systems</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/data-structures/>Data-Structures</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-development/>Game-Development</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/world-building/>World-Building</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/pcg/>Pcg</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-design/>Game-Design</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/procedural-generation/>Procedural-Generation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/terrain-algorithms/>Terrain-Algorithms</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/noise/>Noise</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/geology-simulation/>Geology-Simulation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/climate-modeling/>Climate-Modeling</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/biome-distribution/>Biome-Distribution</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/voronoi-diagrams/>Voronoi-Diagrams</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/hex-grids/>Hex-Grids</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/worldengine/>Worldengine</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/mapgen4/>Mapgen4</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/tectonics-js/>Tectonics-Js</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/minecraft/>Minecraft</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/no-mans-sky/>No-Mans-Sky</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/dwarf-fortress/>Dwarf-Fortress</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/cplusplus/>Cplusplus</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/future-trends/>Future-Trends</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/interactive-worlds/>Interactive-Worlds</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/digital-worldsmithing/>Digital-Worldsmithing</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/clock-day-hour-week-widget/><span class=title>« Prev</span><br><span>Dev Log: Adding a All-in-One Widget to Breezy Weather - The ClockDayHourWeekWidget Journey</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>