<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules | Tategoto Azarasi</title>
<meta name=keywords content="wasm,wasmtime,cpp,rust,ffi,shared-memory,bidirectional-communication,host-guest,linear-memory,struct-passing,state-management,wasi,runtime,sandboxing,wasmtime-api,c-plus-plus"><meta name=description content="A detailed technical guide on using the Wasmtime runtime to enable complex bidirectional communication, shared memory access, and struct passing between C++ host applications and Rust WebAssembly modules."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules"><meta property="og:description" content="A detailed technical guide on using the Wasmtime runtime to enable complex bidirectional communication, shared memory access, and struct passing between C++ host applications and Rust WebAssembly modules."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-06T16:42:41+08:00"><meta property="article:modified_time" content="2025-04-06T16:42:41+08:00"><meta property="article:tag" content="Wasm"><meta property="article:tag" content="Wasmtime"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Ffi"><meta property="article:tag" content="Shared-Memory"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules"><meta name=twitter:description content="A detailed technical guide on using the Wasmtime runtime to enable complex bidirectional communication, shared memory access, and struct passing between C++ host applications and Rust WebAssembly modules."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules","item":"https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules","name":"Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C\u002b\u002b and Rust Wasm Modules","description":"A detailed technical guide on using the Wasmtime runtime to enable complex bidirectional communication, shared memory access, and struct passing between C++ host applications and Rust WebAssembly modules.","keywords":["wasm","wasmtime","cpp","rust","ffi","shared-memory","bidirectional-communication","host-guest","linear-memory","struct-passing","state-management","wasi","runtime","sandboxing","wasmtime-api","c-plus-plus"],"articleBody":"Today, let’s talk about an increasingly popular technology: WebAssembly (Wasm). However, we won’t confine it to the browser. Instead, we’ll explore how, on the server-side or in desktop applications, we can use the Wasmtime runtime to allow C++ programs to load and execute Rust-compiled Wasm modules. We’ll also delve into enabling complex interactions between them, such as bidirectional function calls, shared memory, passing structs, and even modifying each other’s state.\nA Brief Introduction to WebAssembly and Wasmtime First, let’s briefly explain what WebAssembly is. You can think of it as a portable binary instruction format designed for the modern web. It’s not meant to replace JavaScript but rather to act as a powerful complement, allowing code written in performance-sensitive or low-level languages like C, C++, or Rust to run in web environments (and other Wasm-supporting environments) at near-native speeds. Wasm’s core strengths lie in its sandboxed security model and * platform-agnostic* nature.\nWasmtime, on the other hand, is a standalone, efficient, and secure WebAssembly runtime developed by the Bytecode Alliance (a consortium including companies like Mozilla, Fastly, Intel, and Red Hat). It enables you to run Wasm modules outside the browser – for instance, on servers, in command-line tools, or on embedded devices. Wasmtime provides APIs for various languages, including C, C++, Python, Rust, and Go, making it convenient to integrate Wasm into existing applications.\nWhy Choose a C++ Host + Rust Wasm Combination? This combination offers several compelling advantages:\nMany mature projects have extensive C++ foundations. Wasm allows parts of these projects to be modularized, sandboxed, or exposed as a plugin system without rewriting the core logic. Rust is renowned for its memory and concurrency safety, making it an excellent choice for writing highly reliable Wasm modules. Rust adds another layer of assurance on top of Wasm’s sandbox. Both C++ and Rust are high-performance languages. When compiled to Wasm and executed with a JIT runtime like Wasmtime, they can achieve performance close to native code. Interaction between the Wasm module and the host must occur through explicitly defined interfaces (imports/exports), which helps maintain a clean architecture.\nThe goal of this article is to demonstrate, through a concrete example, how to use Wasmtime’s C++ API to build a C++ host application that loads a Rust-written Wasm module and facilitates various interesting interactions between them.\nCore Concepts: Bridging C++ and Wasm Before diving into the code, we need to understand a few key concepts:\nHost and Guest In this scenario, the C++ application is the host. It is responsible for loading, managing, and running the Wasm module. The Rust-compiled Wasm module is the guest. It runs within the Wasmtime runtime environment provided by the host, constrained by the sandbox.\nWasm Imports and Exports The primary way Wasm modules communicate with the outside world is through imports and exports.\nA Wasm module can export functions, memory, global variables, or tables, making them available for the host or other Wasm modules to call or access. In Rust, we typically use #[no_mangle] pub extern \"C\" to mark functions intended for export.\nA Wasm module can declare which functionalities (usually functions) it needs to import from the host environment. When the host instantiates the Wasm module, it must provide implementations for these imports. In Rust, we use an extern \"C\" { ... } block combined with #[link(wasm_import_module = \"...\")] to declare imports.\nThis import/export mechanism forms the interface contract between the host and the Wasm module.\nLinear Memory Each Wasm instance (usually) has its own linear memory. This is a contiguous, mutable array of bytes that can be read and written by both the Wasm code and the host code. Pointers within Wasm code are essentially offsets ( typically 32-bit or 64-bit integers) into this memory region.\nCrucially, Wasm itself is sandboxed; it cannot directly access the host’s memory. Likewise, the host cannot arbitrarily access variables internal to the Wasm instance. However, the host can obtain access to the Wasm instance’s exported linear memory via Wasmtime APIs (often as a pointer or Span to the memory’s start). Once access is granted, the host can directly read from or write to this memory block. Similarly, Wasm code can indirectly interact with the host’s state or resources by calling host-provided functions (imported functions).\nThis method of data exchange via shared linear memory is central to Wasm interaction. Passing complex data structures ( like C++ structs or Rust structs) is typically achieved by serializing them into this memory and then passing pointers (offsets) to that location.\nWASI (WebAssembly System Interface) WASI is a set of standardized system interfaces designed to allow Wasm modules to interact with the underlying operating system in a secure and portable manner, covering functionalities like file system access, network communication, and standard I/O. While our example doesn’t involve complex file operations, Rust’s standard println! macro relies on underlying standard output capabilities. To make println! within the Wasm module work correctly (printing output to the host’s console), we need to configure and link WASI support in the host.\nBuilding the C++ Host: Setting the Stage with Wasmtime Now, let’s examine what the C++ host side needs to do. For better code organization, we often create a class (e.g., WasmHost) to encapsulate the interaction logic with Wasmtime.\nLoading and Compiling the Wasm Module The first step is to read the contents of the Wasm module file (the .wasm binary) and then use Wasmtime’s Engine to compile it. The Engine acts as Wasmtime’s core compilation and execution engine, responsible for transforming Wasm bytecode into executable machine code. The compilation result is a Module object. This Module object is thread-safe and can be reused by multiple Stores.\n// Pseudo-code example (Actual code in wasm_host.cpp) #include \"wasmtime.hh\" // Include Wasmtime C++ header #include #include #include using namespace wasmtime; // ... WasmHost class definition ... std::vector\u003cuint8_t\u003e WasmHost::readWasmFile() { std::ifstream file(wasm_path_, std::ios::binary | std::ios::ate); // ... Error handling ... std::streamsize size = file.tellg(); file.seekg(0, std::ios::beg); std::vector\u003cuint8_t\u003e buffer(static_cast\u003csize_t\u003e(size)); // ... Read file contents into buffer ... return buffer; } void WasmHost::loadAndCompile() { std::vector\u003cuint8_t\u003e wasm_bytes = readWasmFile(); std::cout \u003c\u003c \"[Host Setup] Compiling WASM module...\" \u003c\u003c std::endl; // engine_ is a member variable of WasmHost, type wasmtime::Engine Result\u003cModule\u003e module_res = Module::compile(engine_, wasm_bytes); if (!module_res) { throw std::runtime_error(\"Module compilation failed: \" + module_res.err().message()); } // module_ is also a WasmHost member, type std::optional module_ = std::move(module_res.ok()); std::cout \u003c\u003c \"[Host Setup] Module compiled successfully.\" \u003c\u003c std::endl; } // Call loadAndCompile() in the WasmHost constructor or an initialization function Engine and Store The Engine handles code compilation, while the Store represents the “world” or “context” of a Wasm instance. All data associated with a Wasm instance, such as its memory, global variables, tables, and the instance itself, belongs to a specific Store. One Engine can be associated with multiple Stores, but a Store is linked to only one Engine. Stores are not thread-safe; typically, one thread corresponds to one Store.\n// WasmHost class members Engine engine_; Store store_; // WasmHost constructor WasmHost::WasmHost(std::string wasm_path) : wasm_path_(std::move(wasm_path)), engine_(), // Create default Engine store_(engine_) // Create Store based on Engine { // ... } Configuring WASI As mentioned, if the Wasm module requires system interactions (like println!), we need to configure WASI for the Store. This is usually done before instantiating the module. Wasmtime provides the WasiConfig class to configure WASI behavior, such as inheriting the host’s standard input/output/error streams, environment variables, and command-line arguments. The configured WasiConfig must be set into the Store’s context.\n// WasmHost::setupWasi() method void WasmHost::setupWasi() { // ... Check if already initialized or configured ... std::cout \u003c\u003c \"[Host Setup] Configuring WASI...\" \u003c\u003c std::endl; WasiConfig wasi; wasi.inherit_stdout(); // Make Wasm's stdout go to host's stdout wasi.inherit_stderr(); // Same for stderr // store_ is a WasmHost member variable auto wasi_set_res = store_.context().set_wasi(std::move(wasi)); if (!wasi_set_res) { throw std::runtime_error(\"Failed setting WASI config in store: \" + wasi_set_res.err().message()); } wasi_configured_ = true; std::cout \u003c\u003c \"[Host Setup] WASI configured for Store.\" \u003c\u003c std::endl; // Also need to define WASI imports in the Linker linkWasiImports(); } // WasmHost::linkWasiImports() method void WasmHost::linkWasiImports() { // ... Check if WASI is configured ... std::cout \u003c\u003c \"[Host Setup] Defining WASI imports in linker...\" \u003c\u003c std::endl; // linker_ is a WasmHost member variable, type wasmtime::Linker auto linker_define_wasi_res = linker_.define_wasi(); if (!linker_define_wasi_res) { throw std::runtime_error(\"Failed defining WASI imports in linker: \" + linker_define_wasi_res.err().message()); } std::cout \u003c\u003c \"[Host Setup] WASI imports defined.\" \u003c\u003c std::endl; } Linker: The Bridge Connecting Host and Wasm The Linker is a Wasmtime utility for resolving module imports and connecting them to host-provided implementations. Before instantiating a module, we need to inform the Linker how to satisfy all of the Wasm module’s import requirements.\nThis involves two main parts:\nLinking WASI Imports: If we’ve configured WASI, we need to call linker_.define_wasi(). This automatically adds implementations for standard WASI functions to the Linker. Linking Custom Host Function Imports: The Wasm module might need to call our custom host functions. We must wrap these C++ functions (or lambdas) into a form Wasmtime understands and register them with the Linker using linker_.define() or linker_.func_wrap(). We specify the corresponding Wasm module name (defined by #[link(wasm_import_module = \"...\")] in the Rust code) and the function name. Defining Host Functions Callable by Wasm This is crucial for enabling Wasm-to-Host calls. We need to write the implementation functions in C++. Their signatures must match the extern \"C\" function declarations in Rust (or be adaptable by Wasmtime C++ API template deduction).\nFor example, if Rust declares imports like this:\n// src/ffi.rs #[link(wasm_import_module = \"env\")] // Module name is \"env\" unsafe extern \"C\" { fn host_log_value(value: i32); fn host_get_shared_value() -\u003e i32; fn host_set_shared_value(value: i32); } Then, in the C++ host, we provide implementations for these three functions and register them with the Linker, associated with the “env” module.\n// host.cpp #include #include // Host state int32_t shared_host_value = 42; // C++ implementation functions void host_log_value_impl_target(int32_t value) { std::cout \u003c\u003c \"[Host Target] host_log_value called by WASM with value: \" \u003c\u003c value \u003c\u003c std::endl; } int32_t host_get_shared_value_impl_target() { std::cout \u003c\u003c \"[Host Target] host_get_shared_value called by WASM. Returning: \" \u003c\u003c shared_host_value \u003c\u003c std::endl; return shared_host_value; } void host_set_shared_value_impl_target(int32_t new_value) { std::cout \u003c\u003c \"[Host Target] host_set_shared_value called by WASM. Old host value: \" \u003c\u003c shared_host_value \u003c\u003c \", New host value: \" \u003c\u003c new_value \u003c\u003c std::endl; shared_host_value = new_value; // Modify host state } // In the WasmHost class or main function, register these using the Linker // (Simplified wrapper function within WasmHost class) template \u003ctypename FuncPtr\u003e void WasmHost::defineHostFunction(std::string_view module_name, std::string_view func_name, FuncPtr func_ptr) { if (is_initialized_) { throw std::logic_error(\"Cannot define host functions after initialization.\"); } std::cout \u003c\u003c \"[Host Setup] Defining host function: \" \u003c\u003c module_name \u003c\u003c \"::\" \u003c\u003c func_name \u003c\u003c \"...\" \u003c\u003c std::endl; // linker_ is a WasmHost member variable auto result = linker_.func_wrap(module_name, func_name, func_ptr); if (!result) { throw std::runtime_error(\"Failed to define host function '\" + std::string(func_name) + \"': \" + result.err().message()); } } // Called from main function host.defineHostFunction(\"env\", \"host_log_value\", host_log_value_impl_target); host.defineHostFunction(\"env\", \"host_get_shared_value\", host_get_shared_value_impl_target); host.defineHostFunction(\"env\", \"host_set_shared_value\", host_set_shared_value_impl_target); linker_.func_wrap() is a convenient template function. It automatically deduces the parameter and return types of the C++ function, converts them to the corresponding Wasm function type, and registers the function. This is often simpler than manually creating a FuncType and using linker_.define().\nInstantiating the Module Once all imports (WASI and custom functions) are defined in the Linker, we can use linker_.instantiate() to create an instance (Instance) of the Wasm module. The instantiation process connects the Wasm code with the host-provided implementations and allocates resources like memory and globals within the Store.\n// WasmHost::instantiateModule() method void WasmHost::instantiateModule() { // ... Check if module_ is valid ... std::cout \u003c\u003c \"[Host Setup] Instantiating module...\" \u003c\u003c std::endl; // store_ is a WasmHost member variable TrapResult\u003cInstance\u003e instance_res = linker_.instantiate(store_.context(), module_.value()); if (!instance_res) { // Handle instantiation error (could be linking error or Wasm start trap) throw std::runtime_error(\"Module instantiation failed: \" + instance_res.err().message()); } // instance_ is a WasmHost member, type std::optional instance_ = std::move(instance_res.ok()); std::cout \u003c\u003c \"[Host Setup] Module instantiated successfully.\" \u003c\u003c std::endl; } Accessing Wasm Linear Memory To exchange complex data with the Wasm module or directly read/write its memory state, the host needs access to the Wasm instance’s linear memory. Wasm modules typically export a memory object named “memory”. We can retrieve it using instance_.get().\n// WasmHost::getMemory() method void WasmHost::getMemory() { // ... Check if instance_ is valid ... std::cout \u003c\u003c \"[Host Setup] Getting exported memory 'memory'...\" \u003c\u003c std::endl; // store_ is a WasmHost member variable auto memory_export_opt = instance_.value().get(store_.context(), \"memory\"); if (memory_export_opt \u0026\u0026 std::holds_alternative\u003cMemory\u003e(*memory_export_opt)) { // memory_ is a WasmHost member, type std::optional memory_ = std::get\u003cMemory\u003e(*memory_export_opt); std::cout \u003c\u003c \"[Host Setup] Found exported memory. Size: \" \u003c\u003c memory_.value().data(store_.context()).size() \u003c\u003c \" bytes.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"[Host Setup] Export 'memory' not found or not a memory. Proceeding without memory access.\" \u003c\u003c std::endl; } } // Get a Span for the memory, providing a view into the memory region Span\u003cuint8_t\u003e WasmHost::getMemorySpan() { if (!is_initialized_ || !memory_.has_value()) { throw std::logic_error(\"Memory not available or host not initialized.\"); } return memory_.value().data(store_.context()); } The obtained wasmtime::Memory object has a data() method that returns a wasmtime::Span (or std::span if C++20 is available). This Span provides direct, low-level access (a pointer and size) to the Wasm linear memory region. With this Span, the host can directly read from and write to the Wasm’s memory.\nBuilding the Wasm Module: Rust’s Safe Territory Now let’s switch to the Rust side and see how the Wasm module is constructed.\nProject Structure Typically, FFI (Foreign Function Interface) related code is placed in a separate module (e.g., src/ffi.rs), while the core, safe Rust logic resides in another module (e.g., src/core.rs or directly within src/lib.rs).\nsrc/lib.rs serves as the library’s entry point. It declares and exports the interfaces from the ffi module needed by the host and might contain or invoke logic from the core module.\n// src/lib.rs mod ffi; // Declare the ffi module pub(crate) mod core; // Declare the internal core module // Re-export functions and types from the FFI layer needed by the host pub use ffi::{ Point, get_plugin_shared_value_ptr, just_add, point_add, simple_add, trigger_host_calls, }; FFI Layer (src/ffi.rs) This is the boundary where Rust interacts with the external world (the C++ host).\nDeclare Host Function Imports: Use extern \"C\" blocks and #[link(wasm_import_module = \"env\")] to inform the Rust compiler and Wasm runtime about external functions provided by a module named “env”. The signatures must match the implementations provided by the C++ host. Note that extern \"C\" blocks are inherently unsafe because calling external functions cannot guarantee Rust’s memory safety rules.\n// src/ffi.rs #[link(wasm_import_module = \"env\")] unsafe extern \"C\" { fn host_log_value(value: i32); fn host_get_shared_value() -\u003e i32; fn host_set_shared_value(value: i32); } Provide Safe Wrappers: To avoid scattering unsafe blocks throughout the business logic, it’s common practice to provide safe Rust wrapper functions for the imported unsafe functions.\n// src/ffi.rs pub fn log_value_from_host(value: i32) { unsafe { host_log_value(value) } // The unsafe call is encapsulated inside } // ... other wrapper functions ... Export Wasm Functions: Use #[no_mangle] to prevent the Rust compiler from mangling function names, and use pub extern \"C\" to specify the C calling convention. This allows the C++ host to find and call these functions by name.\n// src/ffi.rs #[no_mangle] // Prevent name mangling pub extern \"C\" fn just_add(left: u64, right: u64) -\u003e u64 { println!(\"[WASM FFI] just_add called...\"); // Using WASI's println! core::perform_basic_add(left, right) // Call core logic } #[no_mangle] pub extern \"C\" fn trigger_host_calls(input_val: i32) { println!(\"[WASM FFI] trigger_host_calls called...\"); core::perform_host_calls_test(input_val); // Call core logic } // ... other exported functions ... Core Logic Layer (src/core.rs) This is where the actual functionality of the Wasm module is implemented, ideally using safe Rust code. It calls the safe wrappers provided by the FFI layer to interact with the host.\n// src/lib.rs (core module) pub(crate) mod core { use crate::ffi::{ // Import safe wrappers from the FFI layer Point, get_shared_value_from_host, log_value_from_host, set_shared_value_in_host, // ... }; pub fn perform_basic_add(left: u64, right: u64) -\u003e u64 { println!(\"[WASM Core] perform_basic_add: {} + {}\", left, right); left.wrapping_add(right) // Safe addition } pub fn perform_host_calls_test(input_val: i32) { println!(\"[WASM Core] perform_host_calls_test with input: {}\", input_val); // Call host functions (via safe wrappers) log_value_from_host(input_val * 2); let host_val = get_shared_value_from_host(); set_shared_value_in_host(host_val + input_val + 5); // ... } // ... other core logic functions ... } Defining Shared Data Structures If complex data structures need to be passed between C++ and Rust, both sides must agree on the memory layout. In Rust, use the #[repr(C)] attribute to enforce a C-compatible memory layout for the struct. In C++, while compilers often lay out structs sequentially, using #pragma pack(push, 1) and #pragma pack(pop) ensures a packed (no padding) layout for absolute certainty, or ensures consistent alignment between both sides.\n// src/ffi.rs #[repr(C)] // Crucial: guarantees C-compatible layout #[derive(Debug, Copy, Clone, Default)] pub struct Point { pub x: i32, pub y: i32, } // host.cpp #pragma pack(push, 1) // Recommended: ensures packed layout consistent with Rust struct Point { int32_t x; int32_t y; }; #pragma pack(pop) Managing Wasm Internal State Wasm modules sometimes need to maintain their own state. One way is using Rust’s static mut variables. However, accessing static mut requires an unsafe block because it can potentially introduce data races (though the risk is lower in single-threaded Wasm environments, Rust still mandates unsafe).\n// src/ffi.rs static mut PLUGIN_SHARED_VALUE: i32 = 100; // Wasm module's internal state // Internal FFI helper function for safe reading (still needs unsafe block) pub(crate) fn read_plugin_value_internal() -\u003e i32 { unsafe { PLUGIN_SHARED_VALUE } } // Used in the core module // use crate::ffi::read_plugin_value_internal; // let val = read_plugin_value_internal(); If the host needs to modify this state directly, an exported function can return a pointer (memory offset) to the static mut variable.\n// src/ffi.rs #[no_mangle] pub unsafe extern \"C\" fn get_plugin_shared_value_ptr() -\u003e *mut i32 { // Note: Requires `unsafe fn` and an inner `unsafe` block // Use `\u0026raw mut` (newer Rust syntax) or direct cast to get the raw pointer // let ptr = unsafe { \u0026mut PLUGIN_SHARED_VALUE as *mut i32 }; let ptr = { \u0026raw mut PLUGIN_SHARED_VALUE as *mut i32 }; // Using \u0026raw mut avoids Miri complaints println!(\"[WASM FFI] get_plugin_shared_value_ptr() -\u003e {:?}\", ptr); ptr } Warning: Exposing a pointer to internal mutable state directly to the host is a very dangerous practice! It breaks Wasm’s encapsulation, allowing the host to modify internal Wasm data directly, potentially leading to unexpected consequences or violating internal invariants. This pattern should be strongly avoided in practice unless there’s a very specific and controlled reason. A better approach is to modify internal state indirectly and safely via exported functions. It’s shown here primarily to demonstrate the possibilities of memory manipulation.\nDetailed Interaction Patterns Now let’s combine the C++ host and Rust Wasm module code to see how specific interaction flows are implemented.\nPattern One: Host Calls a Simple Wasm Function (just_add) This is the most basic interaction. The host needs to call a pure computation function exported by the Wasm module.\nC++ Host Side (host.cpp):\nGet Function: Obtain a type-safe Wasm function proxy (TypedFunc) using a method encapsulated in WasmHost ( which internally calls instance_.get() and func.typed()). Prepare Arguments: Wrap the C++ uint64_t arguments in an std::tuple. Call: Invoke the Wasm function using the typed_func.call() method. The Wasmtime C++ API handles argument and return value marshalling. Process Result: Extract the std::tuple containing the uint64_t return value from the returned Result. // host.cpp (inside main, Test 1) uint64_t arg1 = 15, arg2 = 27; auto args = std::make_tuple(arg1, arg2); std::cout \u003c\u003c \"[Host Main] Calling Wasm function 'just_add(\" \u003c\u003c arg1 \u003c\u003c \", \" \u003c\u003c arg2 \u003c\u003c \")'...\" \u003c\u003c std::endl; // host is the WasmHost instance // Type deduction: Return is tuple, Params are tuple auto result_tuple = host.callFunction\u003cstd::tuple\u003cuint64_t\u003e, std::tuple\u003cuint64_t, uint64_t\u003e\u003e( \"just_add\", args); // result_tuple is Result","wordCount":"5657","inLanguage":"en","datePublished":"2025-04-06T16:42:41+08:00","dateModified":"2025-04-06T16:42:41+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Deep Dive into Wasmtime: Bidirectional Communication and Memory Sharing Between C++ and Rust Wasm Modules</h1><div class=post-meta><span title='2025-04-06 16:42:41 +0800 +0800'>April 6, 2025</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;5657 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#a-brief-introduction-to-webassembly-and-wasmtime>A Brief Introduction to WebAssembly and Wasmtime</a></li><li><a href=#why-choose-a-c-host--rust-wasm-combination>Why Choose a C++ Host + Rust Wasm Combination?</a></li><li><a href=#core-concepts-bridging-c-and-wasm>Core Concepts: Bridging C++ and Wasm</a><ol><li><a href=#host-and-guest>Host and Guest</a></li><li><a href=#wasm-imports-and-exports>Wasm Imports and Exports</a></li><li><a href=#linear-memory>Linear Memory</a></li><li><a href=#wasi-webassembly-system-interface>WASI (WebAssembly System Interface)</a></li></ol></li><li><a href=#building-the-c-host-setting-the-stage-with-wasmtime>Building the C++ Host: Setting the Stage with Wasmtime</a><ol><li><a href=#loading-and-compiling-the-wasm-module>Loading and Compiling the Wasm Module</a></li><li><a href=#engine-and-store>Engine and Store</a></li><li><a href=#configuring-wasi>Configuring WASI</a></li><li><a href=#linker-the-bridge-connecting-host-and-wasm>Linker: The Bridge Connecting Host and Wasm</a></li><li><a href=#defining-host-functions-callable-by-wasm>Defining Host Functions Callable by Wasm</a></li><li><a href=#instantiating-the-module>Instantiating the Module</a></li><li><a href=#accessing-wasm-linear-memory>Accessing Wasm Linear Memory</a></li></ol></li><li><a href=#building-the-wasm-module-rusts-safe-territory>Building the Wasm Module: Rust&rsquo;s Safe Territory</a><ol><li><a href=#project-structure>Project Structure</a></li><li><a href=#ffi-layer-srcffirs>FFI Layer (<code>src/ffi.rs</code>)</a></li><li><a href=#core-logic-layer-srccorers>Core Logic Layer (<code>src/core.rs</code>)</a></li><li><a href=#defining-shared-data-structures>Defining Shared Data Structures</a></li><li><a href=#managing-wasm-internal-state>Managing Wasm Internal State</a></li></ol></li><li><a href=#detailed-interaction-patterns>Detailed Interaction Patterns</a><ol><li><a href=#pattern-one-host-calls-a-simple-wasm-function-just_add>Pattern One: Host Calls a Simple Wasm Function (<code>just_add</code>)</a></li><li><a href=#pattern-two-wasm-calls-host-functions-trigger_host_calls>Pattern Two: Wasm Calls Host Functions (<code>trigger_host_calls</code>)</a></li><li><a href=#pattern-three-sharing-structs-via-memory-point_add>Pattern Three: Sharing Structs via Memory (<code>point_add</code>)</a></li><li><a href=#pattern-four-host-directly-readswrites-wasm-internal-state>Pattern Four: Host Directly Reads/Writes Wasm Internal State</a></li><li><a href=#pattern-five-wasm-verifies-internal-state-change-by-host>Pattern Five: Wasm Verifies Internal State Change by Host</a></li></ol></li><li><a href=#key-takeaways-and-considerations>Key Takeaways and Considerations</a></li><li><a href=#conclusion>Conclusion</a></li></ol></nav></div></details></div><div class=post-content><p>Today, let&rsquo;s talk about an increasingly popular technology: WebAssembly (Wasm). However, we won&rsquo;t confine it to the
browser. Instead, we&rsquo;ll explore how, on the server-side or in desktop applications, we can use the Wasmtime runtime to
allow C++ programs to load and execute Rust-compiled Wasm modules. We&rsquo;ll also delve into enabling complex interactions
between them, such as bidirectional function calls, shared memory, passing structs, and even modifying each other&rsquo;s
state.</p><h2 id=a-brief-introduction-to-webassembly-and-wasmtime>A Brief Introduction to WebAssembly and Wasmtime<a hidden class=anchor aria-hidden=true href=#a-brief-introduction-to-webassembly-and-wasmtime>#</a></h2><p>First, let&rsquo;s briefly explain what WebAssembly is. You can think of it as a portable binary instruction format designed
for the modern web. It&rsquo;s not meant to replace JavaScript but rather to act as a powerful complement, allowing code
written in performance-sensitive or low-level languages like C, C++, or Rust to run in web environments (and other
Wasm-supporting environments) at near-native speeds. Wasm&rsquo;s core strengths lie in its <strong>sandboxed</strong> security model and *
<em>platform-agnostic</em>* nature.</p><p>Wasmtime, on the other hand, is a <strong>standalone, efficient, and secure</strong> WebAssembly runtime developed by the Bytecode
Alliance (a consortium including companies like Mozilla, Fastly, Intel, and Red Hat). It enables you to run Wasm modules
outside the browser – for instance, on servers, in command-line tools, or on embedded devices. Wasmtime provides APIs
for various languages, including C, C++, Python, Rust, and Go, making it convenient to integrate Wasm into existing
applications.</p><h2 id=why-choose-a-c-host--rust-wasm-combination>Why Choose a C++ Host + Rust Wasm Combination?<a hidden class=anchor aria-hidden=true href=#why-choose-a-c-host--rust-wasm-combination>#</a></h2><p>This combination offers several compelling advantages:</p><p>Many mature projects have extensive C++ foundations. Wasm allows parts of these projects to be modularized, sandboxed,
or exposed as a plugin system without rewriting the core logic. Rust is renowned for its memory and concurrency safety,
making it an excellent choice for writing highly reliable Wasm modules. Rust adds another layer of assurance on top of
Wasm&rsquo;s sandbox. Both C++ and Rust are high-performance languages. When compiled to Wasm and executed with a JIT runtime
like Wasmtime, they can achieve performance close to native code. Interaction between the Wasm module and the host must
occur through explicitly defined interfaces (imports/exports), which helps maintain a clean architecture.</p><p>The goal of this article is to demonstrate, through a concrete example, how to use Wasmtime&rsquo;s C++ API to build a C++
host application that loads a Rust-written Wasm module and facilitates various interesting interactions between them.</p><h2 id=core-concepts-bridging-c-and-wasm>Core Concepts: Bridging C++ and Wasm<a hidden class=anchor aria-hidden=true href=#core-concepts-bridging-c-and-wasm>#</a></h2><p>Before diving into the code, we need to understand a few key concepts:</p><h3 id=host-and-guest>Host and Guest<a hidden class=anchor aria-hidden=true href=#host-and-guest>#</a></h3><p>In this scenario, the C++ application is the <strong>host</strong>. It is responsible for loading, managing, and running the Wasm
module. The Rust-compiled Wasm module is the <strong>guest</strong>. It runs within the Wasmtime runtime environment provided by the
host, constrained by the sandbox.</p><h3 id=wasm-imports-and-exports>Wasm Imports and Exports<a hidden class=anchor aria-hidden=true href=#wasm-imports-and-exports>#</a></h3><p>The primary way Wasm modules communicate with the outside world is through imports and exports.</p><p>A Wasm module can <strong>export</strong> functions, memory, global variables, or tables, making them available for the host or other
Wasm modules to call or access. In Rust, we typically use <code>#[no_mangle] pub extern "C"</code> to mark functions intended for
export.</p><p>A Wasm module can declare which functionalities (usually functions) it needs to <strong>import</strong> from the host environment.
When the host instantiates the Wasm module, it must provide implementations for these imports. In Rust, we use an
<code>extern "C" { ... }</code> block combined with <code>#[link(wasm_import_module = "...")]</code> to declare imports.</p><p>This import/export mechanism forms the interface contract between the host and the Wasm module.</p><h3 id=linear-memory>Linear Memory<a hidden class=anchor aria-hidden=true href=#linear-memory>#</a></h3><p>Each Wasm instance (usually) has its own <strong>linear memory</strong>. This is a contiguous, mutable array of bytes that can be
read and written by both the Wasm code and the host code. Pointers within Wasm code are essentially <strong>offsets</strong> (
typically 32-bit or 64-bit integers) into this memory region.</p><p>Crucially, Wasm itself is sandboxed; it cannot directly access the host&rsquo;s memory. Likewise, the host cannot arbitrarily
access variables internal to the Wasm instance. However, the host <em>can</em> obtain <strong>access</strong> to the Wasm instance&rsquo;s
exported linear memory via Wasmtime APIs (often as a pointer or Span to the memory&rsquo;s start). Once access is granted, the
host can directly read from or write to this memory block. Similarly, Wasm code can indirectly interact with the host&rsquo;s
state or resources by calling host-provided functions (imported functions).</p><p>This method of data exchange via shared linear memory is central to Wasm interaction. Passing complex data structures (
like C++ <code>struct</code>s or Rust <code>struct</code>s) is typically achieved by serializing them into this memory and then passing
pointers (offsets) to that location.</p><h3 id=wasi-webassembly-system-interface>WASI (WebAssembly System Interface)<a hidden class=anchor aria-hidden=true href=#wasi-webassembly-system-interface>#</a></h3><p>WASI is a set of standardized system interfaces designed to allow Wasm modules to interact with the underlying operating
system in a secure and portable manner, covering functionalities like file system access, network communication, and
standard I/O. While our example doesn&rsquo;t involve complex file operations, Rust&rsquo;s standard <code>println!</code> macro relies on
underlying standard output capabilities. To make <code>println!</code> within the Wasm module work correctly (printing output to
the host&rsquo;s console), we need to configure and link WASI support in the host.</p><h2 id=building-the-c-host-setting-the-stage-with-wasmtime>Building the C++ Host: Setting the Stage with Wasmtime<a hidden class=anchor aria-hidden=true href=#building-the-c-host-setting-the-stage-with-wasmtime>#</a></h2><p>Now, let&rsquo;s examine what the C++ host side needs to do. For better code organization, we often create a class (e.g.,
<code>WasmHost</code>) to encapsulate the interaction logic with Wasmtime.</p><h3 id=loading-and-compiling-the-wasm-module>Loading and Compiling the Wasm Module<a hidden class=anchor aria-hidden=true href=#loading-and-compiling-the-wasm-module>#</a></h3><p>The first step is to read the contents of the Wasm module file (the <code>.wasm</code> binary) and then use Wasmtime&rsquo;s <code>Engine</code> to
compile it. The <code>Engine</code> acts as Wasmtime&rsquo;s core compilation and execution engine, responsible for transforming Wasm
bytecode into executable machine code. The compilation result is a <code>Module</code> object. This <code>Module</code> object is thread-safe
and can be reused by multiple <code>Store</code>s.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Pseudo-code example (Actual code in wasm_host.cpp)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;wasmtime.hh&#34;</span><span style=color:#75715e> </span><span style=color:#75715e>// Include Wasmtime C++ header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdexcept&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> wasmtime;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... WasmHost class definition ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> WasmHost<span style=color:#f92672>::</span>readWasmFile() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ifstream file(wasm_path_, std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>binary <span style=color:#f92672>|</span> std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>ate);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Error handling ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>streamsize size <span style=color:#f92672>=</span> file.tellg();
</span></span><span style=display:flex><span>    file.seekg(<span style=color:#ae81ff>0</span>, std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>beg);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> buffer(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(size));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Read file contents into buffer ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> buffer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>loadAndCompile() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> wasm_bytes <span style=color:#f92672>=</span> readWasmFile();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Compiling WASM module...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// engine_ is a member variable of WasmHost, type wasmtime::Engine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Result<span style=color:#f92672>&lt;</span>Module<span style=color:#f92672>&gt;</span> module_res <span style=color:#f92672>=</span> Module<span style=color:#f92672>::</span>compile(engine_, wasm_bytes);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>module_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Module compilation failed: &#34;</span> <span style=color:#f92672>+</span> module_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// module_ is also a WasmHost member, type std::optional&lt;wasmtime::Module&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    module_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(module_res.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Module compiled successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Call loadAndCompile() in the WasmHost constructor or an initialization function
</span></span></span></code></pre></div><h3 id=engine-and-store>Engine and Store<a hidden class=anchor aria-hidden=true href=#engine-and-store>#</a></h3><p>The <code>Engine</code> handles code compilation, while the <code>Store</code> represents the &ldquo;world&rdquo; or &ldquo;context&rdquo; of a Wasm instance. All
data associated with a Wasm instance, such as its memory, global variables, tables, and the instance itself, <strong>belongs</strong>
to a specific <code>Store</code>. One <code>Engine</code> can be associated with multiple <code>Store</code>s, but a <code>Store</code> is linked to only one
<code>Engine</code>. <code>Store</code>s are not thread-safe; typically, one thread corresponds to one <code>Store</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost class members
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Engine engine_;
</span></span><span style=display:flex><span>Store store_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>WasmHost<span style=color:#f92672>::</span>WasmHost(std<span style=color:#f92672>::</span>string wasm_path) <span style=color:#f92672>:</span> wasm_path_(std<span style=color:#f92672>::</span>move(wasm_path)),
</span></span><span style=display:flex><span>                                            engine_(), <span style=color:#75715e>// Create default Engine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                            store_(engine_) <span style=color:#75715e>// Create Store based on Engine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=configuring-wasi>Configuring WASI<a hidden class=anchor aria-hidden=true href=#configuring-wasi>#</a></h3><p>As mentioned, if the Wasm module requires system interactions (like <code>println!</code>), we need to configure WASI for the
<code>Store</code>. This is usually done <strong>before</strong> instantiating the module. Wasmtime provides the <code>WasiConfig</code> class to configure
WASI behavior, such as inheriting the host&rsquo;s standard input/output/error streams, environment variables, and
command-line arguments. The configured <code>WasiConfig</code> must be set into the <code>Store</code>&rsquo;s context.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::setupWasi() method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>setupWasi() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Check if already initialized or configured ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Configuring WASI...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    WasiConfig wasi;
</span></span><span style=display:flex><span>    wasi.inherit_stdout(); <span style=color:#75715e>// Make Wasm&#39;s stdout go to host&#39;s stdout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wasi.inherit_stderr(); <span style=color:#75715e>// Same for stderr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// store_ is a WasmHost member variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> wasi_set_res <span style=color:#f92672>=</span> store_.context().set_wasi(std<span style=color:#f92672>::</span>move(wasi));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>wasi_set_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed setting WASI config in store: &#34;</span> <span style=color:#f92672>+</span> wasi_set_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    wasi_configured_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] WASI configured for Store.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Also need to define WASI imports in the Linker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    linkWasiImports();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost::linkWasiImports() method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>linkWasiImports() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Check if WASI is configured ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Defining WASI imports in linker...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linker_ is a WasmHost member variable, type wasmtime::Linker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> linker_define_wasi_res <span style=color:#f92672>=</span> linker_.define_wasi();
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>linker_define_wasi_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed defining WASI imports in linker: &#34;</span> <span style=color:#f92672>+</span> linker_define_wasi_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] WASI imports defined.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=linker-the-bridge-connecting-host-and-wasm>Linker: The Bridge Connecting Host and Wasm<a hidden class=anchor aria-hidden=true href=#linker-the-bridge-connecting-host-and-wasm>#</a></h3><p>The <code>Linker</code> is a Wasmtime utility for resolving module imports and connecting them to host-provided implementations.
Before instantiating a module, we need to inform the <code>Linker</code> how to satisfy all of the Wasm module&rsquo;s import
requirements.</p><p>This involves two main parts:</p><ol><li><strong>Linking WASI Imports:</strong> If we&rsquo;ve configured WASI, we need to call <code>linker_.define_wasi()</code>. This automatically adds
implementations for standard WASI functions to the <code>Linker</code>.</li><li><strong>Linking Custom Host Function Imports:</strong> The Wasm module might need to call our custom host functions. We must wrap
these C++ functions (or lambdas) into a form Wasmtime understands and register them with the <code>Linker</code> using
<code>linker_.define()</code> or <code>linker_.func_wrap()</code>. We specify the corresponding Wasm module name (defined by
<code>#[link(wasm_import_module = "...")]</code> in the Rust code) and the function name.</li></ol><h3 id=defining-host-functions-callable-by-wasm>Defining Host Functions Callable by Wasm<a hidden class=anchor aria-hidden=true href=#defining-host-functions-callable-by-wasm>#</a></h3><p>This is crucial for enabling Wasm-to-Host calls. We need to write the implementation functions in C++. Their signatures
must match the <code>extern "C"</code> function declarations in Rust (or be adaptable by Wasmtime C++ API template deduction).</p><p>For example, if Rust declares imports like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[link(wasm_import_module = </span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#75715e>)]</span> <span style=color:#75715e>// Module name is &#34;env&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_log_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_get_shared_value</span>() -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_set_shared_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, in the C++ host, we provide implementations for these three functions and register them with the <code>Linker</code>,
associated with the &ldquo;env&rdquo; module.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Host state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> shared_host_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// C++ implementation functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>host_log_value_impl_target</span>(<span style=color:#66d9ef>int32_t</span> value) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_log_value called by WASM with value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int32_t</span> <span style=color:#a6e22e>host_get_shared_value_impl_target</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_get_shared_value called by WASM. Returning: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> shared_host_value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> shared_host_value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>host_set_shared_value_impl_target</span>(<span style=color:#66d9ef>int32_t</span> new_value) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_set_shared_value called by WASM. Old host value: &#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>&lt;&lt;</span> shared_host_value <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, New host value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> new_value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    shared_host_value <span style=color:#f92672>=</span> new_value; <span style=color:#75715e>// Modify host state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In the WasmHost class or main function, register these using the Linker
</span></span></span><span style=display:flex><span><span style=color:#75715e>// (Simplified wrapper function within WasmHost class)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> FuncPtr<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>defineHostFunction(std<span style=color:#f92672>::</span>string_view module_name, std<span style=color:#f92672>::</span>string_view func_name, FuncPtr func_ptr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (is_initialized_) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>logic_error(<span style=color:#e6db74>&#34;Cannot define host functions after initialization.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Defining host function: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> module_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;::&#34;</span> <span style=color:#f92672>&lt;&lt;</span> func_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linker_ is a WasmHost member variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> linker_.func_wrap(module_name, func_name, func_ptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed to define host function &#39;&#34;</span> <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>string(func_name) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;: &#34;</span> <span style=color:#f92672>+</span> result.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Called from main function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_log_value&#34;</span>, host_log_value_impl_target);
</span></span><span style=display:flex><span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_get_shared_value&#34;</span>, host_get_shared_value_impl_target);
</span></span><span style=display:flex><span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_set_shared_value&#34;</span>, host_set_shared_value_impl_target);
</span></span></code></pre></div><p><code>linker_.func_wrap()</code> is a convenient template function. It automatically deduces the parameter and return types of the
C++ function, converts them to the corresponding Wasm function type, and registers the function. This is often simpler
than manually creating a <code>FuncType</code> and using <code>linker_.define()</code>.</p><h3 id=instantiating-the-module>Instantiating the Module<a hidden class=anchor aria-hidden=true href=#instantiating-the-module>#</a></h3><p>Once all imports (WASI and custom functions) are defined in the <code>Linker</code>, we can use <code>linker_.instantiate()</code> to create
an instance (<code>Instance</code>) of the Wasm module. The instantiation process connects the Wasm code with the host-provided
implementations and allocates resources like memory and globals within the <code>Store</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::instantiateModule() method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>instantiateModule() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Check if module_ is valid ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Instantiating module...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store_ is a WasmHost member variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TrapResult<span style=color:#f92672>&lt;</span>Instance<span style=color:#f92672>&gt;</span> instance_res <span style=color:#f92672>=</span> linker_.instantiate(store_.context(), module_.value());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance_res) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>// Handle instantiation error (could be linking error or Wasm start trap)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Module instantiation failed: &#34;</span> <span style=color:#f92672>+</span> instance_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// instance_ is a WasmHost member, type std::optional&lt;wasmtime::Instance&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    instance_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(instance_res.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Module instantiated successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=accessing-wasm-linear-memory>Accessing Wasm Linear Memory<a hidden class=anchor aria-hidden=true href=#accessing-wasm-linear-memory>#</a></h3><p>To exchange complex data with the Wasm module or directly read/write its memory state, the host needs access to the Wasm
instance&rsquo;s linear memory. Wasm modules typically export a memory object named &ldquo;memory&rdquo;. We can retrieve it using
<code>instance_.get()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::getMemory() method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>getMemory() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Check if instance_ is valid ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Getting exported memory &#39;memory&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store_ is a WasmHost member variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> memory_export_opt <span style=color:#f92672>=</span> instance_.value().get(store_.context(), <span style=color:#e6db74>&#34;memory&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (memory_export_opt <span style=color:#f92672>&amp;&amp;</span> std<span style=color:#f92672>::</span>holds_alternative<span style=color:#f92672>&lt;</span>Memory<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span>memory_export_opt)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// memory_ is a WasmHost member, type std::optional&lt;wasmtime::Memory&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        memory_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span>Memory<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span>memory_export_opt);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Found exported memory. Size: &#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> memory_.value().data(store_.context()).size() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; bytes.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Export &#39;memory&#39; not found or not a memory. Proceeding without memory access.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Get a Span&lt;uint8_t&gt; for the memory, providing a view into the memory region
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Span<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> WasmHost<span style=color:#f92672>::</span>getMemorySpan() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>is_initialized_ <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>memory_.has_value()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>logic_error(<span style=color:#e6db74>&#34;Memory not available or host not initialized.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memory_.value().data(store_.context());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The obtained <code>wasmtime::Memory</code> object has a <code>data()</code> method that returns a <code>wasmtime::Span&lt;uint8_t></code> (or
<code>std::span&lt;uint8_t></code> if C++20 is available). This Span provides direct, low-level access (a pointer and size) to the
Wasm linear memory region. With this Span, the host can directly read from and write to the Wasm&rsquo;s memory.</p><h2 id=building-the-wasm-module-rusts-safe-territory>Building the Wasm Module: Rust&rsquo;s Safe Territory<a hidden class=anchor aria-hidden=true href=#building-the-wasm-module-rusts-safe-territory>#</a></h2><p>Now let&rsquo;s switch to the Rust side and see how the Wasm module is constructed.</p><h3 id=project-structure>Project Structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h3><p>Typically, FFI (Foreign Function Interface) related code is placed in a separate module (e.g., <code>src/ffi.rs</code>), while the
core, safe Rust logic resides in another module (e.g., <code>src/core.rs</code> or directly within <code>src/lib.rs</code>).</p><p><code>src/lib.rs</code> serves as the library&rsquo;s entry point. It declares and exports the interfaces from the <code>ffi</code> module needed by
the host and might contain or invoke logic from the <code>core</code> module.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>mod</span> ffi; <span style=color:#75715e>// Declare the ffi module
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>mod</span> core; <span style=color:#75715e>// Declare the internal core module
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Re-export functions and types from the FFI layer needed by the host
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>use</span> ffi::{
</span></span><span style=display:flex><span>    Point, get_plugin_shared_value_ptr, just_add, point_add, simple_add, trigger_host_calls,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=ffi-layer-srcffirs>FFI Layer (<code>src/ffi.rs</code>)<a hidden class=anchor aria-hidden=true href=#ffi-layer-srcffirs>#</a></h3><p>This is the boundary where Rust interacts with the external world (the C++ host).</p><ol><li><p><strong>Declare Host Function Imports:</strong> Use <code>extern "C"</code> blocks and <code>#[link(wasm_import_module = "env")]</code> to inform the
Rust compiler and Wasm runtime about external functions provided by a module named &ldquo;env&rdquo;. The signatures must match
the implementations provided by the C++ host. Note that <code>extern "C"</code> blocks are inherently <code>unsafe</code> because calling
external functions cannot guarantee Rust&rsquo;s memory safety rules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[link(wasm_import_module = </span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_log_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_get_shared_value</span>() -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_set_shared_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>Provide Safe Wrappers:</strong> To avoid scattering <code>unsafe</code> blocks throughout the business logic, it&rsquo;s common practice to
provide safe Rust wrapper functions for the imported <code>unsafe</code> functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log_value_from_host</span>(value: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { host_log_value(value) } <span style=color:#75715e>// The unsafe call is encapsulated inside
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ... other wrapper functions ...
</span></span></span></code></pre></div></li><li><p><strong>Export Wasm Functions:</strong> Use <code>#[no_mangle]</code> to prevent the Rust compiler from mangling function names, and use
<code>pub extern "C"</code> to specify the C calling convention. This allows the C++ host to find and call these functions by
name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span> <span style=color:#75715e>// Prevent name mangling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>just_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add called...&#34;</span>); <span style=color:#75715e>// Using WASI&#39;s println!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    core::perform_basic_add(left, right) <span style=color:#75715e>// Call core logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>trigger_host_calls</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls called...&#34;</span>);
</span></span><span style=display:flex><span>    core::perform_host_calls_test(input_val); <span style=color:#75715e>// Call core logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ... other exported functions ...
</span></span></span></code></pre></div></li></ol><h3 id=core-logic-layer-srccorers>Core Logic Layer (<code>src/core.rs</code>)<a hidden class=anchor aria-hidden=true href=#core-logic-layer-srccorers>#</a></h3><p>This is where the actual functionality of the Wasm module is implemented, ideally using safe Rust code. It calls the
safe wrappers provided by the FFI layer to interact with the host.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs (core module)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>mod</span> core {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::ffi::{ <span style=color:#75715e>// Import safe wrappers from the FFI layer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point,
</span></span><span style=display:flex><span>        get_shared_value_from_host,
</span></span><span style=display:flex><span>        log_value_from_host,
</span></span><span style=display:flex><span>        set_shared_value_in_host,
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_basic_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM Core] perform_basic_add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>        left.wrapping_add(right) <span style=color:#75715e>// Safe addition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_host_calls_test</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM Core] perform_host_calls_test with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Call host functions (via safe wrappers)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        log_value_from_host(input_val <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> host_val <span style=color:#f92672>=</span> get_shared_value_from_host();
</span></span><span style=display:flex><span>        set_shared_value_in_host(host_val <span style=color:#f92672>+</span> input_val <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... other core logic functions ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=defining-shared-data-structures>Defining Shared Data Structures<a hidden class=anchor aria-hidden=true href=#defining-shared-data-structures>#</a></h3><p>If complex data structures need to be passed between C++ and Rust, both sides must agree on the memory layout. In Rust,
use the <code>#[repr(C)]</code> attribute to enforce a C-compatible memory layout for the struct. In C++, while compilers often lay
out structs sequentially, using <code>#pragma pack(push, 1)</code> and <code>#pragma pack(pop)</code> ensures a packed (no padding) layout for
absolute certainty, or ensures consistent alignment between both sides.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[repr(C)]</span> <span style=color:#75715e>// Crucial: guarantees C-compatible layout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> x: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> y: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma pack(push, 1) </span><span style=color:#75715e>// Recommended: ensures packed layout consistent with Rust
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma pack(pop)
</span></span></span></code></pre></div><h3 id=managing-wasm-internal-state>Managing Wasm Internal State<a hidden class=anchor aria-hidden=true href=#managing-wasm-internal-state>#</a></h3><p>Wasm modules sometimes need to maintain their own state. One way is using Rust&rsquo;s <code>static mut</code> variables. However,
accessing <code>static mut</code> requires an <code>unsafe</code> block because it can potentially introduce data races (though the risk is
lower in single-threaded Wasm environments, Rust still mandates <code>unsafe</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// Wasm module&#39;s internal state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Internal FFI helper function for safe reading (still needs unsafe block)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_plugin_value_internal</span>() -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Used in the core module
</span></span></span><span style=display:flex><span><span style=color:#75715e>// use crate::ffi::read_plugin_value_internal;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// let val = read_plugin_value_internal();
</span></span></span></code></pre></div><p>If the host needs to modify this state directly, an exported function can return a <strong>pointer</strong> (memory offset) to the
<code>static mut</code> variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_plugin_shared_value_ptr</span>() -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Note: Requires `unsafe fn` and an inner `unsafe` block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Use `&amp;raw mut` (newer Rust syntax) or direct cast to get the raw pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// let ptr = unsafe { &amp;mut PLUGIN_SHARED_VALUE as *mut i32 };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> { <span style=color:#f92672>&amp;</span>raw <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> }; <span style=color:#75715e>// Using &amp;raw mut avoids Miri complaints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] get_plugin_shared_value_ptr() -&gt; </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>    ptr
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Warning:</strong> Exposing a pointer to internal mutable state directly to the host is a very dangerous practice! It breaks
Wasm&rsquo;s encapsulation, allowing the host to modify internal Wasm data directly, potentially leading to unexpected
consequences or violating internal invariants. This pattern should be strongly avoided in practice unless there&rsquo;s a very
specific and controlled reason. A better approach is to modify internal state indirectly and safely via exported
functions. It&rsquo;s shown here primarily to demonstrate the possibilities of memory manipulation.</p><h2 id=detailed-interaction-patterns>Detailed Interaction Patterns<a hidden class=anchor aria-hidden=true href=#detailed-interaction-patterns>#</a></h2><p>Now let&rsquo;s combine the C++ host and Rust Wasm module code to see how specific interaction flows are implemented.</p><h3 id=pattern-one-host-calls-a-simple-wasm-function-just_add>Pattern One: Host Calls a Simple Wasm Function (<code>just_add</code>)<a hidden class=anchor aria-hidden=true href=#pattern-one-host-calls-a-simple-wasm-function-just_add>#</a></h3><p>This is the most basic interaction. The host needs to call a pure computation function exported by the Wasm module.</p><p><strong>C++ Host Side (<code>host.cpp</code>):</strong></p><ol><li><strong>Get Function:</strong> Obtain a type-safe Wasm function proxy (<code>TypedFunc</code>) using a method encapsulated in <code>WasmHost</code> (
which internally calls <code>instance_.get()</code> and <code>func.typed()</code>).</li><li><strong>Prepare Arguments:</strong> Wrap the C++ <code>uint64_t</code> arguments in an <code>std::tuple</code>.</li><li><strong>Call:</strong> Invoke the Wasm function using the <code>typed_func.call()</code> method. The Wasmtime C++ API handles argument and
return value marshalling.</li><li><strong>Process Result:</strong> Extract the <code>std::tuple</code> containing the <code>uint64_t</code> return value from the returned <code>Result</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (inside main, Test 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint64_t</span> arg1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>, arg2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(arg1, arg2);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;just_add(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg2 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// host is the WasmHost instance
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Type deduction: Return is tuple&lt;u64&gt;, Params are tuple&lt;u64, u64&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> result_tuple <span style=color:#f92672>=</span> host.callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;just_add&#34;</span>, args);
</span></span><span style=display:flex><span><span style=color:#75715e>// result_tuple is Result&lt;std::tuple&lt;uint64_t&gt;, TrapError&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result_tuple) { <span style=color:#75715e>/* Error handling */</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> result_val <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(result_tuple.ok());
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] &#39;just_add&#39; Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_val <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span></code></pre></div><p>Here, <code>host.callFunction</code> is a wrapper within the <code>WasmHost</code> class that hides the details of getting the function,
type-checking, and calling.</p><p><strong>Rust Wasm Side (<code>src/ffi.rs</code> and <code>src/lib.rs::core</code>):</strong></p><ol><li>The <code>#[no_mangle] pub extern "C" fn just_add</code> function is exported.</li><li>It receives two <code>u64</code> parameters and calls <code>core::perform_basic_add</code> for the computation.</li><li>It returns the <code>u64</code> result.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>just_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add called with: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::core::perform_basic_add(left, right); <span style=color:#75715e>// Call core logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, result);
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_basic_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] perform_basic_add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    left.wrapping_add(right) <span style=color:#75715e>// Use safe addition
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This flow demonstrates the basic function call from C++ to Rust and the passing of simple data types.</p><h3 id=pattern-two-wasm-calls-host-functions-trigger_host_calls>Pattern Two: Wasm Calls Host Functions (<code>trigger_host_calls</code>)<a hidden class=anchor aria-hidden=true href=#pattern-two-wasm-calls-host-functions-trigger_host_calls>#</a></h3><p>This pattern reverses the direction: the Wasm module needs to invoke functionality provided by the host.</p><p><strong>C++ Host Side:</strong></p><ol><li><strong>Implement Host Functions:</strong> Such as <code>host_log_value_impl_target</code>, <code>host_get_shared_value_impl_target</code>,
<code>host_set_shared_value_impl_target</code>. These functions can directly access and modify the host&rsquo;s state (like
<code>shared_host_value</code>).</li><li><strong>Register with Linker:</strong> Use <code>host.defineHostFunction("env", ...)</code> to associate these C++ functions with the
function names the Wasm module expects to import from the &ldquo;env&rdquo; module.</li><li><strong>Call Wasm Entry Point:</strong> The host calls the Wasm-exported <code>trigger_host_calls</code> function. This function will, in
turn, trigger calls from within Wasm back to the host functions. Since this Wasm function returns void,
<code>host.callFunctionVoid</code> can be used.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (inside main, Test 2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> trigger_arg <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int32_t</span> host_value_before <span style=color:#f92672>=</span> shared_host_value; <span style=color:#75715e>// Record state before call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;trigger_host_calls(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> trigger_arg <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// host.callFunctionVoid wraps calling void Wasm functions
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Params are tuple&lt;i32&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.callFunctionVoid<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;trigger_host_calls&#34;</span>, std<span style=color:#f92672>::</span>make_tuple(trigger_arg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Returned from &#39;trigger_host_calls&#39;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// Check if host state was modified by Wasm after the call
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ... Compare shared_host_value with the expected value ...
</span></span></span></code></pre></div><p><strong>Rust Wasm Side:</strong></p><ol><li><strong>Declare Imports:</strong> Use <code>extern "C"</code> and <code>#[link(wasm_import_module = "env")]</code> in <code>src/ffi.rs</code> to declare the
functions needed from the host.</li><li><strong>Provide Safe Wrappers:</strong> Offer safe wrappers like <code>log_value_from_host</code>, <code>get_shared_value_from_host</code>,
<code>set_shared_value_in_host</code> in <code>src/ffi.rs</code>.</li><li><strong>Export Trigger Function:</strong> The <code>trigger_host_calls</code> function is exported.</li><li><strong>Call Host Functions:</strong> In <code>core::perform_host_calls_test</code> (called by <code>trigger_host_calls</code>), invoke the C++ host
functions indirectly by calling the safe wrappers from the FFI layer, thereby reading and modifying the host&rsquo;s state.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - Import declarations and safe wrappers (shown previously)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - Export trigger function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>trigger_host_calls</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls called with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>crate</span>::core::perform_host_calls_test(input_val); <span style=color:#75715e>// Call core logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls finished.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core - Core logic calling host functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_host_calls_test</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] perform_host_calls_test with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. Call host_log_value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    log_value_from_host(input_val <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Call host_get_shared_value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> host_val <span style=color:#f92672>=</span> get_shared_value_from_host();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] Received value from host: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, host_val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. Call host_set_shared_value (modifying host state)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> new_host_val <span style=color:#f92672>=</span> host_val.wrapping_add(input_val).wrapping_add(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    set_shared_value_in_host(new_host_val);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This flow demonstrates calls from Wasm to C++ and how Wasm can influence the host&rsquo;s state by invoking host functions.</p><h3 id=pattern-three-sharing-structs-via-memory-point_add>Pattern Three: Sharing Structs via Memory (<code>point_add</code>)<a hidden class=anchor aria-hidden=true href=#pattern-three-sharing-structs-via-memory-point_add>#</a></h3><p>This is a more complex interaction involving passing struct data between the host and Wasm. Since C++ or Rust objects
cannot be passed directly, we utilize the shared linear memory.</p><p><strong>C++ Host Side (<code>host.cpp</code>, Test 3):</strong></p><ol><li><strong>Define Struct:</strong> Define the <code>Point</code> struct, using <code>#pragma pack</code> to ensure a controlled layout.</li><li><strong>Calculate Memory Offsets:</strong> Choose addresses (offsets) within the Wasm linear memory to store the input points
<code>p1</code>, <code>p2</code>, and the result <code>result</code>. Ensure these addresses don&rsquo;t overlap and have sufficient space.</li><li><strong>Write to Memory:</strong> Create C++ <code>Point</code> objects <code>host_p1</code>, <code>host_p2</code>. Use the <code>host.writeMemory()</code> method to copy the
byte representation of these objects into the Wasm linear memory at the corresponding offsets <code>offset_p1</code>,
<code>offset_p2</code>. <code>writeMemory</code> internally gets the memory Span and performs <code>memcpy</code>.</li><li><strong>Call Wasm Function:</strong> Invoke the Wasm-exported <code>point_add</code> function. Importantly, the arguments passed to Wasm are
the previously calculated <strong>memory offsets</strong> (as <code>int32_t</code> pointers).</li><li><strong>Read from Memory:</strong> After the Wasm function executes, the result is written back to <code>offset_result</code> in Wasm memory.
The host uses <code>host.readMemory&lt;Point>()</code> to read the bytes from that offset and interpret them as a C++ <code>Point</code>
object. <code>readMemory</code> also gets the memory Span and uses <code>memcpy</code>.</li><li><strong>Verify Result:</strong> Compare the result read back from Wasm memory with the expected result.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (inside main, Test 3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> size_t point_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(Point);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_p1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2048</span>; <span style=color:#75715e>// Example offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_p2 <span style=color:#f92672>=</span> offset_p1 <span style=color:#f92672>+</span> point_size;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_result <span style=color:#f92672>=</span> offset_p2 <span style=color:#f92672>+</span> point_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Point host_p1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>};
</span></span><span style=display:flex><span>Point host_p2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>70</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Writing points to WASM memory...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// host.writeMemory encapsulates getting Span and memcpy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.writeMemory(offset_p1, host_p1); <span style=color:#75715e>// Write host_p1 to Wasm memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.writeMemory(offset_p2, host_p2); <span style=color:#75715e>// Write host_p2 to Wasm memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;point_add&#39; with offsets...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// Args are offsets (i32), representing pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> point_add_args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(offset_result, offset_p1, offset_p2);
</span></span><span style=display:flex><span>host.callFunctionVoid<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span>, <span style=color:#66d9ef>int32_t</span>, <span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(<span style=color:#e6db74>&#34;point_add&#34;</span>, point_add_args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Reading result struct from WASM memory...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// host.readMemory encapsulates getting Span and memcpy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Point result_point <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>(offset_result); <span style=color:#75715e>// Read result from Wasm memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] &#39;point_add&#39; Result read from memory: { x: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_point.x
</span></span><span style=display:flex><span>          <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, y: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_point.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; }&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// ... Verify result ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Simplified implementation of writeMemory/readMemory in WasmHost:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>writeMemory(<span style=color:#66d9ef>int32_t</span> offset, <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> memory_span <span style=color:#f92672>=</span> getMemorySpan();
</span></span><span style=display:flex><span>    size_t data_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(T);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(offset) <span style=color:#f92672>+</span> data_size <span style=color:#f92672>&gt;</span> memory_span.size()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>out_of_range(<span style=color:#e6db74>&#34;Memory write out of bounds&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(memory_span.data() <span style=color:#f92672>+</span> offset, <span style=color:#f92672>&amp;</span>data, data_size);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T WasmHost<span style=color:#f92672>::</span>readMemory(<span style=color:#66d9ef>int32_t</span> offset) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> memory_span <span style=color:#f92672>=</span> getMemorySpan();
</span></span><span style=display:flex><span>    size_t data_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(T);
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(offset) <span style=color:#f92672>+</span> data_size <span style=color:#f92672>&gt;</span> memory_span.size()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>out_of_range(<span style=color:#e6db74>&#34;Memory read out of bounds&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    T result;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(<span style=color:#f92672>&amp;</span>result, memory_span.data() <span style=color:#f92672>+</span> offset, data_size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Rust Wasm Side:</strong></p><ol><li><strong>Define Struct:</strong> Define the <code>Point</code> struct using <code>#[repr(C)]</code> to ensure layout compatibility with the C++ side.</li><li><strong>Export Function:</strong> Export the <code>point_add</code> function. Its parameters are <code>*mut Point</code> and <code>*const Point</code>. These
receive the 32-bit integers (memory offsets) from the host, which Wasmtime interprets as pointers into the Wasm
linear memory.</li><li><strong>Use <code>unsafe</code>:</strong> Inside the function body, an <code>unsafe</code> block is mandatory to dereference these raw pointers (
<code>*result_ptr</code>, <code>*p1_ptr</code>, <code>*p2_ptr</code>). The Rust compiler cannot guarantee the validity of these pointers (they
originate from the external world), so the developer must take responsibility.</li><li><strong>Perform Operation:</strong> Read the input <code>Point</code> data from the pointers, call <code>core::add_points</code> to compute the result.</li><li><strong>Write to Memory:</strong> Write the calculated <code>result</code> back to the memory location specified by the host using
<code>*result_ptr = result;</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - Point struct definition (shown previously)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - Export point_add function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>point_add</span>(result_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Point, p1_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Point, p2_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Point) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] point_add called with pointers...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#75715e>// Must use unsafe to dereference raw pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> result_ptr.is_null() <span style=color:#f92672>||</span> p1_ptr.is_null() <span style=color:#f92672>||</span> p2_ptr.is_null() {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;[WASM FFI] Error: Received null pointer.&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Dereference input pointers to read data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> p1 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p1_ptr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p2_ptr;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Call core logic for calculation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::core::add_points(p1, p2);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Dereference output pointer to write the result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>*</span>result_ptr <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM FFI] Wrote result to address </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, result_ptr);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core - Core addition logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_points</span>(p1: <span style=color:#a6e22e>Point</span>, p2: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] add_points called with p1: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>, p2: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, p1, p2);
</span></span><span style=display:flex><span>    Point {
</span></span><span style=display:flex><span>        x: <span style=color:#a6e22e>p1</span>.x.wrapping_add(p2.x),
</span></span><span style=display:flex><span>        y: <span style=color:#a6e22e>p1</span>.y.wrapping_add(p2.y),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This pattern forms the basis for complex data exchange between Wasm and the host. Key elements are agreed-upon memory
layouts, access via pointers (offsets), and the correct use of <code>unsafe</code> in Rust.</p><h3 id=pattern-four-host-directly-readswrites-wasm-internal-state>Pattern Four: Host Directly Reads/Writes Wasm Internal State<a hidden class=anchor aria-hidden=true href=#pattern-four-host-directly-readswrites-wasm-internal-state>#</a></h3><p>This pattern demonstrates (but does not recommend) how the host can directly modify internal <code>static mut</code> state within
the Wasm module.</p><p><strong>C++ Host Side (<code>host.cpp</code>, Test 4):</strong></p><ol><li><strong>Get State Pointer:</strong> Call the Wasm-exported <code>get_plugin_shared_value_ptr</code> function. This function returns an
<code>int32_t</code>, representing the offset of <code>PLUGIN_SHARED_VALUE</code> within Wasm linear memory.</li><li><strong>Read Initial Value:</strong> Use <code>host.readMemory&lt;int32_t>()</code> to read the current value of the Wasm state from the
obtained offset.</li><li><strong>Write New Value:</strong> Use <code>host.writeMemory()</code> to write a new <code>int32_t</code> value to that offset.</li><li><strong>Read Again to Verify:</strong> Use <code>host.readMemory&lt;int32_t>()</code> again to confirm the write was successful.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (inside main, Test 4)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> plugin_value_offset <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm &#39;get_plugin_shared_value_ptr&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// getPluginDataOffset wraps calling the Wasm function to get the offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>plugin_value_offset <span style=color:#f92672>=</span> host.getPluginDataOffset(<span style=color:#e6db74>&#34;get_plugin_shared_value_ptr&#34;</span>);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Received offset: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> plugin_value_offset <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (plugin_value_offset <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// Basic validity check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Read Wasm state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int32_t</span> value_from_plugin_before <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;</span>(plugin_value_offset);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Value read from plugin: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value_from_plugin_before <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write new value to Wasm state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> new_value_for_plugin <span style=color:#f92672>=</span> <span style=color:#ae81ff>777</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Writing new value (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> new_value_for_plugin <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;) to plugin state...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    host.writeMemory(plugin_value_offset, new_value_for_plugin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read again to verify
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int32_t</span> value_from_plugin_after <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;</span>(plugin_value_offset);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Value read after host write: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value_from_plugin_after <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Verify value_from_plugin_after == new_value_for_plugin ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost::getPluginDataOffset implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> WasmHost<span style=color:#f92672>::</span>getPluginDataOffset(std<span style=color:#f92672>::</span>string_view func_name) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host] Getting plugin data offset via &#39;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> func_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wasm function takes no args, returns i32 (offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> result_tuple <span style=color:#f92672>=</span> callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(func_name);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result_tuple) { <span style=color:#75715e>/* Error handling */</span> <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> offset <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(result_tuple.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host] Received offset from plugin: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> offset <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> offset;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Rust Wasm Side:</strong></p><ol><li><strong>Define <code>static mut</code> State:</strong> <code>static mut PLUGIN_SHARED_VALUE: i32 = 100;</code></li><li><strong>Export Pointer Function:</strong> Export the <code>get_plugin_shared_value_ptr</code> function, which, within an <code>unsafe</code> context,
returns the raw pointer (offset) to <code>PLUGIN_SHARED_VALUE</code>.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_plugin_shared_value_ptr</span>() -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> { <span style=color:#f92672>&amp;</span>raw <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] get_plugin_shared_value_ptr() -&gt; </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>    ptr
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This pattern showcases the power of memory manipulation but also highlights the potential risks. The host can now
directly interfere with Wasm&rsquo;s internal implementation details.</p><h3 id=pattern-five-wasm-verifies-internal-state-change-by-host>Pattern Five: Wasm Verifies Internal State Change by Host<a hidden class=anchor aria-hidden=true href=#pattern-five-wasm-verifies-internal-state-change-by-host>#</a></h3><p>To confirm that the host&rsquo;s write in Pattern Four actually took effect, we let the Wasm module itself check the value of
that <code>static mut</code> variable.</p><p><strong>C++ Host Side (<code>host.cpp</code>, Test 5):</strong></p><p>After modifying the Wasm state in Pattern Four, call another Wasm function (e.g., <code>simple_add</code>, repurposed here). We
aren&rsquo;t interested in this function&rsquo;s return value, but rather in the log output it generates from within Wasm.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (inside main, Test 5, assuming plugin_value_offset &gt; 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm &#39;simple_add&#39; to verify internal state...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// Call a Wasm function, allowing it to read and print its own state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(<span style=color:#ae81ff>1ULL</span>, <span style=color:#ae81ff>1ULL</span>);
</span></span><span style=display:flex><span>host.callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;simple_add&#34;</span>, args);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Returned from &#39;simple_add&#39;. Check WASM output above.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span></code></pre></div><p><strong>Rust Wasm Side:</strong></p><p>We need to modify the <code>simple_add</code> function (or the core logic it calls, <code>perform_simple_add_and_read_internal_state</code>)
so that before performing its main task, it reads the value of <code>PLUGIN_SHARED_VALUE</code> and prints it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simple_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] simple_add (verification step) called...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>crate</span>::core::perform_simple_add_and_read_internal_state(left, right)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Internal helper function to read static mut (requires unsafe)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_plugin_value_internal</span>() -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_simple_add_and_read_internal_state</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Read and print its own internal state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> current_plugin_val <span style=color:#f92672>=</span> read_plugin_value_internal(); <span style=color:#75715e>// Call FFI helper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[WASM Core] Current plugin&#39;s internal shared value: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#75715e>// Expecting 777 here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        current_plugin_val
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] Performing simple add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... Perform original addition logic ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    left <span style=color:#f92672>+</span> right <span style=color:#75715e>// Assuming simple return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>When the host executes Test 5, we should see output from <code>[WASM Core]</code> in the console showing
<code>Current plugin's internal shared value: 777</code> (or whatever value was written in Pattern Four). This verifies that the
host successfully modified the Wasm&rsquo;s internal state.</p><h2 id=key-takeaways-and-considerations>Key Takeaways and Considerations<a hidden class=anchor aria-hidden=true href=#key-takeaways-and-considerations>#</a></h2><p>This example highlights several crucial points when using Wasmtime for C++/Rust Wasm interactions:</p><ol><li><strong>Clear Interface Definition:</strong> The FFI layer is central. Rust&rsquo;s <code>extern "C"</code> (for both imports and exports) and the
C++ function signatures/linking must match precisely.</li><li><strong>Memory Operations are Fundamental:</strong> Passing complex data relies on reading and writing to Wasm&rsquo;s linear memory.
Understanding pointers as offsets and ensuring consistent data structure layouts (<code>#[repr(C)]</code>, <code>#pragma pack</code>) is
vital.</li><li><strong>Necessity of <code>unsafe</code>:</strong> In the Rust Wasm module, interacting with the FFI and <code>static mut</code> almost inevitably
requires <code>unsafe</code> blocks. Use them cautiously and confine them to the FFI boundary layer whenever possible.</li><li><strong>Careful State Management:</strong> Both the host and Wasm can maintain state. They can influence each other&rsquo;s state
through function calls. Directly exposing pointers to Wasm&rsquo;s internal state to the host, while technically feasible,
breaks encapsulation and should generally be avoided. Prefer managing state through interface functions.</li><li><strong>Role of WASI:</strong> For Wasm modules needing standard I/O or other system interactions (even just <code>println!</code>), the host
must configure and link WASI.</li><li><strong>Wasmtime API:</strong> Wasmtime provides a comprehensive C++ API (<code>wasmtime.hh</code>) featuring core classes like <code>Engine</code>,
<code>Store</code>, <code>Module</code>, <code>Linker</code>, <code>Instance</code>, <code>Memory</code>, <code>Func</code>, <code>TypedFunc</code>, <code>Val</code>, and error handling mechanisms like
<code>Result</code> and <code>Trap</code>. Understanding the roles and relationships of these classes is key to successful implementation.</li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>WebAssembly and Wasmtime offer a powerful way to extend existing applications and achieve high-performance, secure, and
portable modularity. The combination of C++ and Rust leverages C++&rsquo;s ecosystem and performance while benefiting from
Rust&rsquo;s safety guarantees, making it particularly suitable for building plugin systems, handling performance-critical
tasks, or scenarios requiring strong sandboxing.</p><p>While the interaction patterns covered here are quite comprehensive, they represent just the tip of the iceberg.
Wasmtime also supports more advanced features like epoch-based interruption, fuel metering for resource control,
reference types, multiple memories, threading, and more.</p><p>Hopefully, this detailed walkthrough has helped you grasp the fundamental principles and practical methods for enabling
interaction between a C++ host and a Rust Wasm module using Wasmtime. If this area interests you, I encourage you to
experiment and integrate Wasm into your next project!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/wasm/>Wasm</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/wasmtime/>Wasmtime</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/cpp/>Cpp</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/rust/>Rust</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ffi/>Ffi</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/shared-memory/>Shared-Memory</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/bidirectional-communication/>Bidirectional-Communication</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/host-guest/>Host-Guest</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/linear-memory/>Linear-Memory</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/struct-passing/>Struct-Passing</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/state-management/>State-Management</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/wasi/>Wasi</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/runtime/>Runtime</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/sandboxing/>Sandboxing</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/wasmtime-api/>Wasmtime-Api</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/c-plus-plus/>C-Plus-Plus</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/bridging-the-gap-flexible-relationship-management-between-cpp-host-and-rust-wasm-plugins-using-entt/><span class=title>« Prev</span><br><span>Bridging the Gap: Flexible Relationship Management Between C++ Host and Rust WASM Plugins using EnTT</span>
</a><a class=next href=https://tategotoazarasi.github.io/en/posts/weaving-the-web-managing-entity-relationships-in-entt/><span class=title>Next »</span><br><span>Weaving the Web: Managing Entity Relationships in EnTT</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>