<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application | Tategoto Azarasi</title>
<meta name=keywords content="anki,card-templates,demystification,data-extraction,puppeteer,jsdom,ankiconnect,javascript,html,css,nodejs,typescript,web-scraping,data-migration,template-conversion,reverse-engineering,anki-customization,learning-tools,spaced-repetition,automation,scripting,headless-browser,dom-parsing,persistencejs,anki-automation,knowledge-management,data-processing,frontend-techniques"><meta name=description content="Uncover techniques to demystify complex Anki card templates using Puppeteer and JSDOM for accurate data extraction from dynamically rendered content and facilitate migration."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application"><meta property="og:description" content="Uncover techniques to demystify complex Anki card templates using Puppeteer and JSDOM for accurate data extraction from dynamically rendered content and facilitate migration."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-16T21:58:20+08:00"><meta property="article:modified_time" content="2025-05-16T21:58:20+08:00"><meta property="article:tag" content="Anki"><meta property="article:tag" content="Card-Templates"><meta property="article:tag" content="Demystification"><meta property="article:tag" content="Data-Extraction"><meta property="article:tag" content="Puppeteer"><meta property="article:tag" content="Jsdom"><meta name=twitter:card content="summary"><meta name=twitter:title content="Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application"><meta name=twitter:description content="Uncover techniques to demystify complex Anki card templates using Puppeteer and JSDOM for accurate data extraction from dynamically rendered content and facilitate migration."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application","item":"https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application","name":"Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application","description":"Uncover techniques to demystify complex Anki card templates using Puppeteer and JSDOM for accurate data extraction from dynamically rendered content and facilitate migration.","keywords":["anki","card-templates","demystification","data-extraction","puppeteer","jsdom","ankiconnect","javascript","html","css","nodejs","typescript","web-scraping","data-migration","template-conversion","reverse-engineering","anki-customization","learning-tools","spaced-repetition","automation","scripting","headless-browser","dom-parsing","persistencejs","anki-automation","knowledge-management","data-processing","frontend-techniques"],"articleBody":"Anki, a powerful spaced repetition software, is widely appreciated for its flexibility and customizability. Many users download or purchase elaborately designed card templates from the internet. These templates often incorporate complex HTML, CSS, and JavaScript to achieve rich interactive effects and aesthetically pleasing visual presentations. However, this complexity sometimes introduces a challenge: when we need to migrate data, adjust templates, or simply understand how card content is generated, we may find that the data within the template is not directly visible but is instead dynamically rendered via JavaScript or presented in some form of “obfuscation.”\nThis blog post aims to explore a systematic approach to “demystify” such complex Anki cards, extract their core data, and lay the groundwork for subsequent data reuse (for example, migrating to new, simpler templates or performing data analysis). We will use actual card templates encountered (such as a political review template and a driving test question bank template) as examples to progressively analyze the processing flow and key technical points. This article focuses more on the thought process and methodology rather than a direct reiteration of code, hoping that readers, after understanding, can adapt and practice according to their own needs.\nWhy Demystify Card Templates? Before diving into the technical details, it is essential to first clarify the motivations and value detrás de demystifying Anki card templates. A core driving factor is the need for data migration and template replacement. Over long-term Anki usage, users might wish to migrate their accumulated card content from one template to another – perhaps to a self-designed one, a superior community-sourced template, or transitioning from a complex commercial template to a lighter, more personalized one. Direct copy-pasting is often unfeasible because much of the visible content in advanced templates is dynamically generated, underscoring the necessity of extracting the raw, underlying data through demystification.\nAnother significant benefit lies in data cleaning and format unification. Original card data can be intermingled with a considerable amount of HTML tags and inline style information that are not essential to the content itself, or the data formatting across different fields might be inconsistent. By demystifying the cards and extracting relatively pure data, we can more conveniently perform subsequent data cleansing tasks, unify data formats, and establish a solid foundation for further data processing and utilization.\nFurthermore, the structured data extracted through this process opens up broad possibilities for data analysis and reuse. This extracted data can be employed for various statistical analyses, such as examining the distribution покупатели of different question types within a test bank or the frequency of specific knowledge points appearing across cards, thereby providing data-driven insights for adjusting learning strategies. Concurrently, this structured raw data can serve as a valuable resource for generating other forms of learning materials, such as mind maps or summary notes, enabling a multi-dimensional presentation and utilization of the acquired knowledge.\nFrom a technical skill development perspective, the demystification process itself presents a valuable opportunity for * learning template mechanisms and customization*. By meticulously reverse-engineering how data is processed and presented in complex card templates, users can gain a deeper understanding of advanced Anki templating system features, acquiring skills in areas like dynamic JavaScript interactions and sophisticated CSS layout techniques. Such experience is immensely beneficial for users aspiring to independently design and customize more powerful and highly personalized Anki templates in the future.\nFinally, and perhaps most fundamentally, mastering card demystification techniques empowers users to break free from dependency on specific templates. Once the core data is in their own hands, users are no longer tethered to a particular template that might become obsolete due to a lack of maintenance by the author, features no longer meeting their needs, or incompatibility issues with newer Anki versions. Data autonomy translates to greater flexibility and long-term control over one’s learning resources.\nIn essence, the primary goal of card demystification is to revert the “what you see is what you get” card content back to its intrinsic data structure, thereby gaining greater control and understanding over the card’s informational core.\nOverview of the Core Technical Stack To effectively achieve automated demystification of Anki cards, we need to leverage a combination of modern programming tools and libraries. Central to our scripting and development efforts are Node.js and TypeScript. Node.js provides a robust JavaScript runtime environment, making it highly suitable for executing automated scripts either server-side or locally. TypeScript, as a superset of JavaScript, introduces static type checking, which significantly enhances code robustness and maintainability. This is particularly advantageous when dealing with complex data structures and intricate logical flows, as it helps in identifying potential type errors температураly in the development cycle, thereby improving both development efficiency and overall code quality.\nFor simulating browser behavior and executing client-side JavaScript, Puppeteer plays an indispensable role. This Node library, maintained by the Google Chrome team, offers a high-level API that allows us to control Chrome or Chromium browsers programmatically via the DevTools Protocol. In the context of Anki card demystification, Puppeteer’s core value lies in its ability to create an authentic browser environment, typically operating in headless mode, meaning it can execute in the background without a graphical user interface. Many sophisticated Anki card templates extensively use JavaScript to dynamically generate content, manage user interactions, or even perform simple data decryption or transformations. If we were to analyze only the static HTML template files, we would often fail to capture the complete data as it is ultimately presented to the user after JavaScript processing. Puppeteer addresses this by loading the HTML, executing any embedded JavaScript, and simulating the browser’s full rendering pipeline, ultimately providing the final, rendered Document Object Model (DOM) structure. This capability is crucial for handling cards where content is not statically hardcoded into the HTML.\nOnce Puppeteer has completed the page rendering and returned the HTML string containing all dynamically generated content, JSDOM comes into play. JSDOM is a pure JavaScript implementation of the WHATWG DOM and HTML standards, primarily designed to facilitate the use of common web browser objects—such as window, document, and Element —within a Node.js environment. Specifically, JSDOM can parse the HTML string output by Puppeteer and transform it into a complete DOM tree structure. This DOM tree can then be manipulated and queried much like one would operate on the document object in a browser’s developer console, using standard DOM APIs like document.getElementById(), document.getElementsByClassName(), and document.querySelectorAll(). This provides immense convenience for precisely locating and extracting the required data from complex HTML structures.\nLastly, to interact with the Anki application itself—for reading source card data and writing processed new cards—we rely on AnkiConnect. AnkiConnect is a highly practical Anki add-on that exposes a local HTTP service interface, allowing external applications to programmatically control Anki. In our demystification workflow, AnkiConnect primarily undertakes the following responsibilities: First, through its findNotes action, we can batch-retrieve a list of note IDs that require processing, based on criteria such as deck name, tags, or other query parameters. Second, for each note ID, we can use the notesInfo action to obtain comprehensive details about the note, including the raw content of all its fields (e.g., “Question,” “Answer,” “Explanation”) and its associated tags and other metadata. Finally, after the data extraction and transformation are complete, we can utilize the addNote action to send the organized new data, structured according to a specified note type and field mapping, back to Anki, thereby completing the data migration or reformatting process. AnkiConnect, therefore, serves as the critical bridge facilitating data exchange between our automated script and the Anki database.\nGeneral Demystification Workflow Although different Anki card templates vary in complexity and implementation, the fundamental demystification process is largely similar and can be summarized into the following core stages:\nPreparation Phase: Understanding the Source Card This preparatory phase is of paramount importance, directly influencing the efficiency and accuracy of the subsequent automated scripting.\nThe initial step involves identifying the data source. This means precisely specifying the Anki deck containing the cards that need to be processed. Once the target deck is determined, AnkiConnect’s findNotes action can be utilized, constructing a query (e.g., deck:YourDeckName, where YourDeckName must be replaced with the actual deck name) to retrieve a list of unique IDs for all notes within that deck. This list of IDs will serve as the entry point for our automated processing.\nFollowing this, we move to analyzing the card structure, which is key to understanding how data is stored and rendered. It is advisable to select one or more representative card samples from the Anki card browser for meticulous examination. The first task here is to inspect the “Fields” content of these cards. It’s crucial to discern what type of raw data each field stores—for instance, which field holds the question text, which contains the options (paying close attention to potential delimiters between options, such as double vertical bars ||), which field records the correct answer, which provides a detailed explanation or notes, and whether auxiliary fields like question numbers or tags exist. A clear understanding of the source data at the field level forms the basis for subsequent data mapping.\nEven more critically, we need to delve into Anki’s template editor to carefully study the “Front Template,” “Back Template,” and “Styling (CSS).” Regarding the HTML structure, one must observe how data from various fields is embedded into the final HTML document via Anki’s placeholders (e.g., {{FieldName}} or {{cloze:FieldName}}). This helps in comprehending the mapping between raw data and the eventually displayed content.\nHowever, for complex card templates, analyzing JavaScript behavior often represents the core and most challenging aspect of demystification. Many templates leverage JavaScript to achieve dynamic content rendering and interactive effects. It’s necessary to broadly outline the main functionalities of the JavaScript code found within ","wordCount":"5771","inLanguage":"en","datePublished":"2025-05-16T21:58:20+08:00","dateModified":"2025-05-16T21:58:20+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Delving into Anki Cards: Demystifying Templates for Data Extraction and Practical Application</h1><div class=post-meta><span title='2025-05-16 21:58:20 +0800 +0800'>May 16, 2025</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;5771 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#why-demystify-card-templates>Why Demystify Card Templates?</a></li><li><a href=#overview-of-the-core-technical-stack>Overview of the Core Technical Stack</a></li><li><a href=#general-demystification-workflow>General Demystification Workflow</a><ol><li><a href=#preparation-phase-understanding-the-source-card>Preparation Phase: Understanding the Source Card</a></li><li><a href=#core-automation-process>Core Automation Process</a></li><li><a href=#auxiliary-features>Auxiliary Features</a></li></ol></li><li><a href=#experience-with-typical-templates>Experience with Typical Templates</a></li><li><a href=#practical-considerations-and-future-outlook>Practical Considerations and Future Outlook</a></li></ol></nav></div></details></div><div class=post-content><p>Anki, a powerful spaced repetition software, is widely appreciated for its flexibility and customizability. Many users
download or purchase elaborately designed card templates from the internet. These templates often incorporate complex
HTML, CSS, and JavaScript to achieve rich interactive effects and aesthetically pleasing visual presentations. However,
this complexity sometimes introduces a challenge: when we need to migrate data, adjust templates, or simply understand
how card content is generated, we may find that the data within the template is not directly visible but is instead
dynamically rendered via JavaScript or presented in some form of &ldquo;obfuscation.&rdquo;</p><p>This blog post aims to explore a systematic approach to &ldquo;demystify&rdquo; such complex Anki cards, extract their core data,
and lay the groundwork for subsequent data reuse (for example, migrating to new, simpler templates or performing data
analysis). We will use actual card templates encountered (such as a political review template and a driving test
question bank template) as examples to progressively analyze the processing flow and key technical points. This article
focuses more on the thought process and methodology rather than a direct reiteration of code, hoping that readers, after
understanding, can adapt and practice according to their own needs.</p><h2 id=why-demystify-card-templates>Why Demystify Card Templates?<a hidden class=anchor aria-hidden=true href=#why-demystify-card-templates>#</a></h2><p>Before diving into the technical details, it is essential to first clarify the motivations and value detrás de
demystifying Anki card templates. A core driving factor is the need for <strong>data migration and template replacement</strong>.
Over long-term Anki usage, users might wish to migrate their accumulated card content from one template to another –
perhaps to a self-designed one, a superior community-sourced template, or transitioning from a complex commercial
template to a lighter, more personalized one. Direct copy-pasting is often unfeasible because much of the visible
content in advanced templates is dynamically generated, underscoring the necessity of extracting the raw, underlying
data through demystification.</p><p>Another significant benefit lies in <strong>data cleaning and format unification</strong>. Original card data can be intermingled
with a considerable amount of HTML tags and inline style information that are not essential to the content itself, or
the data formatting across different fields might be inconsistent. By demystifying the cards and extracting relatively
pure data, we can more conveniently perform subsequent data cleansing tasks, unify data formats, and establish a solid
foundation for further data processing and utilization.</p><p>Furthermore, the structured data extracted through this process opens up broad possibilities for <strong>data analysis and
reuse</strong>. This extracted data can be employed for various statistical analyses, such as examining the distribution
покупатели of different question types within a test bank or the frequency of specific knowledge points appearing across
cards, thereby providing data-driven insights for adjusting learning strategies. Concurrently, this structured raw data
can serve as a valuable resource for generating other forms of learning materials, such as mind maps or summary notes,
enabling a multi-dimensional presentation and utilization of the acquired knowledge.</p><p>From a technical skill development perspective, the demystification process itself presents a valuable opportunity for *
<em>learning template mechanisms and customization</em>*. By meticulously reverse-engineering how data is processed and
presented in complex card templates, users can gain a deeper understanding of advanced Anki templating system features,
acquiring skills in areas like dynamic JavaScript interactions and sophisticated CSS layout techniques. Such experience
is immensely beneficial for users aspiring to independently design and customize more powerful and highly personalized
Anki templates in the future.</p><p>Finally, and perhaps most fundamentally, mastering card demystification techniques empowers users to <strong>break free from
dependency on specific templates</strong>. Once the core data is in their own hands, users are no longer tethered to a
particular template that might become obsolete due to a lack of maintenance by the author, features no longer meeting
their needs, or incompatibility issues with newer Anki versions. Data autonomy translates to greater flexibility and
long-term control over one&rsquo;s learning resources.</p><p>In essence, the primary goal of card demystification is to revert the &ldquo;what you see is what you get&rdquo; card content back
to its intrinsic data structure, thereby gaining greater control and understanding over the card&rsquo;s informational core.</p><h2 id=overview-of-the-core-technical-stack>Overview of the Core Technical Stack<a hidden class=anchor aria-hidden=true href=#overview-of-the-core-technical-stack>#</a></h2><p>To effectively achieve automated demystification of Anki cards, we need to leverage a combination of modern programming
tools and libraries. Central to our scripting and development efforts are <strong>Node.js and TypeScript</strong>. Node.js provides a
robust JavaScript runtime environment, making it highly suitable for executing automated scripts either server-side or
locally. TypeScript, as a superset of JavaScript, introduces static type checking, which significantly enhances code
robustness and maintainability. This is particularly advantageous when dealing with complex data structures and
intricate logical flows, as it helps in identifying potential type errors температураly in the development cycle,
thereby improving both development efficiency and overall code quality.</p><p>For simulating browser behavior and executing client-side JavaScript, <strong>Puppeteer</strong> plays an indispensable role. This
Node library, maintained by the Google Chrome team, offers a high-level API that allows us to control Chrome or Chromium
browsers programmatically via the DevTools Protocol. In the context of Anki card demystification, Puppeteer&rsquo;s core value
lies in its ability to create an authentic browser environment, typically operating in headless mode, meaning it can
execute in the background without a graphical user interface. Many sophisticated Anki card templates extensively use
JavaScript to dynamically generate content, manage user interactions, or even perform simple data decryption or
transformations. If we were to analyze only the static HTML template files, we would often fail to capture the complete
data as it is ultimately presented to the user after JavaScript processing. Puppeteer addresses this by loading the
HTML, executing any embedded JavaScript, and simulating the browser&rsquo;s full rendering pipeline, ultimately providing the
final, rendered Document Object Model (DOM) structure. This capability is crucial for handling cards where content is
not statically hardcoded into the HTML.</p><p>Once Puppeteer has completed the page rendering and returned the HTML string containing all dynamically generated
content, <strong>JSDOM</strong> comes into play. JSDOM is a pure JavaScript implementation of the WHATWG DOM and HTML standards,
primarily designed to facilitate the use of common web browser objects—such as <code>window</code>, <code>document</code>, and <code>Element</code>
—within a Node.js environment. Specifically, JSDOM can parse the HTML string output by Puppeteer and transform it into a
complete DOM tree structure. This DOM tree can then be manipulated and queried much like one would operate on the
<code>document</code> object in a browser&rsquo;s developer console, using standard DOM APIs like <code>document.getElementById()</code>,
<code>document.getElementsByClassName()</code>, and <code>document.querySelectorAll()</code>. This provides immense convenience for precisely
locating and extracting the required data from complex HTML structures.</p><p>Lastly, to interact with the Anki application itself—for reading source card data and writing processed new cards—we
rely on <strong>AnkiConnect</strong>. AnkiConnect is a highly practical Anki add-on that exposes a local HTTP service interface,
allowing external applications to programmatically control Anki. In our demystification workflow, AnkiConnect primarily
undertakes the following responsibilities: First, through its <code>findNotes</code> action, we can batch-retrieve a list of note
IDs that require processing, based on criteria such as deck name, tags, or other query parameters. Second, for each note
ID, we can use the <code>notesInfo</code> action to obtain comprehensive details about the note, including the raw content of all
its fields (e.g., &ldquo;Question,&rdquo; &ldquo;Answer,&rdquo; &ldquo;Explanation&rdquo;) and its associated tags and other metadata. Finally, after the
data extraction and transformation are complete, we can utilize the <code>addNote</code> action to send the organized new data,
structured according to a specified note type and field mapping, back to Anki, thereby completing the data migration or
reformatting process. AnkiConnect, therefore, serves as the critical bridge facilitating data exchange between our
automated script and the Anki database.</p><h2 id=general-demystification-workflow>General Demystification Workflow<a hidden class=anchor aria-hidden=true href=#general-demystification-workflow>#</a></h2><p>Although different Anki card templates vary in complexity and implementation, the fundamental demystification process is
largely similar and can be summarized into the following core stages:</p><h3 id=preparation-phase-understanding-the-source-card>Preparation Phase: Understanding the Source Card<a hidden class=anchor aria-hidden=true href=#preparation-phase-understanding-the-source-card>#</a></h3><p>This preparatory phase is of paramount importance, directly influencing the efficiency and accuracy of the subsequent
automated scripting.</p><p>The initial step involves <strong>identifying the data source</strong>. This means precisely specifying the Anki deck containing the
cards that need to be processed. Once the target deck is determined, AnkiConnect&rsquo;s <code>findNotes</code> action can be utilized,
constructing a query (e.g., <code>deck:YourDeckName</code>, where <code>YourDeckName</code> must be replaced with the actual deck name) to
retrieve a list of unique IDs for all notes within that deck. This list of IDs will serve as the entry point for our
automated processing.</p><p>Following this, we move to <strong>analyzing the card structure</strong>, which is key to understanding how data is stored and
rendered. It is advisable to select one or more representative card samples from the Anki card browser for meticulous
examination. The first task here is to inspect the &ldquo;Fields&rdquo; content of these cards. It&rsquo;s crucial to discern what type of
raw data each field stores—for instance, which field holds the question text, which contains the options (paying close
attention to potential delimiters between options, such as double vertical bars <code>||</code>), which field records the correct
answer, which provides a detailed explanation or notes, and whether auxiliary fields like question numbers or tags
exist. A clear understanding of the source data at the field level forms the basis for subsequent data mapping.</p><p>Even more critically, we need to delve into Anki&rsquo;s template editor to carefully study the &ldquo;Front Template,&rdquo; &ldquo;Back
Template,&rdquo; and &ldquo;Styling (CSS).&rdquo; Regarding the HTML structure, one must observe how data from various fields is embedded
into the final HTML document via Anki&rsquo;s placeholders (e.g., <code>{{FieldName}}</code> or <code>{{cloze:FieldName}}</code>). This helps in
comprehending the mapping between raw data and the eventually displayed content.</p><p>However, for complex card templates, analyzing <strong>JavaScript behavior</strong> often represents the core and most challenging
aspect of demystification. Many templates leverage JavaScript to achieve dynamic content rendering and interactive
effects. It&rsquo;s necessary to broadly outline the main functionalities of the JavaScript code found within <code>&lt;script></code> tags.
These scripts might be responsible for parsing raw data from placeholders (e.g., splitting an option string delimited by
<code>||</code> into individual options and rendering them as HTML list items), dynamically highlighting options based on user
selection and the correct answer, or controlling the display/hide logic for supplementary learning content like "
Explanation" sections. Understanding how this JavaScript manipulates the DOM and processes data is vital for accurately
simulating the rendering process later with Puppeteer.</p><p>Concurrently, during the analysis of HTML and JavaScript, special attention must be paid to the use of **CSS class names
**. CSS classes that are dynamically added or modified by JavaScript often serve as important clues for identifying card
states, such as user-selected options, correct answers, or incorrect answers. For instance, a template might assign
classes like <code>correct-light</code> or <code>correct</code> to a selected correct option, and <code>wrong-light</code> or <code>wrong</code> to incorrect ones.
Identifying these key CSS class names will greatly assist in accurately extracting information from the rendered HTML
using JSDOM later on.</p><p>Finally, after a thorough understanding of the source card&rsquo;s data composition and rendering logic is achieved, we need
to <strong>determine the extraction targets</strong>. This involves clearly listing the specific data items we wish to extract from
the old cards and how these items will correspond to the fields in the new card template. A well-defined set of targets
will guide the development of our subsequent data extraction and transformation logic.</p><h3 id=core-automation-process>Core Automation Process<a hidden class=anchor aria-hidden=true href=#core-automation-process>#</a></h3><p>Having gained a deep understanding of the source cards in the preparation phase, we can proceed to the <strong>core automation
process</strong>. The central idea of this process is to iterate through the list of note IDs obtained earlier and execute a
standardized series of data extraction and transformation operations for the card represented by each ID.</p><p>For every note ID in the list, the first step in the processing pipeline is to <strong>retrieve the note&rsquo;s information</strong>. We
utilize AnkiConnect&rsquo;s <code>notesInfo</code> action, passing the current note ID as a parameter. AnkiConnect will then return
comprehensive details for that note, typically as an object containing all its fields and their corresponding values,
along with a list of the note&rsquo;s tags. These raw field values form the basis for constructing the HTML document that will
be rendered.</p><p>Next is the task of <strong>building the HTML document for rendering</strong>. This requires having a local HTML template file
prepared beforehand, whose structure should be identical or very similar to the source Anki card&rsquo;s template (
encompassing front, back, and CSS styles). Examples from our previous discussions include <code>pol2.html</code> or <code>jiazhao.html</code>.
Once the field data for the current note is fetched, our script will systematically replace the predefined
placeholders (e.g., <code>{{Question}}</code>, <code>{{Options}}</code>) in this local HTML template file with the actual data. A crucial
detail here is that if placeholders contain special characters, such as colons (common in <code>{{cloze:Question}}</code>), these
characters must be properly escaped when used in regular expressions for replacement to ensure accuracy. For instance,
an <code>{{Options}}</code> placeholder would be replaced with the options string retrieved from the note, which is typically
delimited by <code>||</code>.</p><p>Once the HTML content, now populated with specific note data, has been constructed, the process moves to <strong>dynamic
rendering using Puppeteer</strong>. The script first writes this generated HTML content to a temporary local HTML file. Then,
Puppeteer is launched, and a new headless browser page instance is created. A particularly critical step, especially
when dealing with templates like <code>jiazhao.html</code> that rely on <code>Persistence.js</code> or similar libraries for managing session
state, is to perform necessary environment simulation. Some templates store user preferences or card states (e.g.,
whether to randomize options, whether to display explanations by default) in the Anki WebView&rsquo;s session storage during
user interaction with the front of the card. The back template then reads these settings upon loading to determine how
to present its content. If our automated script attempts to directly render a template containing both front and back
logic (or just the back, expecting it to show the &ldquo;answer revealed&rdquo; state) without first establishing the session state
expected by <code>Persistence.js</code>, certain JavaScript logic dependent on these values might not execute as intended. A common
consequence is that the &ldquo;Explanation&rdquo; section might remain hidden by default.</p><p>To address this, we employ Puppeteer&rsquo;s <code>page.evaluateOnNewDocument()</code> method. This powerful API allows us to inject
custom JavaScript code into the page <em>before</em> any of its own scripts are executed. We can leverage this to create a mock
implementation of the <code>Persistence</code> object within the page&rsquo;s context. This mock object needs to provide the same core
APIs as the real library (such as <code>isAvailable</code>, <code>getItem</code>, <code>setItem</code>, and <code>removeItem</code>) and allow us to preset specific
key-value pairs. For example, we can use code like <code>window.Persistence.setItem('ANKI-SETTINGS-HIDE-NOTES', '0');</code> to
compel the template&rsquo;s script to believe that the user preference is to show the explanation. Similarly, to handle
potential randomization of option order by the front template (which often stores the randomized order in an
<code>ANKI-OPTIONS-ORDER</code> key for the back template to read), we can preset a fixed, non-random order in our mock, such as
<code>window.Persistence.setItem('ANKI-OPTIONS-ORDER', '1,2,3,4');</code> (assuming up to four options displayed in their original
sequence).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Illustrative Puppeteer script snippet
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>evaluateOnNewDocument</span>(() =&gt; {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mockStore</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>	window.<span style=color:#a6e22e>Persistence</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>isAvailable</span><span style=color:#f92672>:</span> () =&gt; <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>getItem</span>    <span style=color:#f92672>:</span> (<span style=color:#a6e22e>key</span>) =&gt; <span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>?</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>]) <span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>setItem</span>    <span style=color:#f92672>:</span> (<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>) =&gt; {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ... other necessary methods like removeItem, clear, getAllKeys, if used by the template script
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	};
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Force display of explanations
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	window.<span style=color:#a6e22e>Persistence</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;ANKI-SETTINGS-HIDE-NOTES&#39;</span>, <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Set a default option order to ensure correct parsing and highlighting on the back
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// This value should align with the original option order expected by the card&#39;s front template JS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// or simply be set to &#39;1,2,3,4...&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Persistence</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;ANKI-OPTIONS-ORDER&#39;</span>, <span style=color:#e6db74>&#39;1,2,3,4&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>After injecting the mocked <code>Persistence</code> environment, we use <code>page.goto()</code> to load the temporary HTML file containing
the card&rsquo;s data. Since JavaScript execution within templates is often asynchronous, **waiting for rendering to complete
** is an indispensable part of this stage. We must ensure that all relevant JavaScript logic has finished executing and
the DOM has been updated to its final state before attempting to extract content. This can be achieved in several ways.
One approach is to use <code>page.waitForSelector()</code>, which pauses execution until one or more elements matching a critical
CSS selector appear in the DOM. For example, on the back of the card, we might wait for CSS classes indicating option
states (such as correct, incorrect, or should-have-been-selected, e.g., <code>.correct-light</code>, <code>.should-select-light</code>,
<code>.correct</code>) to be applied to the option <code>&lt;li></code> elements. Another method is <code>page.waitForFunction()</code>, which can wait for
a JavaScript function executed in the page&rsquo;s context to return a truthy value; for instance, we could write a function
to check if the container for the &ldquo;Explanation&rdquo; has been populated with text. Once these waiting conditions are met,
signifying that the page has fully rendered, we can invoke <code>page.content()</code> to retrieve the complete HTML content string
of the rendered page.</p><p>Upon obtaining the rendered HTML, the next step is to <strong>parse the HTML and extract structured data using JSDOM</strong>. We
pass the HTML string returned by Puppeteer to JSDOM&rsquo;s constructor, which generates a <code>document</code> object that can be
manipulated within our Node.js environment using APIs highly compatible with those found in web browsers. Leveraging
this <code>document</code> object, we can employ standard DOM traversal and query methods to precisely extract the desired data.
For example, the <strong>question text</strong> is typically found within an element possessing a specific class name (e.g.,
<code>.question</code>), and may require further processing such as removing a question number prefix. For <strong>option texts</strong>, we
would first locate the parent container holding all options (e.g., a <code>div</code> with <code>id="back-options"</code>), then iterate
through each child element representing an option (e.g., <code>&lt;li class="option"></code>), extracting its <code>textContent</code>. The
extraction of the <strong>correct answer(s)</strong> relies on inspecting these option elements for CSS classes that denote &ldquo;correct&rdquo;
or &ldquo;should-be-selected&rdquo; states. Based on these classes and the original order of the options in the list (which can be
determined by analyzing their index within the parent container or via option-specific IDs if present), we can determine
the corresponding letter identifiers (A, B, C, D, etc.). If the card involves multiple correct answers, we need to
concatenate the letters of all correctly marked options. <strong>Explanations or remarks</strong> are also usually housed within
specific container elements (e.g., the <code>&lt;div id="notes-wrapper">&lt;div class="notes-container">...&lt;/div>&lt;/div></code> structure
in the <code>jiazhao.html</code> template); we can extract their <code>innerHTML</code> if preserving HTML formatting is desired, or
<code>textContent</code> for plain text. As for <strong>tag information</strong>, this can be directly obtained from the <code>notesInfo</code> object
fetched via AnkiConnect in the initial step. After extracting various data pieces, <strong>data cleansing</strong> is often
necessary, which might involve removing leading/trailing whitespace using <code>.trim()</code> or stripping out unwanted HTML tags,
depending on the requirements of the target field.</p><p>Once all required data has been successfully extracted from the rendered HTML and properly cleaned, we proceed to *
<em>constructing the new note data</em>*. At this stage, we need to organize the extracted and processed data into a JavaScript
object that conforms to the field structure of the target Anki note type and the requirements of AnkiConnect&rsquo;s <code>addNote</code>
action. This object will specify the target deck name (<code>deckName</code>), the target note type name (<code>modelName</code>), and a
<code>fields</code> object. The keys of the <code>fields</code> object will be the field names in the target note type, and their values will
be the data we just extracted and prepared. An example structure might look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>deckName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;My New Driving Test Deck&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modelName</span>
</span></span><span style=display:flex><span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;Driving Test MCQ - Simplified&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fields</span>
</span></span><span style=display:flex><span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;QuestionStem&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedQuestionText</span>,
</span></span><span style=display:flex><span>			<span style=color:#e6db74>&#34;OptionA&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedOptions</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#e6db74>&#34;OptionB&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedOptions</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#e6db74>&#34;CorrectAnswer&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedCorrectAnswerLetters</span>, <span style=color:#75715e>// e.g., &#34;A&#34;, &#34;BC&#34;, &#34;ACD&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#e6db74>&#34;DetailedExplanation&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedRemarkText</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tags</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>originalTagsArray</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The final step in the core loop is <strong>adding the new note to Anki</strong>. We invoke AnkiConnect&rsquo;s <code>addNote</code> action, passing
the meticulously constructed note data object from the previous step as an argument. AnkiConnect will then process this
request and create a new, clean, and properly structured card in Anki. With this, the demystification and data
migration (or restructuring) process for a single source note is complete.</p><h3 id=auxiliary-features>Auxiliary Features<a hidden class=anchor aria-hidden=true href=#auxiliary-features>#</a></h3><p>When designing and implementing automated scripts for Anki card demystification, beyond the core logic of data
extraction and transformation, it&rsquo;s prudent to incorporate certain <strong>auxiliary features</strong> to enhance the script&rsquo;s
robustness and user experience. Among these, a <strong>comprehensive error handling and logging mechanism</strong> is indispensable.
Throughout the process of iterating over and processing each card, various unforeseen errors can occur due to the
involvement of multiple components such as file I/O, network communication (via AnkiConnect), browser automation (via
Puppeteer), and DOM parsing (via JSDOM). Examples include network connection interruptions, Puppeteer operation
timeouts, or failures in JSDOM parsing due to an inability to find expected DOM elements. Therefore, within the main
processing loop, the handling of each note should be encapsulated within a <code>try...catch</code> block. Upon catching an
exception, the script should ideally not terminate immediately. Instead, it should log the ID of the note that caused
the error, along with detailed error information (including error type, message, and potentially a stack trace) to a
dedicated log file. The advantage of this approach is that even if some cards fail to process, the script can continue
attempting to process the remaining ones. After the entire batch is finished, the user can review the log file to
identify problematic cards and perform targeted troubleshooting or necessary manual intervention. Furthermore, for
certain predictable, non-critical &ldquo;minor issues,&rdquo; such as a source note missing a non-essential field, we can opt to log
a warning message and gracefully skip processing that particular note, rather than halting the entire script due to such
minor imperfections.</p><p>On the other hand, providing <strong>clear progress indicators and an estimated time of arrival (ETA)</strong> is equally important
for improving the user experience, especially when dealing with large decks containing hundreds or thousands of cards,
as the entire automation process can be quite time-consuming. If the script provides no feedback during its execution,
users might become anxious or uncertain about whether it is still running correctly. To mitigate this, we can output
real-time processing progress to the console, for instance, by displaying messages like &ldquo;Processing note X / Y&mldr;&rdquo;,
where X is the number of notes processed so far, and Y is the total number of notes. Taking this a step further, we can
also dynamically estimate the remaining processing time (ETA) based on the average time taken to process the notes
completed thus far. A practical way to do this is to record the total time elapsed since the script began processing
notes. After each note is processed, calculate the average processing time per note (total elapsed time / number of
notes processed) and then multiply this average by the number of remaining notes. This yields a rough estimate of the
time still required. Presenting this ETA information (e.g., formatted as &ldquo;Estimated time remaining: HH:MM:SS&rdquo;) alongside
the progress update gives the user a clear expectation and makes the waiting period less opaque.</p><h2 id=experience-with-typical-templates>Experience with Typical Templates<a hidden class=anchor aria-hidden=true href=#experience-with-typical-templates>#</a></h2><p>In previous discussions and practical applications, we&rsquo;ve encountered several representative types of Anki card
templates, each presenting distinct challenges during the demystification process. Taking a **political review template
** (<code>pol2.html</code>) as an example, its primary characteristic was relatively straightforward data substitution, where card
content was largely populated by filling Anki field placeholders within the HTML structure. However, the template&rsquo;s
complexity was concentrated in its JavaScript component, particularly in how it handled options. The &ldquo;Options&rdquo; field in
the source data was typically a single string with options concatenated by a specific delimiter (e.g.,
<code>A. xxx||B. yyy</code>). The template&rsquo;s internal JavaScript was responsible for parsing this string, dynamically rendering it
into multiple distinct <code>&lt;div class="option"></code> HTML elements, each corresponding to a single choice. Consequently, when
automating the processing of such templates, the critical factor was ensuring that Puppeteer could correctly and
completely execute this client-side JavaScript. Once the JavaScript execution finished and the DOM structure was
updated, JSDOM could then be used to extract the specific text content of each option from the rendered HTML, and to
determine the correct answer(s) by inspecting the CSS classes applied to the option elements. Additionally, the display
logic for the &ldquo;Explanation&rdquo; section in this template might also be controlled by JavaScript. In such cases, using
<code>waitForSelector</code> to wait for CSS class names indicating option states (like highlighting) to appear often indirectly
ensures that the explanation content (if loaded synchronously or immediately after the option logic) has also been
correctly rendered onto the page, making it available for JSDOM to capture.</p><p>Another category of templates, exemplified by the <strong>driving test question bank template</strong> (<code>jiazhao.html</code>), introduced a
higher degree of complexity, primarily due to its use of libraries like <code>Persistence.js</code>. As mentioned earlier in the
technical stack overview, <code>Persistence.js</code> (or similar libraries) is commonly used to store user preferences or card
states within the Anki WebView&rsquo;s session, such as whether the user prefers options to be randomized, or if the "
Explanation" section should be displayed by default when the back of the card is revealed. The main <strong>challenge</strong> posed
by this mechanism is that if our automated script attempts to directly render a template containing the complete front
and back logic (or only the back part, expecting it to be in an &ldquo;answer revealed&rdquo; state) without first establishing the
session state that <code>Persistence.js</code> relies upon (particularly crucial settings like <code>ANKI-SETTINGS-HIDE-NOTES</code>), then
the JavaScript on the back of the template (e.g., a <code>prepareNotes()</code> function) might not inject the &ldquo;Explanation&rdquo;
content into the designated DOM container (such as <code>.notes-container</code>) because it cannot read the expected setting
value. This would directly prevent us from extracting the &ldquo;Explanation&rdquo; information using JSDOM later.</p><p>The <strong>core solution</strong> for such templates that depend on session storage is to leverage Puppeteer&rsquo;s
<code>page.evaluateOnNewDocument()</code> method. This powerful API allows us to inject custom JavaScript code into the target HTML
page <em>before</em> any of its native scripts are executed. We can use this opportunity to create a mock implementation of the
<code>Persistence</code> object within the page&rsquo;s context. This mock object needs to emulate the key API interfaces provided by the
real <code>Persistence.js</code> library, such as <code>isAvailable()</code>, <code>getItem()</code>, and <code>setItem()</code>. By using this mock object, we can
proactively call <code>Persistence.setItem('ANKI-SETTINGS-HIDE-NOTES', '0');</code>, thereby &ldquo;tricking&rdquo; the card&rsquo;s back-side script
into believing that the user has set the preference to display explanations. As a result, the template&rsquo;s JavaScript
logic will render the &ldquo;Explanation&rdquo; content into the DOM as intended, enabling JSDOM to extract it successfully.</p><p>Furthermore, another noteworthy detail concerning the driving test template is the handling of <strong>option order</strong>. Its
front template&rsquo;s <code>showFrontOptions</code> function might include logic to randomize the display order of options, storing this
randomized sequence (typically as a comma-separated string of the options&rsquo; original indices, e.g., <code>2,1,4,3</code>) in a
<code>Persistence</code> key named <code>ANKI-OPTIONS-ORDER</code>. The <code>getOptionObjs</code> function on the card&rsquo;s back template then reads this
stored order when rendering options and highlighting the correct answer, to ensure that the option text correctly
corresponds to its original answer identifier (e.g., numbers 1, 2, 3, 4 mapping to A, B, C, D). In our <code>render</code>
function, because we usually render the entire HTML template (potentially with merged front and back logic) at once
using Puppeteer, and because we can preset a deterministic, non-random option order (e.g., simply setting it to
<code>'1,2,3,4'</code>, representing display in the original order) for <code>ANKI-OPTIONS-ORDER</code> during the <code>evaluateOnNewDocument</code>
phase, this guarantees a stable and predictable relationship between the option content and its correctness evaluation
during the back-card rendering. This facilitates the accurate extraction of formatted options and answers.</p><h2 id=practical-considerations-and-future-outlook>Practical Considerations and Future Outlook<a hidden class=anchor aria-hidden=true href=#practical-considerations-and-future-outlook>#</a></h2><p>When actually writing and applying Anki card demystification scripts, adhering to certain key **practical considerations
** can significantly enhance work efficiency and the reliability of the results. Foremost among these is <strong>thorough
template analysis</strong>. Before rushing into coding, it is imperative to dedicate sufficient time within the Anki
environment, utilizing browser developer tools, to deeply dissect the target card template&rsquo;s HTML structure, the dynamic
changing patterns of CSS class names, and, crucially, the execution logic of its JavaScript. A full comprehension of how
data flows and is transformed within the template is fundamental to subsequently programming precise rendering logic in
Puppeteer and accurate extraction rules in JSDOM.</p><p>Secondly, an <strong>iterative approach to building and testing</strong> is a highly effective strategy for managing complexity. It
is advisable to break down the entire demystification process into several independently verifiable modules or steps.
For instance, one might first focus on correctly reading the local HTML template file and ensuring accurate substitution
of field values (obtained from AnkiConnect) into the template&rsquo;s placeholders. Once this is achieved, the Puppeteer
component can be tested to confirm its ability to load the data-filled HTML, execute the embedded JavaScript correctly,
and output the final rendered HTML to the Node.js console. Building on this, JSDOM parsing and data extraction functions
can be developed and tested in isolation, using the HTML string output by Puppeteer as input, to validate the precise
extraction of elements like the question, individual options, correct answers, and explanations. Only after these core
data processing stages have been thoroughly debugged should one integrate the AnkiConnect APIs for a complete end-to-end
test of reading source notes from Anki and writing new notes back. This divide-and-conquer, incremental iteration
methodology facilitates rapid problem identification and reduces debugging complexity. Furthermore, when crafting JSDOM
extraction logic, striving for <strong>robust CSS selectors</strong> is a factor deserving special attention. To make the script as
resilient as possible to minor future modifications in the source card template, one should prioritize using ID
selectors (if unique IDs are provided for key elements in the template), as IDs generally offer high stability. In the
absence of IDs, an attempt should be made to use sufficiently specific and unique combinations of class names, or to
construct CSS selectors incorporating tag names, attributes, and other features to minimize the risk of the extraction
script failing due to the template author altering an unrelated class name or HTML hierarchy. It&rsquo;s best to avoid overly
generic selectors or those heavily reliant on deep DOM level nesting.</p><p>Regarding the content extracted from cards, it&rsquo;s necessary to carefully <strong>differentiate and handle the boundary between
HTML and plain text</strong>. Anki fields such as questions, options, and explanations may inherently contain HTML tags, for
example, <code>&lt;img></code> tags for images, <code>&lt;br></code> for line breaks, or <code>&lt;strong></code> and <code>&lt;em></code> for text emphasis. When extracting
the text from these fields using JSDOM, a decision must be made whether the target field ultimately requires plain text
or should retain some or all of the HTML formatting. For plain text, the element&rsquo;s <code>textContent</code> property can be used;
to preserve HTML structure, <code>innerHTML</code> should be employed. This choice should be guided by how your new card template
is designed to render these fields. Additionally, for Anki-specific placeholders like <code>{{cloze:FieldName}}</code>, if the
target note type is also a cloze deletion type, this Anki-recognized format should be preserved when constructing the
field data for the new note. However, if the corresponding field in the target note type is just a regular text field,
then you might need to extract either the elided portion from the source text (i.e., the content between <code>c1::</code> and
<code>}}</code>) or the full text after removing the cloze markers.</p><p>Given that the entire demystification workflow heavily relies on asynchronous operations—such as file I/O (e.g., using
<code>fs/promises</code>), Puppeteer&rsquo;s page loading and interactions, and AnkiConnect&rsquo;s network requests—<strong>proficient and correct
management of asynchronous operations</strong> is crucial. In modern JavaScript/TypeScript development, a_sync/await_ syntax
should be preferentially used for handling Promises, as this makes the logic of asynchronous code more closely resemble
the intuitive flow of synchronous code, thereby greatly enhancing code readability and maintainability. It is imperative
to ensure that all asynchronous operations are properly <code>await</code>-ed to guarantee that steps execute in the intended
sequence, thus avoiding elusive logical errors that can arise from improperly handled asynchronous callbacks.</p><p>In terms of resource management, an often-overlooked detail is <strong>prompt resource cleanup</strong>. Each time Puppeteer is
launched, it creates a browser instance that consumes system resources. Therefore, within the script&rsquo;s <code>try...finally</code>
blocks, or at least before the script terminates, it is essential to ensure that the <code>browser.close()</code> method is called
to shut down the Puppeteer-created browser instance. This releases the memory and processes it was using, preventing
resource exhaustion issues that could arise from long-running scripts or multiple script executions.</p><p>Finally, concerning the <strong>use of temporary files</strong>, writing the data-filled HTML content to a local temporary file and
then having Puppeteer load this file via the <code>file://</code> protocol is a simple and effective strategy. The benefits include
avoiding the need to pass excessively long HTML strings directly to Puppeteer and facilitating debugging by allowing
easy inspection of the actual page content that Puppeteer is loading. After processing is complete, one might consider
adding logic to clean up these temporary files. Although in most scenarios, scripts will overwrite the same temporary
file on each note&rsquo;s processing, so active cleanup might not be strictly necessary to prevent disk space issues,
maintaining a tidy environment is generally good practice.</p><p>Adhering to these considerations and techniques will contribute to a smoother and more reliable execution of Anki card
demystification tasks.</p><p><strong>In summary</strong>, by skillfully combining Puppeteer&rsquo;s dynamic rendering capabilities with JSDOM&rsquo;s robust DOM parsing, we
can effectively &ldquo;unwrap&rdquo; complex Anki cards that rely on JavaScript for content generation. The crux lies in
understanding the source card&rsquo;s rendering mechanisms and then either precisely simulating or appropriately bypassing
these mechanisms within the Puppeteer environment to obtain the final, structured HTML. For libraries like
<code>Persistence.js</code> that maintain state across an Anki WebView session, leveraging Puppeteer&rsquo;s <code>page.evaluateOnNewDocument</code>
method to perform necessary environment mocking is a key technique to ensure that target content, such as the "
Explanation" on the card&rsquo;s back, is correctly rendered and becomes extractable.</p><p>This demystification process not only provides users with an effective means to extract and migrate valuable learning
data but also serves as an excellent opportunity to deepen one&rsquo;s understanding of web front-end technologies (HTML, CSS,
JavaScript, DOM interaction) and advanced Anki template customization mechanisms. While this article has offered a
general framework and solutions to specific template challenges, every Anki card template can possess its unique
intricacies and complexities. Therefore, when tackling any specific demystification task, patient and meticulous
analysis, rigorous step-by-step debugging, and the flexibility to adapt to actual circumstances are indispensable
qualities for achieving success.</p><p><strong>Looking ahead</strong>, once the aforementioned demystification workflows and technical methods are further refined and
abstracted, they hold considerable potential to be encapsulated into more universal, user-friendly tools or libraries.
Such tools could significantly lower the technical barrier for a_verage_ Anki users to manage complex card templates.
Furthermore, these techniques could be integrated into larger Anki auxiliary management systems or add-ons, thereby
providing Anki users with even more powerful capabilities for managing and repurposing their knowledge bases, ultimately
enhancing Anki&rsquo;s effectiveness as a personalized learning platform.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/anki/>Anki</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/card-templates/>Card-Templates</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/demystification/>Demystification</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/data-extraction/>Data-Extraction</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/puppeteer/>Puppeteer</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/jsdom/>Jsdom</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ankiconnect/>Ankiconnect</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/javascript/>Javascript</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/html/>Html</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/css/>Css</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/nodejs/>Nodejs</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/typescript/>Typescript</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/web-scraping/>Web-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/data-migration/>Data-Migration</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/template-conversion/>Template-Conversion</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/reverse-engineering/>Reverse-Engineering</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/anki-customization/>Anki-Customization</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/learning-tools/>Learning-Tools</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/spaced-repetition/>Spaced-Repetition</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/automation/>Automation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/scripting/>Scripting</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/headless-browser/>Headless-Browser</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/dom-parsing/>Dom-Parsing</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/persistencejs/>Persistencejs</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/anki-automation/>Anki-Automation</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/knowledge-management/>Knowledge-Management</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/data-processing/>Data-Processing</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/frontend-techniques/>Frontend-Techniques</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/troubleshooting-a-stubborn-dmic-on-a-thinkbook-16-g7-plus-asp-with-linux/><span class=title>« Prev</span><br><span>Troubleshooting a Stubborn DMIC on a ThinkBook 16 G7+ ASP with Linux</span>
</a><a class=next href=https://tategotoazarasi.github.io/en/posts/automating-online-grading-with-tampermonkey-and-ai/><span class=title>Next »</span><br><span>Automating Online Grading with Tampermonkey and AI</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>