<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation | Tategoto Azarasi</title>
<meta name=keywords content="python,icalendar,ics,json,api,reverse-engineering,web-scraping,developer-tools,network-analysis,http-request,curl,automation,data-conversion,timetable,calendar-import,student-project,time-management,university-life"><meta name=description content="Learn how to reverse-engineer a university&rsquo;s private timetable API using browser developer tools and write a Python script to convert the JSON data into a universally importable iCalendar (.ics) file for your personal calendar."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tategotoazarasi.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tategotoazarasi.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tategotoazarasi.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tategotoazarasi.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.tategotoazarasi.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/><link rel=alternate hreflang=zh href=https://blog.tategotoazarasi.me/zh/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation"><meta property="og:description" content="Learn how to reverse-engineer a university’s private timetable API using browser developer tools and write a Python script to convert the JSON data into a universally importable iCalendar (.ics) file for your personal calendar."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-09T22:32:33+00:00"><meta property="article:modified_time" content="2025-11-09T22:32:33+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Icalendar"><meta property="article:tag" content="Ics"><meta property="article:tag" content="Json"><meta property="article:tag" content="Api"><meta property="article:tag" content="Reverse-Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation"><meta name=twitter:description content="Learn how to reverse-engineer a university&rsquo;s private timetable API using browser developer tools and write a Python script to convert the JSON data into a universally importable iCalendar (.ics) file for your personal calendar."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tategotoazarasi.me/en/posts/"},{"@type":"ListItem","position":2,"name":"Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation","item":"https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation","name":"Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation","description":"Learn how to reverse-engineer a university\u0026rsquo;s private timetable API using browser developer tools and write a Python script to convert the JSON data into a universally importable iCalendar (.ics) file for your personal calendar.","keywords":["python","icalendar","ics","json","api","reverse-engineering","web-scraping","developer-tools","network-analysis","http-request","curl","automation","data-conversion","timetable","calendar-import","student-project","time-management","university-life"],"articleBody":"As a student, effective time management is paramount. I’ve always wanted to integrate my university timetable into the personal calendar application I use daily, allowing me to view all my commitments in one unified place. However, the official university timetable system offers no “Export to Calendar” feature or any form of .ics subscription link. To complicate matters further, accessing the timetable webpage requires navigating a complex multi-factor authentication (MFA) process.\nInitially, this seemed like a daunting automation challenge. Any script attempting to simulate a login would be made incredibly complex and fragile by the MFA requirement. However, I soon had a crucial realization: once the timetable is set for a semester, it almost never changes. This meant I probably didn’t need a dynamic, real-time synchronization solution. A one-time, manual import process would be perfectly sufficient.\nThis insight completely reframed my approach to the problem. The challenge shifted from “how to automate a complex login flow” to “how to, after one successful login, retrieve the entire semester’s data and convert it into a standard calendar format.” This blog post will document my entire process for solving this problem, from investigating network requests and analyzing the API to finally generating an .ics file using a Python script.\nDive into Browser Developer Tools My first step was to understand how the timetable data is loaded onto the webpage. Most modern web applications are built with a front-end/back-end separation, where the front-end page is merely a shell. The necessary data is fetched from a back-end server via asynchronous API calls (usually AJAX) and then rendered dynamically. If this were the case, I could potentially find this API directly, bypassing the need for complex page scraping.\nI opened the university’s timetable page and pressed F12 (or Option + Command + I on macOS) to launch the browser’s developer tools. This is a powerful suite of tools that allows for the inspection and debugging of nearly every aspect of a webpage. I focused my attention on the “Network” tab, which records all communication between the browser and the server.\nTo trigger a data-loading event, I needed to perform an action on the page. The timetable defaults to showing the current week’s schedule. I clicked the “Next Week” button to advance to the following week’s timetable. As expected, a new network request immediately appeared in the Network panel.\nAfter filtering through the various requests, I zeroed in on one named get-events. Its URL looked something like this:\nhttps://timetable.university.ac.uk/services/get-events?start=2025-11-10T00%3A00%3A00\u0026end=2025-11-15T00%3A00%3A00\u0026_=1762726887267\nThis discovery was exhilarating. The request’s name (get-events) and its parameters were highly suggestive. I immediately began to dissect every detail of this request.\nAnalyzing the Request Method and URL Structure The request used the GET method, which is the standard HTTP method for a client to request data from a server. The URL structure was also quite intuitive:\nHostname: timetable.university.ac.uk, the domain of the timetable service. Path: /services/get-events, clearly indicating that this endpoint’s function is to retrieve events. Query Parameters: The part of the URL after the ?, which held the keys to unlocking the data. Deconstructing the Query Parameters I examined the query parameters closely. They were formatted as key=value pairs, separated by \u0026.\nstart=2025-11-10T00%3A00%3A00: The value for the start parameter was URL-encoded. After decoding, it became 2025-11-10T00:00:00. This was clearly the start time of the first day (Monday) of the week I had requested. The T separates the date and time, which conforms to the ISO 8601 date-time standard.\nend=2025-11-15T00%3A00%3A00: Similarly, the end parameter decoded to 2025-11-15T00:00:00. Interestingly, this appeared to be the start of Saturday for that week, not the end of Friday. This suggested that the API’s time range query likely uses a left-closed, right-open interval [start, end), meaning it includes the start timestamp but excludes the end timestamp. This is a very common practice in programming for handling time ranges, as it avoids many off-by-one errors and boundary condition issues.\n_=1762726887267: This parameter looked like a Unix timestamp (in milliseconds). This is a common technique known as a “cache buster.” Browsers and proxy servers may cache the results of GET requests. By appending a unique, time-based parameter to each request, it ensures that every request is treated as new and distinct, forcing the server to return fresh data instead of a cached version. For my use case, this parameter probably wasn’t strictly necessary, but to faithfully replay the request, it was best to keep it.\nThe Importance of Request Headers Beyond the URL, the HTTP request headers also contained crucial information. I paid special attention to the following headers:\nCookie: This long, seemingly random string of characters was the cornerstone that made the entire operation possible. When I logged in through the university’s complex MFA process, the server generated a session and stored a unique session ID in my browser’s Cookie. Subsequently, the browser automatically includes this Cookie in every request sent to that domain. The server validates this Cookie to confirm my identity and returns the timetable data that belongs only to me. This meant that as long as I could get my hands on this valid Cookie, I could simulate my logged-in state in any tool capable of sending HTTP requests (like curl or a Python script) without needing to perform MFA again.\nX-Requested-With: XMLHttpRequest: This header is a de facto standard used to identify an AJAX request. Some server-side frameworks check for the presence of this header to determine the request’s origin and may alter their response behavior accordingly (e.g., an AJAX request might return JSON, while a normal page request returns full HTML). It’s good practice to include this header when simulating such requests.\nAccept: application/json, text/javascript, */*; q=0.01: This header informs the server about the response formats the client is willing to accept. Here, we are explicitly stating a preference for data in application/json format.\nAnalyzing the Response The server responded to this GET request with a 200 OK status code, indicating success. The response body was exactly what I had hoped for: JSON data. It was an array, and each object within the array represented a single class event.\nI inspected the structure of one of these event objects and found all the information I would need:\n{ \"start\": \"2025-11-10T10:00\", \"end\": \"2025-11-10T11:00\", \"activitydesc\": \"COURSE101 - Introduction to Programming [ON CAMPUS LECTURE]\", \"locationdesc\": \"Science Building, Lecture Theatre A\", \"uniqueid\": \"caf4ff456c0dba721bafcfe27f526214\", \"activityname\": \"COURSE101/LEC/A/02\", \"staffs\": [ { \"FullName\": \"Dr. A. Smith\" } ] } start and end: The precise start and end times of the event. activitydesc: The title of the event, perfect for the calendar item’s summary. locationdesc: The location of the class. uniqueid: A unique identifier that looks like a hash value. This is critical for calendar events, as it can serve as the event’s Unique ID (UID), facilitating future updates or deletions and preventing duplicate imports. activityname: The internal code for the course, which could be included as supplementary information. staffs: An array containing instructor information, which could be extracted to enrich the event’s description. At this point, the initial investigation was complete. I had a full understanding of how the data was being fetched and had identified all the necessary components: an API endpoint, two key query parameters (start and end), and a Cookie containing my authentication token.\nFetching Data for the Entire Semester My hypothesis was simple: if the start and end parameters control the time range of the request, I just needed to expand this range to cover the entire semester to get all the course data in one go.\nFirst, I needed to determine the start and end dates of the academic semester. This information is typically available in the university’s Academic Calendar. I found the relevant dates for the current semester—for instance, from September 22, 2025, to December 12, 2025.\nNext, I needed a way to replay the network request I had captured, but with modified parameters. Many tools, such as Postman or Insomnia, are excellent for this. However, for a simple one-off task, I chose to use a feature built directly into the browser’s developer tools: “Copy as cURL.”\nI right-clicked on the get-events request in the Network panel and selected “Copy” -\u003e “Copy as cURL (bash).” This action copied the entire HTTP request—including the method, URL, all headers, and the crucial Cookie—to my clipboard as a command-line-runnable curl command.\nPasting it into a text editor, I had a long command that looked something like this:\ncurl 'https://timetable.university.ac.uk/services/get-events?start=...' \\ -H 'User-Agent: ...' \\ -H 'Accept: application/json, ...' \\ -H 'Accept-Language: ...' \\ --compressed \\ -H 'X-Requested-With: XMLHttpRequest' \\ -H 'Connection: keep-alive' \\ -H 'Referer: https://timetable.university.ac.uk/' \\ -H 'Cookie: session_auth_cookie=...' \\ -H 'Sec-Fetch-Dest: empty' \\ -H 'Sec-Fetch-Mode: cors' \\ -H 'Sec-Fetch-Site: same-origin' Now, I only needed to make two small modifications to this command:\nChange the value of the start parameter to the semester’s start date, e.g., 2025-09-22T00:00:00. Change the value of the end parameter to the semester’s end date, e.g., 2025-12-13T00:00:00 (I set it to the day after the last day of classes to ensure all events on December 12th were included). The modified URL portion looked like this:\n'https://timetable.university.ac.uk/services/get-events?start=2025-09-22T00%3A00%3A00\u0026end=2025-12-13T00%3A00%3A00\u0026_=...\nThen, I appended \u003e timetable.json to the end of the command. This would redirect the output of the curl command (the JSON data returned by the server) and save it directly into a file named timetable.json.\nI pasted the complete, modified command into my terminal and pressed Enter. After a few seconds, the command completed without any errors. I checked my current directory, and there it was: a file named timetable.json. Opening it revealed a massive array of JSON data, containing every single course event for the entire semester.\nThis was the breakthrough moment of the project. I had successfully extracted the data I needed, in its entirety, from a protected web system that offered no export functionality, and saved it as a structured local file. Now, the only remaining task was to convert this data into a format that my calendar application could understand.\nUnderstanding the iCalendar (.ics) Format My goal was to generate an .ics file, the standard file extension for the iCalendar format. iCalendar is a widely supported open standard (RFC 5545), and virtually all calendar applications—whether it’s Google Calendar, Apple Calendar, or Outlook—can recognize and import it.\nBefore I could start writing code, I had to gain a solid understanding of the syntax and structure of an .ics file. It’s essentially a plain text file with content that follows a specific key-value pair format.\nThe basic structure of an .ics file is as follows:\nBEGIN:VCALENDAR VERSION:2.0 PRODID:-//My App//EN ... BEGIN:VEVENT ... END:VEVENT BEGIN:VEVENT ... END:VEVENT ... END:VCALENDAR The entire file is wrapped in BEGIN:VCALENDAR and END:VCALENDAR, defining a calendar object. VERSION:2.0 is a required property that specifies the iCalendar version. PRODID is a product identifier, indicating which software generated the file. I could set this to a custom value. A calendar can contain one or more events, each wrapped in BEGIN:VEVENT and END:VEVENT blocks. The Role of Time Zones Handling time is one of the most complex and error-prone aspects of calendar formats. My timetable is based on the local time in the UK, which observes both British Summer Time (BST) and Greenwich Mean Time (GMT). To ensure that the event times are correct after importing them into a calendar, I must explicitly define the time zone information within the .ics file.\nThe iCalendar specification allows for the definition of a complete time zone rule set using a VTIMEZONE component. This includes the standard time offset, the daylight saving time offset, and the rules for when the transitions occur. For the Europe/London time zone, a standard VTIMEZONE definition looks like this:\nBEGIN:VTIMEZONE TZID:Europe/London BEGIN:DAYLIGHT TZOFFSETFROM:+0000 TZOFFSETTO:+0100 TZNAME:BST DTSTART:19700329T010000 RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU END:DAYLIGHT BEGIN:STANDARD TZOFFSETFROM:+0100 TZOFFSETTO:+0000 TZNAME:GMT DTSTART:19701025T020000 RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU END:STANDARD END:VTIMEZONE TZID defines the name of the time zone. The inner DAYLIGHT and STANDARD blocks define the rules for daylight saving time and standard time, respectively. TZOFFSETFROM and TZOFFSETTO define the offset from UTC. RRULE defines the recurrence rule for when the time changes start (e.g., BYDAY=-1SU means “the last Sunday”). After defining the time zone, I can reference its TZID in each event’s timestamp to ensure time accuracy.\nDeconstructing the VEVENT Each VEVENT block contains several properties that describe a specific event. Based on the information I extracted from the JSON data, I needed to focus on these key properties:\nDTSTART and DTEND: The start and end times of the event. To bind them to the time zone I defined, the format should be DTSTART;TZID=Europe/London:YYYYMMDDTHHMMSS. Note that the date-time format here, YYYYMMDDTHHMMSS, has no separators.\nSUMMARY: The title of the event. This corresponds to activitydesc in the JSON.\nLOCATION: The location of the event. This corresponds to locationdesc.\nDESCRIPTION: A detailed description of the event. I can place additional information here, such as the course code (activityname) and instructor names (staffs). In the .ics format, newlines must be represented as \\n.\nUID: A unique identifier for the event. This is crucial for calendar applications to distinguish between different events, handle updates, and prevent duplicate imports. I will use the uniqueid field from the JSON directly, appending a custom domain to ensure it is globally unique, like uniqueid@my-university-timetable.\nDTSTAMP: A timestamp indicating when this event object was created or last modified, formatted as a UTC time.\nWith a clear understanding of the .ics format, I was now ready to write a Python script to “translate” the data from timetable.json into this format.\nThe Python Script Implementation I chose Python for this conversion task due to its excellent capabilities for handling JSON and text files, along with its powerful standard library. The script’s logic is very straightforward: read the JSON file, iterate over each event, format and concatenate strings according to the .ics specification, and finally, write the result to a new file.\nDesigning the Core Function I encapsulated all the logic within a single function, create_ics_file, which takes the JSON data and an output filename as its arguments.\nThe first part of the function constructs the static header of the .ics file, including BEGIN:VCALENDAR, PRODID, VERSION, and the VTIMEZONE block I prepared earlier. I stored these lines in a list of strings, which would make it easy to join them together later.\ndef create_ics_file(json_data, output_filename): ics_content = [ \"BEGIN:VCALENDAR\", \"PRODID:-//[Your Name]//Timetable//EN\", \"VERSION:2.0\", # ... other header info ... \"X-WR-TIMEZONE:Europe/London\", # ... VTIMEZONE block ... \"END:VTIMEZONE\" ] Iteration and Data Extraction Next came the core of the script: a loop to iterate through the list of events loaded from timetable.json. Inside the loop, I needed to safely extract the required data from each event dictionary.\nUsing the dictionary’s .get() method is a best practice here. Unlike direct access with [], .get() returns a default value (which is None by default) if a key doesn’t exist, rather than raising a KeyError. This makes the code more robust.\nfor event_data in json_data: summary = event_data.get('activitydesc', 'No Title') start_time_str = event_data.get('start') end_time_str = event_data.get('end') location = event_data.get('locationdesc', '') unique_id = event_data.get('uniqueid', '') Handling Instructor Info and Description The instructor information was nested within the staffs list. I needed to iterate through this list, extract the FullName, and join them into a single string. A list comprehension is an elegant way to accomplish this.\nstaff_list = [ staff['FullName'] for staff in event_data.get('staffs', []) if staff.get('FullName') ] I then combined the course code and the list of instructors into a multi-line description string. The iCalendar spec requires a literal \\n for newlines, so in my Python string, I needed to use \\\\n to escape the backslash.\ndescription_parts = [] if activity_name: description_parts.append(activity_name) if staff_list: description_parts.append(\"Staff: \" + \", \".join(staff_list)) description = \"\\\\n\".join(description_parts) Formatting Dates and Times This was the step that required the most attention to detail. The time format in the JSON was ISO 8601 (YYYY-MM-DDTHH:MM), while the .ics file required the YYYYMMDDTHHMMSS format. Python’s datetime module is the perfect tool for this job.\nFirst, I used datetime.fromisoformat() to parse the string into a datetime object. Then, I used the .strftime() method to format this object into the target string.\nstart_dt = datetime.fromisoformat(start_time_str).strftime('%Y%m%dT%H%M%S') end_dt = datetime.fromisoformat(end_time_str).strftime('%Y%m%dT%H%M%S') Assembling the VEVENT Block With all the information extracted and correctly formatted, I could now assemble it into a complete VEVENT block as a series of strings and append them to my ics_content list. F-strings are a modern and efficient way to format strings in Python.\nics_content.extend([ \"BEGIN:VEVENT\", f\"DTSTART;TZID=Europe/London:{start_dt}\", f\"DTEND;TZID=Europe/London:{end_dt}\", f\"DTSTAMP:{dtstamp}\", f\"UID:{unique_id}@university-timetable\", f\"SUMMARY:{summary}\", f\"DESCRIPTION:{description}\", f\"LOCATION:{location}\", \"END:VEVENT\" ]) The Final Result After the loop finished, the ics_content list contained the complete calendar data. I added the final END:VCALENDAR marker, then used \"\\n\".join() to concatenate all lines in the list into a single string, which I then wrote to the specified output file.\nUsing a with open(...) statement for file I/O is a good practice, as it ensures the file is properly closed, even if errors occur during the write process. Additionally, explicitly specifying encoding='utf-8' prevents potential encoding issues when dealing with non-ASCII characters (such as in some instructor or location names).\nics_content.append(\"END:VCALENDAR\") with open(output_filename, 'w', encoding='utf-8') as f: f.write(\"\\n\".join(ics_content)) Finally, I added an if __name__ == \"__main__\": block, which is the standard entry point for a Python script. This allows the file to be both imported as a module in other scripts and run directly from the command line as the main program. Within this block, I included the logic for reading the timetable.json file and added error handling for cases like the file not being found or containing invalid JSON.\nI placed the timetable.json file and my completed Python script in the same directory. Then, I ran python your_script_name.py in my terminal. The script executed in an instant, and a timetable.ics file was generated.\nThe final step was to verify the result. I opened my calendar application (Google Calendar), selected the “Import” function, and uploaded the timetable.ics file I had just created.\nIt worked perfectly. My entire semester’s timetable, with the exact time, location, course name, and instructor for every class, appeared neatly on my calendar. I could now customize colors, set reminders, and manage my academic schedule just like any other event.\n","wordCount":"3004","inLanguage":"en","datePublished":"2025-11-09T22:32:33Z","dateModified":"2025-11-09T22:32:33Z","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tategotoazarasi.me/en/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://blog.tategotoazarasi.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tategotoazarasi.me/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.tategotoazarasi.me/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://blog.tategotoazarasi.me/en/ title=Home><span>Home</span></a></li><li><a href=https://blog.tategotoazarasi.me/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tategotoazarasi.me/en/>Home</a>&nbsp;»&nbsp;<a href=https://blog.tategotoazarasi.me/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Importing My University Timetable into a Personal Calendar: A Hands-On Journey Through Manual API Exploration and iCalendar Generation</h1><div class=post-meta><span title='2025-11-09 22:32:33 +0000 UTC'>November 9, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3004 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://blog.tategotoazarasi.me/zh/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#dive-into-browser-developer-tools>Dive into Browser Developer Tools</a><ol><li><a href=#analyzing-the-request-method-and-url-structure>Analyzing the Request Method and URL Structure</a></li><li><a href=#deconstructing-the-query-parameters>Deconstructing the Query Parameters</a></li><li><a href=#the-importance-of-request-headers>The Importance of Request Headers</a></li><li><a href=#analyzing-the-response>Analyzing the Response</a></li></ol></li><li><a href=#fetching-data-for-the-entire-semester>Fetching Data for the Entire Semester</a></li><li><a href=#understanding-the-icalendar-ics-format>Understanding the iCalendar (.ics) Format</a><ol><li><a href=#the-role-of-time-zones>The Role of Time Zones</a></li><li><a href=#deconstructing-the-vevent>Deconstructing the VEVENT</a></li></ol></li><li><a href=#the-python-script-implementation>The Python Script Implementation</a><ol><li><a href=#designing-the-core-function>Designing the Core Function</a></li><li><a href=#iteration-and-data-extraction>Iteration and Data Extraction</a></li><li><a href=#handling-instructor-info-and-description>Handling Instructor Info and Description</a></li><li><a href=#formatting-dates-and-times>Formatting Dates and Times</a></li><li><a href=#assembling-the-vevent-block>Assembling the VEVENT Block</a></li></ol></li><li><a href=#the-final-result>The Final Result</a></li></ol></nav></div></details></div><div class=post-content><p>As a student, effective time management is paramount. I&rsquo;ve always wanted to integrate my university timetable into the personal calendar application I use daily, allowing me to view all my commitments in one unified place. However, the official university timetable system offers no &ldquo;Export to Calendar&rdquo; feature or any form of <code>.ics</code> subscription link. To complicate matters further, accessing the timetable webpage requires navigating a complex multi-factor authentication (MFA) process.</p><p>Initially, this seemed like a daunting automation challenge. Any script attempting to simulate a login would be made incredibly complex and fragile by the MFA requirement. However, I soon had a crucial realization: once the timetable is set for a semester, it almost never changes. This meant I probably didn&rsquo;t need a dynamic, real-time synchronization solution. A one-time, manual import process would be perfectly sufficient.</p><p>This insight completely reframed my approach to the problem. The challenge shifted from &ldquo;how to automate a complex login flow&rdquo; to &ldquo;how to, after one successful login, retrieve the entire semester&rsquo;s data and convert it into a standard calendar format.&rdquo; This blog post will document my entire process for solving this problem, from investigating network requests and analyzing the API to finally generating an <code>.ics</code> file using a Python script.</p><h2 id=dive-into-browser-developer-tools>Dive into Browser Developer Tools<a hidden class=anchor aria-hidden=true href=#dive-into-browser-developer-tools>#</a></h2><p>My first step was to understand how the timetable data is loaded onto the webpage. Most modern web applications are built with a front-end/back-end separation, where the front-end page is merely a shell. The necessary data is fetched from a back-end server via asynchronous API calls (usually AJAX) and then rendered dynamically. If this were the case, I could potentially find this API directly, bypassing the need for complex page scraping.</p><p>I opened the university&rsquo;s timetable page and pressed <code>F12</code> (or <code>Option + Command + I</code> on macOS) to launch the browser&rsquo;s developer tools. This is a powerful suite of tools that allows for the inspection and debugging of nearly every aspect of a webpage. I focused my attention on the &ldquo;Network&rdquo; tab, which records all communication between the browser and the server.</p><p>To trigger a data-loading event, I needed to perform an action on the page. The timetable defaults to showing the current week&rsquo;s schedule. I clicked the &ldquo;Next Week&rdquo; button to advance to the following week&rsquo;s timetable. As expected, a new network request immediately appeared in the Network panel.</p><p>After filtering through the various requests, I zeroed in on one named <code>get-events</code>. Its URL looked something like this:</p><p><code>https://timetable.university.ac.uk/services/get-events?start=2025-11-10T00%3A00%3A00&amp;end=2025-11-15T00%3A00%3A00&_=1762726887267</code></p><p>This discovery was exhilarating. The request&rsquo;s name (<code>get-events</code>) and its parameters were highly suggestive. I immediately began to dissect every detail of this request.</p><h3 id=analyzing-the-request-method-and-url-structure>Analyzing the Request Method and URL Structure<a hidden class=anchor aria-hidden=true href=#analyzing-the-request-method-and-url-structure>#</a></h3><p>The request used the <code>GET</code> method, which is the standard HTTP method for a client to request data from a server. The URL structure was also quite intuitive:</p><ul><li><strong>Hostname</strong>: <code>timetable.university.ac.uk</code>, the domain of the timetable service.</li><li><strong>Path</strong>: <code>/services/get-events</code>, clearly indicating that this endpoint&rsquo;s function is to retrieve events.</li><li><strong>Query Parameters</strong>: The part of the URL after the <code>?</code>, which held the keys to unlocking the data.</li></ul><h3 id=deconstructing-the-query-parameters>Deconstructing the Query Parameters<a hidden class=anchor aria-hidden=true href=#deconstructing-the-query-parameters>#</a></h3><p>I examined the query parameters closely. They were formatted as <code>key=value</code> pairs, separated by <code>&</code>.</p><ul><li><p><code>start=2025-11-10T00%3A00%3A00</code>: The value for the <code>start</code> parameter was URL-encoded. After decoding, it became <code>2025-11-10T00:00:00</code>. This was clearly the start time of the first day (Monday) of the week I had requested. The <code>T</code> separates the date and time, which conforms to the ISO 8601 date-time standard.</p></li><li><p><code>end=2025-11-15T00%3A00%3A00</code>: Similarly, the <code>end</code> parameter decoded to <code>2025-11-15T00:00:00</code>. Interestingly, this appeared to be the start of Saturday for that week, not the end of Friday. This suggested that the API&rsquo;s time range query likely uses a left-closed, right-open interval <code>[start, end)</code>, meaning it includes the <code>start</code> timestamp but excludes the <code>end</code> timestamp. This is a very common practice in programming for handling time ranges, as it avoids many off-by-one errors and boundary condition issues.</p></li><li><p><code>_=1762726887267</code>: This parameter looked like a Unix timestamp (in milliseconds). This is a common technique known as a &ldquo;cache buster.&rdquo; Browsers and proxy servers may cache the results of <code>GET</code> requests. By appending a unique, time-based parameter to each request, it ensures that every request is treated as new and distinct, forcing the server to return fresh data instead of a cached version. For my use case, this parameter probably wasn&rsquo;t strictly necessary, but to faithfully replay the request, it was best to keep it.</p></li></ul><h3 id=the-importance-of-request-headers>The Importance of Request Headers<a hidden class=anchor aria-hidden=true href=#the-importance-of-request-headers>#</a></h3><p>Beyond the URL, the HTTP request headers also contained crucial information. I paid special attention to the following headers:</p><ul><li><p><code>Cookie</code>: This long, seemingly random string of characters was the cornerstone that made the entire operation possible. When I logged in through the university&rsquo;s complex MFA process, the server generated a session and stored a unique session ID in my browser&rsquo;s Cookie. Subsequently, the browser automatically includes this Cookie in every request sent to that domain. The server validates this Cookie to confirm my identity and returns the timetable data that belongs only to me. This meant that as long as I could get my hands on this valid Cookie, I could simulate my logged-in state in any tool capable of sending HTTP requests (like <code>curl</code> or a Python script) without needing to perform MFA again.</p></li><li><p><code>X-Requested-With: XMLHttpRequest</code>: This header is a de facto standard used to identify an AJAX request. Some server-side frameworks check for the presence of this header to determine the request&rsquo;s origin and may alter their response behavior accordingly (e.g., an AJAX request might return JSON, while a normal page request returns full HTML). It&rsquo;s good practice to include this header when simulating such requests.</p></li><li><p><code>Accept: application/json, text/javascript, */*; q=0.01</code>: This header informs the server about the response formats the client is willing to accept. Here, we are explicitly stating a preference for data in <code>application/json</code> format.</p></li></ul><h3 id=analyzing-the-response>Analyzing the Response<a hidden class=anchor aria-hidden=true href=#analyzing-the-response>#</a></h3><p>The server responded to this <code>GET</code> request with a <code>200 OK</code> status code, indicating success. The response body was exactly what I had hoped for: JSON data. It was an array, and each object within the array represented a single class event.</p><p>I inspected the structure of one of these event objects and found all the information I would need:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;start&#34;</span>: <span style=color:#e6db74>&#34;2025-11-10T10:00&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;end&#34;</span>: <span style=color:#e6db74>&#34;2025-11-10T11:00&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;activitydesc&#34;</span>: <span style=color:#e6db74>&#34;COURSE101 - Introduction to Programming [ON CAMPUS LECTURE]&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;locationdesc&#34;</span>: <span style=color:#e6db74>&#34;Science Building, Lecture Theatre A&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;uniqueid&#34;</span>: <span style=color:#e6db74>&#34;caf4ff456c0dba721bafcfe27f526214&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;activityname&#34;</span>: <span style=color:#e6db74>&#34;COURSE101/LEC/A/02&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;staffs&#34;</span>: [
</span></span><span style=display:flex><span>    { <span style=color:#f92672>&#34;FullName&#34;</span>: <span style=color:#e6db74>&#34;Dr. A. Smith&#34;</span> }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>start</code> and <code>end</code>: The precise start and end times of the event.</li><li><code>activitydesc</code>: The title of the event, perfect for the calendar item&rsquo;s summary.</li><li><code>locationdesc</code>: The location of the class.</li><li><code>uniqueid</code>: A unique identifier that looks like a hash value. This is critical for calendar events, as it can serve as the event&rsquo;s Unique ID (UID), facilitating future updates or deletions and preventing duplicate imports.</li><li><code>activityname</code>: The internal code for the course, which could be included as supplementary information.</li><li><code>staffs</code>: An array containing instructor information, which could be extracted to enrich the event&rsquo;s description.</li></ul><p>At this point, the initial investigation was complete. I had a full understanding of how the data was being fetched and had identified all the necessary components: an API endpoint, two key query parameters (<code>start</code> and <code>end</code>), and a <code>Cookie</code> containing my authentication token.</p><h2 id=fetching-data-for-the-entire-semester>Fetching Data for the Entire Semester<a hidden class=anchor aria-hidden=true href=#fetching-data-for-the-entire-semester>#</a></h2><p>My hypothesis was simple: if the <code>start</code> and <code>end</code> parameters control the time range of the request, I just needed to expand this range to cover the entire semester to get all the course data in one go.</p><p>First, I needed to determine the start and end dates of the academic semester. This information is typically available in the university&rsquo;s Academic Calendar. I found the relevant dates for the current semester—for instance, from September 22, 2025, to December 12, 2025.</p><p>Next, I needed a way to replay the network request I had captured, but with modified parameters. Many tools, such as Postman or Insomnia, are excellent for this. However, for a simple one-off task, I chose to use a feature built directly into the browser&rsquo;s developer tools: &ldquo;Copy as cURL.&rdquo;</p><p>I right-clicked on the <code>get-events</code> request in the Network panel and selected &ldquo;Copy&rdquo; -> &ldquo;Copy as cURL (bash).&rdquo; This action copied the entire HTTP request—including the method, URL, all headers, and the crucial Cookie—to my clipboard as a command-line-runnable <code>curl</code> command.</p><p>Pasting it into a text editor, I had a long command that looked something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl <span style=color:#e6db74>&#39;https://timetable.university.ac.uk/services/get-events?start=...&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;User-Agent: ...&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Accept: application/json, ...&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Accept-Language: ...&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --compressed <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;X-Requested-With: XMLHttpRequest&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Connection: keep-alive&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Referer: https://timetable.university.ac.uk/&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Cookie: session_auth_cookie=...&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Sec-Fetch-Dest: empty&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Sec-Fetch-Mode: cors&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -H <span style=color:#e6db74>&#39;Sec-Fetch-Site: same-origin&#39;</span>
</span></span></code></pre></div><p>Now, I only needed to make two small modifications to this command:</p><ol><li>Change the value of the <code>start</code> parameter to the semester&rsquo;s start date, e.g., <code>2025-09-22T00:00:00</code>.</li><li>Change the value of the <code>end</code> parameter to the semester&rsquo;s end date, e.g., <code>2025-12-13T00:00:00</code> (I set it to the day after the last day of classes to ensure all events on December 12th were included).</li></ol><p>The modified URL portion looked like this:</p><p><code>'https://timetable.university.ac.uk/services/get-events?start=2025-09-22T00%3A00%3A00&amp;end=2025-12-13T00%3A00%3A00&_=...</code></p><p>Then, I appended <code>> timetable.json</code> to the end of the command. This would redirect the output of the <code>curl</code> command (the JSON data returned by the server) and save it directly into a file named <code>timetable.json</code>.</p><p>I pasted the complete, modified command into my terminal and pressed Enter. After a few seconds, the command completed without any errors. I checked my current directory, and there it was: a file named <code>timetable.json</code>. Opening it revealed a massive array of JSON data, containing every single course event for the entire semester.</p><p>This was the breakthrough moment of the project. I had successfully extracted the data I needed, in its entirety, from a protected web system that offered no export functionality, and saved it as a structured local file. Now, the only remaining task was to convert this data into a format that my calendar application could understand.</p><h2 id=understanding-the-icalendar-ics-format>Understanding the iCalendar (.ics) Format<a hidden class=anchor aria-hidden=true href=#understanding-the-icalendar-ics-format>#</a></h2><p>My goal was to generate an <code>.ics</code> file, the standard file extension for the iCalendar format. iCalendar is a widely supported open standard (RFC 5545), and virtually all calendar applications—whether it&rsquo;s Google Calendar, Apple Calendar, or Outlook—can recognize and import it.</p><p>Before I could start writing code, I had to gain a solid understanding of the syntax and structure of an <code>.ics</code> file. It&rsquo;s essentially a plain text file with content that follows a specific key-value pair format.</p><p>The basic structure of an <code>.ics</code> file is as follows:</p><pre tabindex=0><code class=language-ics data-lang=ics>BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//My App//EN
...
BEGIN:VEVENT
...
END:VEVENT
BEGIN:VEVENT
...
END:VEVENT
...
END:VCALENDAR
</code></pre><ul><li>The entire file is wrapped in <code>BEGIN:VCALENDAR</code> and <code>END:VCALENDAR</code>, defining a calendar object.</li><li><code>VERSION:2.0</code> is a required property that specifies the iCalendar version.</li><li><code>PRODID</code> is a product identifier, indicating which software generated the file. I could set this to a custom value.</li><li>A calendar can contain one or more events, each wrapped in <code>BEGIN:VEVENT</code> and <code>END:VEVENT</code> blocks.</li></ul><h3 id=the-role-of-time-zones>The Role of Time Zones<a hidden class=anchor aria-hidden=true href=#the-role-of-time-zones>#</a></h3><p>Handling time is one of the most complex and error-prone aspects of calendar formats. My timetable is based on the local time in the UK, which observes both British Summer Time (BST) and Greenwich Mean Time (GMT). To ensure that the event times are correct after importing them into a calendar, I must explicitly define the time zone information within the <code>.ics</code> file.</p><p>The iCalendar specification allows for the definition of a complete time zone rule set using a <code>VTIMEZONE</code> component. This includes the standard time offset, the daylight saving time offset, and the rules for when the transitions occur. For the <code>Europe/London</code> time zone, a standard <code>VTIMEZONE</code> definition looks like this:</p><pre tabindex=0><code class=language-ics data-lang=ics>BEGIN:VTIMEZONE
TZID:Europe/London
BEGIN:DAYLIGHT
TZOFFSETFROM:+0000
TZOFFSETTO:+0100
TZNAME:BST
DTSTART:19700329T010000
RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU
END:DAYLIGHT
BEGIN:STANDARD
TZOFFSETFROM:+0100
TZOFFSETTO:+0000
TZNAME:GMT
DTSTART:19701025T020000
RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU
END:STANDARD
END:VTIMEZONE
</code></pre><ul><li><code>TZID</code> defines the name of the time zone.</li><li>The inner <code>DAYLIGHT</code> and <code>STANDARD</code> blocks define the rules for daylight saving time and standard time, respectively.</li><li><code>TZOFFSETFROM</code> and <code>TZOFFSETTO</code> define the offset from UTC.</li><li><code>RRULE</code> defines the recurrence rule for when the time changes start (e.g., <code>BYDAY=-1SU</code> means &ldquo;the last Sunday&rdquo;).</li></ul><p>After defining the time zone, I can reference its <code>TZID</code> in each event&rsquo;s timestamp to ensure time accuracy.</p><h3 id=deconstructing-the-vevent>Deconstructing the VEVENT<a hidden class=anchor aria-hidden=true href=#deconstructing-the-vevent>#</a></h3><p>Each <code>VEVENT</code> block contains several properties that describe a specific event. Based on the information I extracted from the JSON data, I needed to focus on these key properties:</p><ul><li><p><code>DTSTART</code> and <code>DTEND</code>: The start and end times of the event. To bind them to the time zone I defined, the format should be <code>DTSTART;TZID=Europe/London:YYYYMMDDTHHMMSS</code>. Note that the date-time format here, <code>YYYYMMDDTHHMMSS</code>, has no separators.</p></li><li><p><code>SUMMARY</code>: The title of the event. This corresponds to <code>activitydesc</code> in the JSON.</p></li><li><p><code>LOCATION</code>: The location of the event. This corresponds to <code>locationdesc</code>.</p></li><li><p><code>DESCRIPTION</code>: A detailed description of the event. I can place additional information here, such as the course code (<code>activityname</code>) and instructor names (<code>staffs</code>). In the <code>.ics</code> format, newlines must be represented as <code>\n</code>.</p></li><li><p><code>UID</code>: A unique identifier for the event. This is crucial for calendar applications to distinguish between different events, handle updates, and prevent duplicate imports. I will use the <code>uniqueid</code> field from the JSON directly, appending a custom domain to ensure it is globally unique, like <code>uniqueid@my-university-timetable</code>.</p></li><li><p><code>DTSTAMP</code>: A timestamp indicating when this event object was created or last modified, formatted as a UTC time.</p></li></ul><p>With a clear understanding of the <code>.ics</code> format, I was now ready to write a Python script to &ldquo;translate&rdquo; the data from <code>timetable.json</code> into this format.</p><h2 id=the-python-script-implementation>The Python Script Implementation<a hidden class=anchor aria-hidden=true href=#the-python-script-implementation>#</a></h2><p>I chose Python for this conversion task due to its excellent capabilities for handling JSON and text files, along with its powerful standard library. The script&rsquo;s logic is very straightforward: read the JSON file, iterate over each event, format and concatenate strings according to the <code>.ics</code> specification, and finally, write the result to a new file.</p><h3 id=designing-the-core-function>Designing the Core Function<a hidden class=anchor aria-hidden=true href=#designing-the-core-function>#</a></h3><p>I encapsulated all the logic within a single function, <code>create_ics_file</code>, which takes the JSON data and an output filename as its arguments.</p><p>The first part of the function constructs the static header of the <code>.ics</code> file, including <code>BEGIN:VCALENDAR</code>, <code>PRODID</code>, <code>VERSION</code>, and the <code>VTIMEZONE</code> block I prepared earlier. I stored these lines in a list of strings, which would make it easy to join them together later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_ics_file</span>(json_data, output_filename):
</span></span><span style=display:flex><span>    ics_content <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;BEGIN:VCALENDAR&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;PRODID:-//[Your Name]//Timetable//EN&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;VERSION:2.0&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#75715e># ... other header info ...</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;X-WR-TIMEZONE:Europe/London&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#75715e># ... VTIMEZONE block ...</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;END:VTIMEZONE&#34;</span>
</span></span><span style=display:flex><span>    ]
</span></span></code></pre></div><h3 id=iteration-and-data-extraction>Iteration and Data Extraction<a hidden class=anchor aria-hidden=true href=#iteration-and-data-extraction>#</a></h3><p>Next came the core of the script: a loop to iterate through the list of events loaded from <code>timetable.json</code>. Inside the loop, I needed to safely extract the required data from each event dictionary.</p><p>Using the dictionary&rsquo;s <code>.get()</code> method is a best practice here. Unlike direct access with <code>[]</code>, <code>.get()</code> returns a default value (which is <code>None</code> by default) if a key doesn&rsquo;t exist, rather than raising a <code>KeyError</code>. This makes the code more robust.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> event_data <span style=color:#f92672>in</span> json_data:
</span></span><span style=display:flex><span>    summary <span style=color:#f92672>=</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;activitydesc&#39;</span>, <span style=color:#e6db74>&#39;No Title&#39;</span>)
</span></span><span style=display:flex><span>    start_time_str <span style=color:#f92672>=</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;start&#39;</span>)
</span></span><span style=display:flex><span>    end_time_str <span style=color:#f92672>=</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;end&#39;</span>)
</span></span><span style=display:flex><span>    location <span style=color:#f92672>=</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;locationdesc&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    unique_id <span style=color:#f92672>=</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;uniqueid&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>)
</span></span></code></pre></div><h3 id=handling-instructor-info-and-description>Handling Instructor Info and Description<a hidden class=anchor aria-hidden=true href=#handling-instructor-info-and-description>#</a></h3><p>The instructor information was nested within the <code>staffs</code> list. I needed to iterate through this list, extract the <code>FullName</code>, and join them into a single string. A list comprehension is an elegant way to accomplish this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>staff_list <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    staff[<span style=color:#e6db74>&#39;FullName&#39;</span>] <span style=color:#66d9ef>for</span> staff <span style=color:#f92672>in</span> event_data<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;staffs&#39;</span>, [])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> staff<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;FullName&#39;</span>)
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>I then combined the course code and the list of instructors into a multi-line description string. The iCalendar spec requires a literal <code>\n</code> for newlines, so in my Python string, I needed to use <code>\\n</code> to escape the backslash.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>description_parts <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> activity_name:
</span></span><span style=display:flex><span>    description_parts<span style=color:#f92672>.</span>append(activity_name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> staff_list:
</span></span><span style=display:flex><span>    description_parts<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;Staff: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, &#34;</span><span style=color:#f92672>.</span>join(staff_list))
</span></span><span style=display:flex><span>description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;</span><span style=color:#f92672>.</span>join(description_parts)
</span></span></code></pre></div><h3 id=formatting-dates-and-times>Formatting Dates and Times<a hidden class=anchor aria-hidden=true href=#formatting-dates-and-times>#</a></h3><p>This was the step that required the most attention to detail. The time format in the JSON was ISO 8601 (<code>YYYY-MM-DDTHH:MM</code>), while the <code>.ics</code> file required the <code>YYYYMMDDTHHMMSS</code> format. Python&rsquo;s <code>datetime</code> module is the perfect tool for this job.</p><p>First, I used <code>datetime.fromisoformat()</code> to parse the string into a <code>datetime</code> object. Then, I used the <code>.strftime()</code> method to format this object into the target string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>start_dt <span style=color:#f92672>=</span> datetime<span style=color:#f92672>.</span>fromisoformat(start_time_str)<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%Y%m</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>T%H%M%S&#39;</span>)
</span></span><span style=display:flex><span>end_dt <span style=color:#f92672>=</span> datetime<span style=color:#f92672>.</span>fromisoformat(end_time_str)<span style=color:#f92672>.</span>strftime(<span style=color:#e6db74>&#39;%Y%m</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>T%H%M%S&#39;</span>)
</span></span></code></pre></div><h3 id=assembling-the-vevent-block>Assembling the VEVENT Block<a hidden class=anchor aria-hidden=true href=#assembling-the-vevent-block>#</a></h3><p>With all the information extracted and correctly formatted, I could now assemble it into a complete <code>VEVENT</code> block as a series of strings and append them to my <code>ics_content</code> list. F-strings are a modern and efficient way to format strings in Python.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ics_content<span style=color:#f92672>.</span>extend([
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;BEGIN:VEVENT&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;DTSTART;TZID=Europe/London:</span><span style=color:#e6db74>{</span>start_dt<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;DTEND;TZID=Europe/London:</span><span style=color:#e6db74>{</span>end_dt<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;DTSTAMP:</span><span style=color:#e6db74>{</span>dtstamp<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;UID:</span><span style=color:#e6db74>{</span>unique_id<span style=color:#e6db74>}</span><span style=color:#e6db74>@university-timetable&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;SUMMARY:</span><span style=color:#e6db74>{</span>summary<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;DESCRIPTION:</span><span style=color:#e6db74>{</span>description<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;LOCATION:</span><span style=color:#e6db74>{</span>location<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;END:VEVENT&#34;</span>
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><h2 id=the-final-result>The Final Result<a hidden class=anchor aria-hidden=true href=#the-final-result>#</a></h2><p>After the loop finished, the <code>ics_content</code> list contained the complete calendar data. I added the final <code>END:VCALENDAR</code> marker, then used <code>"\n".join()</code> to concatenate all lines in the list into a single string, which I then wrote to the specified output file.</p><p>Using a <code>with open(...)</code> statement for file I/O is a good practice, as it ensures the file is properly closed, even if errors occur during the write process. Additionally, explicitly specifying <code>encoding='utf-8'</code> prevents potential encoding issues when dealing with non-ASCII characters (such as in some instructor or location names).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ics_content<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#34;END:VCALENDAR&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(output_filename, <span style=color:#e6db74>&#39;w&#39;</span>, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;utf-8&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>	f<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>join(ics_content))
</span></span></code></pre></div><p>Finally, I added an <code>if __name__ == "__main__":</code> block, which is the standard entry point for a Python script. This allows the file to be both imported as a module in other scripts and run directly from the command line as the main program. Within this block, I included the logic for reading the <code>timetable.json</code> file and added error handling for cases like the file not being found or containing invalid JSON.</p><p>I placed the <code>timetable.json</code> file and my completed Python script in the same directory. Then, I ran <code>python your_script_name.py</code> in my terminal. The script executed in an instant, and a <code>timetable.ics</code> file was generated.</p><p>The final step was to verify the result. I opened my calendar application (Google Calendar), selected the &ldquo;Import&rdquo; function, and uploaded the <code>timetable.ics</code> file I had just created.</p><p>It worked perfectly. My entire semester&rsquo;s timetable, with the exact time, location, course name, and instructor for every class, appeared neatly on my calendar. I could now customize colors, set reminders, and manage my academic schedule just like any other event.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tategotoazarasi.me/en/tags/python/>Python</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/icalendar/>Icalendar</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/ics/>Ics</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/json/>Json</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/api/>Api</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/reverse-engineering/>Reverse-Engineering</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/web-scraping/>Web-Scraping</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/developer-tools/>Developer-Tools</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/network-analysis/>Network-Analysis</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/http-request/>Http-Request</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/curl/>Curl</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/automation/>Automation</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/data-conversion/>Data-Conversion</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/timetable/>Timetable</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/calendar-import/>Calendar-Import</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/student-project/>Student-Project</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/time-management/>Time-Management</a></li><li><a href=https://blog.tategotoazarasi.me/en/tags/university-life/>University-Life</a></li></ul><nav class=paginav><a class=prev href=https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/><span class=title>« Prev</span><br><span>Building a Data-Driven City: Integrating Housing, Safety, and Deprivation Metrics with Python</span>
</a><a class=next href=https://blog.tategotoazarasi.me/en/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/><span class=title>Next »</span><br><span>Building a TypeScript Video Downloader for Complex, Anti-Scraping Websites</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://blog.tategotoazarasi.me/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>