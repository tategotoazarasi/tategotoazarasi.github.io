<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Under the Hood: The Technologies Powering Your Favorite Game Mods | Tategoto Azarasi</title>
<meta name=keywords content="game-modding,single-player-games,pc-gaming,modding-frameworks,scripting-languages,domain-specific-languages,lua,python,c-sharp,interpreted-scripts,compiled-mods,mod-apis,sandboxing,security,game-architecture,extensibility,mod-lifecycle,event-handling,paradox-games,rimworld,mount-and-blade-bannerlord,minecraft,software-engineering,user-created-content,performance-trade-offs,modding-technology,game-development,scripting-vs-compiled,mod-security,embedded-languages,dsl-design,game-extensibility,sandbox-strategies,case-studies,future-research,modding-tools,api-design,community-mods,gaming-platforms,code-execution"><meta name=description content="Discover the tech behind single-player PC game mods, from scripting languages to security and future trends like WebAssembly."><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/under-the-hood-the-technologies-powering-your-favorite-game-mods/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/under-the-hood-the-technologies-powering-your-favorite-game-mods/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/under-the-hood-the-technologies-powering-your-favorite-game-mods/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Under the Hood: The Technologies Powering Your Favorite Game Mods"><meta property="og:description" content="Discover the tech behind single-player PC game mods, from scripting languages to security and future trends like WebAssembly."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-27T17:33:26+08:00"><meta property="article:modified_time" content="2025-03-27T17:33:26+08:00"><meta property="article:tag" content="Game-Modding"><meta property="article:tag" content="Single-Player-Games"><meta property="article:tag" content="Pc-Gaming"><meta property="article:tag" content="Modding-Frameworks"><meta property="article:tag" content="Scripting-Languages"><meta property="article:tag" content="Domain-Specific-Languages"><meta name=twitter:card content="summary"><meta name=twitter:title content="Under the Hood: The Technologies Powering Your Favorite Game Mods"><meta name=twitter:description content="Discover the tech behind single-player PC game mods, from scripting languages to security and future trends like WebAssembly."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Under the Hood: The Technologies Powering Your Favorite Game Mods","item":"https://tategotoazarasi.github.io/en/posts/under-the-hood-the-technologies-powering-your-favorite-game-mods/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Under the Hood: The Technologies Powering Your Favorite Game Mods","name":"Under the Hood: The Technologies Powering Your Favorite Game Mods","description":"Discover the tech behind single-player PC game mods, from scripting languages to security and future trends like WebAssembly.","keywords":["game-modding","single-player-games","pc-gaming","modding-frameworks","scripting-languages","domain-specific-languages","lua","python","c-sharp","interpreted-scripts","compiled-mods","mod-apis","sandboxing","security","game-architecture","extensibility","mod-lifecycle","event-handling","paradox-games","rimworld","mount-and-blade-bannerlord","minecraft","software-engineering","user-created-content","performance-trade-offs","modding-technology","game-development","scripting-vs-compiled","mod-security","embedded-languages","dsl-design","game-extensibility","sandbox-strategies","case-studies","future-research","modding-tools","api-design","community-mods","gaming-platforms","code-execution"],"articleBody":"If you’ve spent any time in the PC gaming world, you know mods. They’re the lifeblood that keeps games fresh years after release, the sparks of creativity that turn a fun experience into a personalized obsession, and sometimes, the foundation for entirely new genres. Think about it: Counter-Strike started as a Half-Life mod, Dota emerged from Warcraft III, and countless other innovations bubbled up from player communities tinkering with the games they loved [1]. Modding isn’t just about adding silly hats (though that’s important too!); it’s a powerful form of user engagement, creativity, and even end-user software engineering [1].\nBut here’s the thing: enabling this creative chaos isn’t magic. It requires deliberate, often complex, technical decisions from the game developers themselves. While some hardcore modders might reverse-engineer games without official help, the most vibrant modding scenes often flourish where developers have intentionally built support for mods right into the game’s architecture.\nSupporting mods properly is hard. Developers have to grapple with fundamental questions:\nWhat kind of tools or languages should modders use? Should it be something familiar like Python or Lua, or a custom language built just for the game? How will the mod code actually run? Will it be interpreted on the fly, or compiled into faster (but potentially riskier) binary code? How do we let mods interact with the game without crashing everything or, worse, opening up security holes? How do we balance giving modders enough power to be creative against maintaining game stability and performance? This isn’t just a technical puzzle; it’s a strategic one that shapes the entire modding community around a game. Get it right, and you foster decades of player loyalty and innovation (think Skyrim or Minecraft). Get it wrong, and you might stifle creativity or end up with a buggy, insecure mess.\nIn this (rather extensive) post, we’re going to unpack the technologies developers use on their side to make modding possible for single-player PC games.\nOur focus here is strictly on the developer-side technology for single-player PC games. Multiplayer introduces a whole other layer of complexity (anti-cheat, synchronization, server hosting) that’s beyond our scope today. Console modding is also a different beast due to platform restrictions and certification processes.\nSo, let’s pop the hood and see what makes modding tick.\nThe Foundations: What Makes a Game Moddable? Before we even talk about specific languages or execution methods, we need to understand that supporting mods isn’t usually an afterthought bolted onto a finished game. Truly moddable games are often designed with extensibility in mind from the ground up.\nDesigning for Extensibility This idea isn’t unique to games. Back in the day, software engineering pioneers like David Parnas talked about designing software for change and extension [1]. The core principle is building systems in a modular way, with well-defined interfaces between components, so that you can swap parts out or add new ones without breaking the whole thing.\nWalt Scacchi, who has written extensively on game modding, framed it as a form of “open software extension” [1]. Games that do this well often employ architectural patterns like:\nModular Design Breaking the game down into distinct systems (AI, physics, UI, gameplay logic) that communicate through clear interfaces. This makes it easier to expose specific parts to modders without revealing the entire messy internals. Think of how Unreal Engine uses modules, which can facilitate plugin-based modding [2].\nData-Driven Architecture Instead of hardcoding game rules, content, or parameters directly into the compiled code, developers store this information in external files (like XML, JSON, YAML, or custom formats). The game engine reads these files at runtime to configure itself. This is huge for modding because it means players can change significant aspects of the game simply by editing or adding these data files, without needing to write any code. We’ll see a great example of this with RimWorld.\nSoftware Product Lines Some researchers view moddable games as instances of software product lines, where the base game is the core platform and mods represent variations or features added to that platform [1]. Designing with this mindset encourages developers to think about commonality and variability, isolating the core engine from the customizable game content.\nData-Driven vs. Code-Driven Modding This leads to a fundamental distinction in how mods interact with the game:\nData-Driven Modding Mods primarily consist of data files that the game engine reads and interprets. This could be adding new items by defining them in an XML file, creating new quests via configuration files, or adjusting weapon stats in a spreadsheet-like format. The power here comes from the engine being designed to read this external data. Paradox games are masters of this, allowing huge swathes of game logic and content to be defined in text files [3].\nCode-Driven Modding Mods include actual executable code (scripts or compiled binaries) that runs alongside the game’s own code. This code typically uses an Application Programming Interface (API) exposed by the game engine to query game state, react to events, or modify game behavior. This allows for much deeper, more complex changes, like implementing entirely new gameplay systems or altering core AI. Games like RimWorld (C# mods) [4] or Mount \u0026 Blade II: Bannerlord (C# mods) [5] heavily rely on this.\nMany games actually use a hybrid approach. They might allow simple content additions via data files (easy entry point for beginners) and provide a scripting or code API for more advanced modders. RimWorld is a perfect example: add new guns via XML, write complex AI behaviors in C# [4].\nThe Modding API: The Gateway Whether data-driven or code-driven, the core mechanism enabling mods is some form of interface provided by the developers. This could be:\nFile Formats and Loaders For data mods, the “API” is the specification of the data file formats (e.g., the structure of the XML definitions in RimWorld) and the engine’s ability to find and load these files from mod directories.\nScripting Hooks and Bindings For script mods, the API consists of the functions and objects the scripting language can access to interact with the game world (e.g., the Lua functions exposed by Factorio to let mods react to events like on_player_crafted_item [6].\nCode Libraries and Interfaces For compiled mods, the API is often a set of libraries (like DLLs or JARs) that mods link against, providing classes and methods to interact with the engine (e.g., the TaleWorlds.*.dll assemblies that Bannerlord modders reference [5].\nDesigning a good modding API is an art. It needs to be:\nPowerful enough Expose enough functionality to allow meaningful mods.\nStable enough Avoid changing constantly, which breaks existing mods with every game update.\nSafe enough Not expose functions that could easily crash the game or compromise security.\nDocumented enough Modders need to know what’s available and how to use it! (Though community reverse-engineering often fills gaps, as seen in RimWorld [7].\nWith these foundational concepts in mind, let’s dive into one of the biggest decisions developers face: what language should mods be written in?\nChoosing the Right Tools: Languages for Modders Okay, so you’ve decided to let players mod your game with code or scripts. Now what? Do you embed a popular language like Lua or Python? Or do you invent your own special language just for your game? This choice has massive ripple effects on performance, flexibility, security, and the kind of modding community that grows around your game.\nThe Big Question: General-Purpose Language vs. Domain-Specific Language (DSL)? This is the core dilemma. Let’s break down the options.\nOption 1: Embed a General-Purpose Language This involves integrating an existing, off-the-shelf programming language interpreter or runtime into your game engine. Modders then write their logic in that language.\nLua The reigning champion of embedded game scripting. Why? It’s small, fast (for a script), designed explicitly for embedding in C/C++ applications, and relatively easy to learn [8]. Countless games use it, from World of Warcraft’s UI mods to Factorio’s extensive modding system [9] to experiments in Paradox games [8]. Its C API makes it straightforward (relatively speaking) to bridge the gap between the game’s native code and the Lua scripts.\nPython Another popular choice, known for its readability and vast libraries. Civilization IV famously used Python for a lot of its game logic scripting, allowing extensive modding. The downside? Python interpreters are generally heavier than Lua’s, and performance can be a concern for high-frequency tasks in games. Integration also requires careful handling of the Global Interpreter Lock (GIL) if multithreading is involved.\nC# Particularly relevant for games built with the Unity engine. Since Unity itself uses C# for scripting, it’s natural for developers to expose parts of their C# codebase for modding. RimWorld [4], Cities: Skylines [10], and Mount \u0026 Blade II: Bannerlord [5] all allow mods written as compiled C# assemblies (.DLLs). This provides immense power and performance (thanks to the .NET JIT compiler) but comes with compilation hurdles and security headaches (more on that later).\nJavaScript While primarily a web language, its ubiquity and mature engines (like V8) have led to its use in some game contexts, especially for UI scripting. Valve’s Source 2 engine, for example, uses JavaScript (specifically Panorama UI) for UI elements in games like Dota 2 [11]. Security is a major consideration here, as browser engines have incredibly sophisticated sandboxes built over decades – something game engines usually lack.\nPros of General-Purpose Languages Familiarity Modders can leverage existing programming skills. The learning curve is lower if they already know Lua, Python, or C#.\nPower \u0026 Expressiveness These are real programming languages! Modders can implement complex algorithms, data structures, and logic that might be impossible in a more limited system.\nEcosystem Access to existing libraries (though often restricted for security), documentation, and development tools (debuggers, IDEs).\nCons of General-Purpose Languages Integration Complexity Developers need to embed the interpreter/runtime, create bindings (the C/C++ API bridge), and carefully manage data transfer between the game and the script environment. This binding layer can be tricky to get right and maintain.\nPerformance Overhead Scripting is almost always slower than native compiled code. Oskar Forsslund’s Master’s thesis provides a stark example: evaluating Europa Universalis III’s event triggers in Lua was roughly six times slower than the original C++ implementation that parsed custom script files [8] [8]. The overhead comes from interpretation/JIT compilation itself, but also significantly from the “context switching” and data marshaling required to call script functions from C++ and vice-versa [8].\nSecurity Risks These languages are powerful. Unless carefully sandboxed, a mod script could potentially access the file system ( io.open in Lua), make network connections, or execute arbitrary OS commands (os.execute in Lua). Sandboxing requires deliberately restricting the available functions and libraries, which takes effort.\nAPI Surface Developers need to decide what parts of the game to expose to the scripting language. They are constantly balancing giving modders enough power versus overwhelming them or exposing internals that shouldn’t be touched. As one developer noted in a discussion, you’re “on the hook for anticipating their needs” [12].\nMitigating Performance: Just-In-Time (JIT) compilers can help bridge the performance gap. Forsslund found that using LuaJIT significantly sped up the Lua event handling in his EU3 tests, getting closer to the performance target Paradox had set (though still slower than native C++) [8]. However, even with a JIT, frequent calls across the native/script boundary can remain costly. Developers often design around this by triggering scripts only for higher-level events rather than inside tight loops that run every frame.\nOption 2: Create a Domain-Specific Language (DSL) Instead of embedding an existing language, some developers create their own custom language tailored specifically for modding their game. These DSLs are often not full-fledged programming languages but rather specialized formats for configuring game behavior or defining content.\nParadox Interactive’s Clausewitz Scripting This is the quintessential example. Games like Europa Universalis IV, Crusader Kings III, Hearts of Iron IV, Stellaris, etc., use a proprietary scripting syntax (often in .txt files, despite sometimes involving Lua for specific functions internally) to define almost everything: events, decisions, national focuses, technologies, AI behavior, map data, etc. [3] [13]. It uses a nested key-value structure with braces, looking somewhat declarative.\nHere’s a hypothetical snippet resembling a Paradox event script:\n# Example Event Definition in a Paradox-style DSL country_event = { id = my_awesome_mod.101 title = \"MY_MOD_EVENT_101_TITLE\" # Loc key desc = \"MY_MOD_EVENT_101_DESC\" # Loc key picture = GFX_event_mymod_picture is_triggered_only = yes # Means it won't fire randomly trigger = { # Conditions for the event to be possible has_dlc = \"My Awesome DLC\" # Example check government = democracy NOT = { has_country_modifier = recently_had_event_101 } } mean_time_to_happen = { months = 120 # Average time for it to fire if conditions met modifier = { factor = 0.8 # Faster if... has_idea_group = economic_ideas } } immediate = { # Effects that happen instantly when the event fires add_stability = -1 add_country_modifier = { name = \"recently_had_event_101\" duration = 3650 # 10 years } } option = { # First choice for the player name = \"MY_MOD_EVENT_101_OPT_A\" # Loc key ai_chance = { factor = 70 } add_treasury = 100 add_prestige = 5 } option = { # Second choice name = \"MY_MOD_EVENT_101_OPT_B\" # Loc key ai_chance = { factor = 30 } add_inflation = 2.0 } } Notice how it’s structured around game concepts (trigger, mean_time_to_happen, option, effect like add_stability) rather than generic programming constructs like if/else or for loops (though the engine evaluates these triggers logically).\nBethesda’s Papyrus Used in games like Skyrim and Fallout 4, Papyrus looks more like a traditional scripting language but is still a DSL created specifically for Bethesda’s Creation Engine. It’s event-driven and designed for attaching scripts to objects in the game world. While more powerful than Paradox’s declarative style, it’s still limited compared to a general-purpose language (e.g., no direct file I/O for mods).\nPros of DSLs Performance DSLs can be heavily optimized. The game engine parses the DSL script (often at load time) and converts it into an internal representation that can be executed very efficiently in native code (like C++). Forsslund’s study confirmed this: the original EU3 event system using parsed DSL scripts was significantly faster than his Lua prototype [8]. Paradox likely stuck with their DSL approach precisely because performance is critical in their complex simulations.\nSafety by Design Because the DSL only includes commands relevant to the game, it’s inherently sandboxed. There’s simply no syntax in Paradox script for “delete file” or “connect to internet.” The language itself restricts mods to interacting with the game through predefined, controlled mechanisms (like specific triggers and effects). Security comes from limited expressiveness.\nEase of Use (Potentially) For non-programmers, a well-designed DSL that uses game-specific terminology might be easier to grasp than learning a full programming language. Adding a new country event in Paradox script might feel more intuitive than writing equivalent logic in Lua or C#.\nEnforces Game Structure DSLs can guide modders into creating content that fits the game’s intended structure and rules.\nCons of DSLs Learning Curve Every DSL is unique. Modders have to learn a new, often proprietary, syntax and vocabulary for each game (or game engine). Documentation might be sparse or community-driven.\nLimited Power DSLs are, by definition, domain-specific. Modders might hit a wall if they want to implement something complex or novel that the DSL wasn’t designed for. You can’t easily write a new pathfinding algorithm or a complex economic simulation using only Paradox event script commands. Modders sometimes have to resort to clever workarounds or request new features from the developers.\nDeveloper Burden The game developers have to design, implement, document, and maintain the DSL and its parser/interpreter. If modders need new functionality, developers might have to add new keywords or commands to the language itself, which can be time-consuming.\nHybrid Approaches Some games try to get the best of both worlds. They might use a simple data format or DSL for common tasks (like defining items or basic quests) and embed a general-purpose language (like Lua) for more complex scripting needs (like custom AI behaviors or intricate quest logic). This offers an easier entry point while still providing power for advanced users. Forsslund even mused about using Lua for prototyping event logic due to its flexibility and then potentially translating it back to the faster DSL format for release, though this seems rare in practice [8] [8].\nSo, Which to Choose? The decision often boils down to the game’s specific needs and the developer’s philosophy:\nIf performance is absolutely critical (e.g., complex simulations running thousands of checks per second) and the types of mods expected are mostly content-focused within predictable boundaries, a DSL might be the better choice (Paradox). If flexibility and empowering modders to create truly novel systems is the priority, and the performance overhead is acceptable (or can be managed), an embedded general-purpose language is often preferred (Factorio with Lua, RimWorld with C#). If the game is built in an engine like Unity or uses .NET, allowing mods in the same language (C#) becomes a natural, powerful option, effectively turning the game’s own codebase/API into the “language” for mods (RimWorld, Bannerlord). Now that we’ve considered the language mods are written in, let’s look at how that code actually gets executed by the game.\nHow Mods Run: Interpreted vs. Compiled Execution This is another fundamental fork in the road for modding architecture. Does the game run mod code directly from source files (or intermediate bytecode) at runtime, or does it load pre-compiled binary files (like DLLs)? This choice deeply impacts performance, security, and the mod development workflow.\nLet’s visualize the difference conceptually (imagine a diagram here, as generating one directly is tricky):\nScenario A: Interpreted Mod Modder writes MyMod.lua (source code). Player installs MyMod.lua. Game starts, loads MyMod.lua. Game embeds a Lua Virtual Machine (VM). When needed, the Game Engine tells the Lua VM: “Run this function from MyMod.lua.” The Lua VM interprets (or JITs) the Lua code and executes it, calling back into the Game Engine API for game data/actions. Scenario B: Compiled Mod Modder writes MyMod.cs (source code). Modder uses a C# compiler (like csc or via Visual Studio) to build MyMod.dll (binary code). Player installs MyMod.dll. Game starts, uses the operating system or .NET runtime to load MyMod.dll directly into its own process memory. When needed, the Game Engine directly calls functions within MyMod.dll (like methods in a C# class). The code inside MyMod.dll runs as native (or JIT-compiled) code, calling back into the Game Engine API. Now let’s unpack the implications.\nInterpreted Mods (Runtime Scripting) In this model, the mod code isn’t native machine instructions when the player installs it. The game itself contains the necessary machinery (an interpreter or a VM) to execute the mod scripts on the fly.\nHow it Works The game loads the script files (e.g., .lua, .py). It might parse them line-by-line (very slow, rare nowadays) or, more commonly, compile them into an intermediate bytecode format first (Lua does this automatically). Then, an interpreter executes this bytecode. Sometimes, a Just-In-Time (JIT) compiler might even translate frequently used parts of the bytecode into native machine code at runtime for better speed.\nExamples Games using Lua (like Factorio), Python (Civ IV), or potentially JavaScript. Even Paradox’s DSLs are essentially interpreted – the engine parses the .txt files and executes the logic they represent.\nPros of Interpreted Mods Easier Development Modders often just need a text editor. There’s no separate compilation step. They can make changes and (sometimes) see results quickly, leading to faster iteration.\nCross-Platform Compatibility A Lua script mod will generally work identically on Windows, macOS, or Linux versions of the game, as long as the game itself includes the Lua interpreter for each platform. The mod code is platform-agnostic.\nEasier Sandboxing As we discussed, the interpreter acts as a natural choke point. The game developer can control the environment the interpreter provides to the script, removing dangerous functions or libraries (like file I/O or network access). This makes sandboxing much more feasible than with compiled code.\nCons of Interpreted Mods Performance This is the big one. Even with bytecode compilation and JITs, interpreted code is generally slower than fully pre-compiled native code. We saw Forsslund’s 6x slowdown figure for Lua vs C++ [8]. The overhead comes from the interpretation/JIT process itself and the cost of crossing the boundary between the native game engine and the scripting VM (data marshaling, function call setup) [8]. This might be perfectly acceptable if mods only run occasionally for non-critical tasks, but prohibitive if mods need to run complex logic every frame.\nRequires Embedding Runtime The game developer needs to integrate and ship the language interpreter/VM with the game.\nCompiled Mods (Native or Bytecode Plugins) Here, mods are distributed as binary files (like .dll on Windows, .so on Linux, or .jar containing Java bytecode) that the game loads directly into its process space.\nHow it Works The game uses the operating system’s dynamic library loading mechanism (like LoadLibrary on Windows) or a runtime environment’s assembly loading feature (like .NET’s Assembly.Load or the Java Virtual Machine’s classloader) to load the mod’s binary file. The code in the mod then runs essentially as part of the game itself.\nExamples Mount \u0026 Blade II: Bannerlord (C# DLLs loaded via .NET) [5], RimWorld (C# DLLs loaded via Unity/.NET), Minecraft ( Java JARs loaded by Forge/Fabric via the JVM), Kerbal Space Program (C# DLLs). Many games using engines like Unity or Unreal might implicitly support compiled mods if modders can figure out how to get their compiled assemblies loaded, even without official sanction.\nPros of Compiled Mods Performance This is the main advantage. Compiled code runs at or near native speed. A C# mod in Bannerlord or RimWorld executes much like the game’s own C# code. A C++ mod compiled to a DLL would run just as fast as the engine’s C++. This enables incredibly complex mods – total conversions, new physics systems, sophisticated AI – that might be computationally infeasible with slower scripting languages.\nPower \u0026 Flexibility Modders typically get access to the full power of the language the mod is written in (C++, C#, Java). They can use complex language features, interact more deeply with the engine’s API (if exposed), and potentially link against external libraries (though this adds complexity and risk).\nCons of Compiled Mods Development Complexity Modders need a proper development environment: a compiler, potentially the game’s specific SDK or header files/library references. The workflow involves writing code, compiling, packaging, and then testing in-game. This is a higher barrier to entry than editing a script file.\nCompatibility Issues Compiled mods are often tightly coupled to a specific version of the game or engine API. When the game updates, internal changes (like function signatures changing, classes being refactored, memory layouts shifting in C++) can easily break compiled mods, requiring the mod author to update and recompile. This is a constant headache in communities like Minecraft or Bannerlord.\nPlatform Dependence A DLL compiled for Windows won’t work on Linux or macOS. While managed runtimes like .NET and Java offer better cross-platform potential (compile to intermediate bytecode), native C/C++ mods are inherently platform-specific.\nSecurity Nightmare This is the biggest drawback. By default, a compiled mod loaded into the game’s process has the exact same permissions as the game itself. If the game is running as the user, the mod can do anything the user can do: read/write arbitrary files, connect to the internet, launch other processes, install malware, delete system32 (okay, maybe not that easily, but you get the idea). There is no inherent sandbox. We’ll talk more about security later, but compiled mods basically operate on trust [12].\nStability Risks A bug in a compiled mod (like a null pointer dereference, an unhandled exception, or an infinite loop) can easily crash the entire game process, not just the mod’s operation.\nA Potential Middle Ground: Managed Runtimes and Future Tech It’s worth noting that compiled mods in managed languages like C# or Java occupy a slightly different space than native C++ DLLs. The runtime environment (CLR for .NET, JVM for Java) does provide some layer of abstraction and safety ( e.g., memory safety, garbage collection). Historically, these runtimes also had security managers or code access security systems (like .NET CAS) designed to run untrusted code with limited permissions [12]. However, these features are largely deprecated or considered ineffective/too complex for robust sandboxing in modern versions, especially within a single process [12]. So, in practice, C# mods in RimWorld or Bannerlord still run with full trust.\nLooking ahead, technologies like WebAssembly (WASM) offer a tantalizing possibility. WASM is a binary instruction format designed to be a portable compilation target for high-level languages, enabling deployment on the web for client and server applications. Crucially, it’s designed to run safely in a sandboxed environment, with near-native performance. Could future games allow mods compiled to WASM? It might offer the speed benefits of compiled code with the security benefits of a sandbox. This is an active area of interest we’ll revisit in the “Future Directions” section.\nSummary Table: Interpreted vs. Compiled Feature Interpreted Mods (e.g., Lua, Python, DSLs) Compiled Mods (e.g., C# DLLs, Java JARs, C++ DLLs) Performance Generally Slower (VM overhead, boundary crossing) Generally Faster (Native or near-native speed) Dev Ease Easier (Text editor, no compile step, faster iteration) Harder (Compiler, SDK, build process needed) Flexibility Limited by exposed API \u0026 language features High (Full language power, potentially external libraries) Compatibility Often better survives game updates (if API stable) Often breaks with game updates (tight coupling) Cross-Platform Good (Script runs on any platform with game+VM) Poor (Native DLLs), Better (Managed bytecode like .NET/Java) Security Easier to Sandbox (Control VM environment, limit API) Very Hard to Sandbox (Runs with full game permissions) Stability Errors might be caught by VM (less likely to crash game) Errors can easily crash the entire game process Developers must weigh these factors carefully. If they want to enable deep, complex mods and trust their community (or implement external security measures), compiled mods offer the most power. If they prioritize accessibility, safety, and easier maintenance, interpreted scripts are often the way to go. Many successful modding scenes exist at both ends of this spectrum.\nNow, assuming we’ve chosen a language and execution model, how does the game actually find, load, and run these mods?\nBringing Mods to Life: Loading and Lifecycle Integration Okay, so players have downloaded some mods. How does the game actually know they exist, load their content and code, and make sure they run at the right moments without stepping on each other’s toes? This involves designing a robust mod loading system and integrating mods into the game’s lifecycle.\nFinding and Identifying Mods First, the game needs to locate installed mods. Common strategies include:\nDedicated Mods Folder The simplest approach. The game looks inside a specific folder (e.g., My Documents/MyGame/Mods/ or /Mods/) for subfolders or archive files representing individual mods.\nLauncher Manifests Some games use a launcher application that manages mods. The launcher might maintain a list or configuration file specifying which mods are enabled and where they are located. Bannerlord’s launcher does this, reading module information before starting the game proper [5].\nPlatform Integration Increasingly common is integration with platforms like Steam Workshop. Players subscribe to mods on Workshop, and the Steam client downloads them to a specific location. The game then uses the Steam API to find and load subscribed mods.\nOnce found, each mod usually needs a descriptor file (sometimes called a manifest). This file contains metadata about the mod, such as:\nUnique ID, Name, Author, Version Description Dependencies (other mods it requires) Load order hints Entry points (e.g., the main script file to run, or the DLL and class name to load). Bannerlord’s SubModule.xml is a prime example of such a descriptor, containing all this information [5] [5]. RimWorld uses an About.xml file for basic metadata [4].\nLoading Mods: Order Matters! The game (or its launcher/mod manager) reads these descriptors, decides which mods are active, and then proceeds to load them. This typically happens during game startup, before the main menu appears.\nA critical aspect here is load order. If two mods modify the same game asset or piece of logic, which one “wins”? Most systems adopt a “last loaded wins” rule. Mod A changes weapon damage to 10, Mod B loads later and changes it to 15 – the final damage will be 15.\nThis makes the order in which mods are loaded crucial for compatibility. Many games allow players to manually set the load order through a mod manager UI (common in Bethesda games, Paradox games via launchers). The mod descriptor file might also specify dependencies (e.g., “MyMod requires CoreLibraryMod version 1.2+”). The mod loader must respect these dependencies, ensuring CoreLibraryMod is loaded before MyMod. If dependencies are missing or versions conflict, the loader should ideally warn the user or disable the problematic mod. Tools like LOOT (Load Order Optimization Tool) for Bethesda games automate the process of sorting mods based on known compatibility rules.\nThe Mod Lifecycle: Initialization and Execution Hooks Once a mod’s files (data, scripts, binaries) are loaded into memory, its code often needs to run at specific points in the game’s lifecycle. A typical flow looks like this:\nLoad The game loads the mod’s assets and code.\nInitialize The game calls an initialization function or method in the mod. This is where the mod usually sets itself up, registers things with the game engine, or applies patches.\nRuntime Hooks During gameplay, the game triggers the mod’s code in response to specific events or at regular intervals.\nInitialization: Script Mods Might have a specific init() function the engine calls after loading the script. Or the script might just run top-to-bottom, registering event handlers as it goes.\nCompiled Mods Often have a designated entry point class. Bannerlord mods inherit from MBSubModuleBase and override methods like OnSubModuleLoad() [5]. RimWorld mods can have a class inheriting from Verse.Mod, whose constructor acts as the init hook [4]. Minecraft Forge defines a whole sequence of initialization events (FMLPreInitializationEvent, FMLInitializationEvent, FMLPostInitializationEvent) that mods listen for, ensuring things happen in the right order (e.g., all items registered before recipes) [14].\nThis initialization phase is crucial for mods to tell the game “I exist, and here’s what I do.” They might register new item types, add UI elements, subscribe to game events, or (in the case of patching libraries like Harmony) apply their modifications to the game’s base code.\nRuntime Execution Hooks After initialization, how does mod code get triggered during actual gameplay? Developers provide various “hooks”:\nEvent Callbacks / Subscriptions This is very common. The game engine defines a set of events (e.g., OnPlayerDamaged, OnQuestStarted, OnTick, OnGuiRender). Mods can register functions (callbacks) to be executed whenever a specific event occurs. The engine manages firing these events and calling all subscribed mod functions, often passing event-specific data (like the amount of damage taken, or the quest ID).\nFactorio’s script.on_event(defines.events.EVENT_NAME, function(event_data) ... end) is a classic example [6]. Paradox’s DSL works similarly; event blocks have trigger conditions the engine constantly checks, and immediate or option effects that run when triggered [15]. Minecraft Forge has an extensive event bus (MinecraftForge.EVENT_BUS) covering hundreds of game actions. Bannerlord’s CampaignEvents system allows mods to subscribe to things like DailyTickEvent. Method Overrides / Subclassing If the game’s architecture uses object-oriented principles heavily, it might allow mods to subclass existing game classes and override virtual methods to change behavior. Bannerlord does this with its CampaignBehaviorBase, allowing mods to add custom logic to the campaign loop.\nDirect Patching (e.g., Harmony) This is a more invasive but powerful technique, extremely popular in the Unity C# modding scene (RimWorld, Kerbal Space Program, Cities: Skylines, sometimes Bannerlord). Libraries like Harmony allow mods to dynamically modify the intermediate language (IL) bytecode of existing game methods at runtime. Mods can:\nPrefix Run code before the original method executes. Can modify arguments or even skip the original method entirely.\nPostfix Run code after the original method executes. Can access the return value and modify it.\nTranspiler Directly rewrite the IL instructions of the original method. Extremely powerful, but complex and fragile.\nRimWorld mods use Harmony extensively to alter core game mechanics without needing the developers to provide explicit hooks for everything [12]. While powerful, multiple mods patching the same method can lead to compatibility nightmares if not carefully managed.\nTick/Update Hooks Some systems allow mods to register a function that gets called every game frame or every simulation tick (e.g., OnApplicationTick in Bannerlord, or update loops in Unity). This is necessary for mods that need continuous processing, but must be used cautiously to avoid performance degradation.\nHandling Mod Errors: What happens if a mod script has a bug or a compiled mod throws an exception? A robust modding framework should anticipate this. Ideally, the game engine should wrap calls into mod code within error handlers (like try-catch blocks). If a mod crashes:\nLog the error clearly, indicating which mod caused it. Prevent the error from crashing the entire game if possible. Potentially disable the faulty mod for the rest of the session. Notify the user about the issue. Games like RimWorld are pretty good at catching mod errors and displaying a debug log window without necessarily crashing, allowing the player to continue (though the game state might be compromised).\nDynamic Loading (Hot Swapping)? Can you install or uninstall mods while the game is running? Usually, no. Most games require a restart for mod changes to take effect. Why? Because mods often need to integrate deeply during the initial loading phase (registering items, patching code). Injecting or removing this integration into a live, running simulation state is extremely complex and prone to errors. It’s much simpler and safer to load everything upfront.\nHowever, some systems are exploring partial runtime loading, especially for assets or data-driven content [16], but runtime code injection/removal remains rare in mainstream modding.\nAn interesting related concept is parallelized loading. Minecraft Forge, facing long startup times with large modpacks, implemented parallel loading for certain initialization phases to speed things up, carefully managing dependencies and synchronization between stages [14].\nResource Loading Mods aren’t just code; they often include assets (textures, models, sounds) and new data definitions. The modding framework needs to handle loading these too. Common approaches include:\nFile Overrides A simple method where mod files placed in the correct directory structure simply override the base game files with the same name. Older games often used this. Fragile, as multiple mods overriding the same file causes conflicts.\nVirtual File Systems / Archives Games like Skyrim use archive files (.bsa) and a system where loose files in a Data folder (often managed by mod managers) take precedence over archives, and load order determines which loose file wins if multiple mods provide the same one.\nData Merging For structured data (like lists of items or events), the engine might merge data from multiple mods. Paradox games effectively do this, combining event files, localization strings, etc., from all active mods into the game’s runtime database.\nAPI-Driven Loading The modding API might provide functions for mods to explicitly load their own assets (e.g., LoadTexture(\"mymod/textures/cool_gun.png\")) or register new data entries programmatically.\nA well-designed system makes it clear how mod resources are integrated and how conflicts are resolved.\nIn essence, managing the mod lifecycle is about orchestrating the discovery, loading, initialization, and runtime execution of potentially many independent pieces of user content, ensuring they play nicely together (as much as possible) and integrate seamlessly into the game’s flow.\nNow, for the part that keeps developers up at night…\nThe Elephant in the Room: Security and Sandboxing Okay, let’s talk security. We’ve established that mods, especially compiled ones, can be incredibly powerful. They run code directly on the player’s machine, often within the game’s own process. What stops a malicious mod author from slipping malware into their “Awesome New Sword” mod?\nHonestly? In many cases, not much technical enforcement.\nThe Current Reality: Trust, Community, and Hope A recurring theme in discussions about mod security for single-player PC games is that the primary defense mechanism is not a technical sandbox, but rather community trust and platform curation. A GitHub discussion involving developers wrestling with this exact problem concluded: “Most games do not impose any kind of security restrictions on mods and rely on community trust.” [12].\nThis plays out in several ways:\nReputable Sources Players are generally advised to download mods only from well-known platforms (Steam Workshop, Nexus Mods, official game forums, reputable community sites like ModDB). These platforms often have moderation teams and community reporting systems to catch malicious uploads.\nCommunity Vetting Popular mods are downloaded and used by thousands of players, including many technically savvy ones. If a mod started doing suspicious things (like making weird network calls or messing with system files), it would likely be noticed and reported quickly. Open-source mods are even easier to inspect.\nAntivirus Software Basic antivirus scanning might catch known malware signatures packaged within mod files [17]. After a malware scare involving a Cities: Skylines mod, Paradox stated that mods uploaded to their Paradox Mods platform undergo antivirus scanning [18].\nDeveloper Warnings Some developers explicitly warn players about the risks. The Bannerlord launcher, for example, displays a message cautioning users about running unverified DLLs from mods.\nBut is this enough? History suggests maybe not. There have been notable incidents:\nDota 2 Mods (2023) Malicious mods uploaded to the Steam Workshop exploited a vulnerability in the game’s JavaScript engine (Panorama UI) to gain remote code execution capabilities on users’ machines [11]. This wasn’t just a mod using legitimate APIs maliciously; it was exploiting a flaw in the sandbox itself.\nMinecraft Mods (Various) The large, somewhat unregulated Minecraft modding scene has seen multiple instances of malware distributed through mods on platforms like CurseForge, ranging from credential stealers to ransomware [19] [20].\nCities: Skylines Malware (2022) A mod author was found distributing malware through several popular mods on the Steam Workshop.\nBannerlord Concerns Even without specific major incidents (yet), the community has voiced unease about the inherent risk of loading arbitrary DLLs, questioning why a potentially safer scripting approach wasn’t chosen [21].\nThese cases highlight that relying solely on trust and community moderation isn’t foolproof, especially as modding becomes more mainstream and potentially attracts more malicious actors. So, what technical solutions exist or could be used?\nSandboxing Script Mods: The Easier Path If your game uses an interpreted scripting language like Lua or Python, you have a much better chance of effectively sandboxing mods. The interpreter itself provides a natural boundary.\nHow it Works When the game engine initializes the scripting environment for a mod, it can deliberately limit the functions and libraries available to that script.\nFor Lua, this is relatively straightforward. The host application (the game) controls the global environment table that scripts run in. You can simply not load dangerous standard libraries like io (file input/output) and os ( operating system commands). You can also replace or wrap built-in functions. The mod only gets access to the functions and game objects explicitly exposed through the C API bindings created by the developer. World of Warcraft’s UI modding system is a prime example of a heavily sandboxed Lua environment. Addons can manipulate the UI and query some game data, but they absolutely cannot access the local file system or make arbitrary network calls. Certain sensitive API calls are even restricted during combat to prevent automation (“protected functions”). Python sandboxing is possible but generally considered harder due to the language’s size and dynamic nature. Techniques involve using restricted execution modes, customizing the available built-in modules, or running the Python interpreter within an OS-level sandbox. Effectiveness API-level sandboxing for scripts is quite effective at preventing mods from directly causing harm outside the game ( like deleting files). It doesn’t necessarily prevent mods from crashing the game or behaving badly within the game’s logic (e.g., infinite loops, excessive resource consumption), but it significantly contains the risk.\nSandboxing Compiled Mods: The Herculean Task This is where things get really difficult. Compiled code (C++, C#, Java bytecode) running in the same process as the game has, by default, the same access rights. Truly isolating it is a major challenge.\nWhy it’s Hard: There’s no natural interpreter boundary to control. The mod code is executing directly (or via a JIT) on the CPU. Preventing it from making system calls (like opening files or network sockets) requires intervening at a lower level.\nApproaches (Mostly Theoretical or Limited) OS-Level Sandboxing Run the entire game process within an operating system sandbox (like a container, Windows AppContainer, macOS App Sandbox). This limits what the whole game (including mods) can do. While effective for security, it can be overly restrictive, potentially breaking legitimate game features (like saving games anywhere, interacting with peripherals) and might not be feasible for traditional PC game distribution models (e.g., Steam games usually run with full user privileges).\nProcess Isolation: Run each mod (or the modding subsystem) in a separate process with lower privileges. The main game process communicates with the mod process via Inter-Process Communication (IPC). This is how web browsers sandbox tabs/extensions [12].\nPros Strong isolation. A crash in the mod process doesn’t take down the game. OS enforces privilege separation.\nCons Huge architectural complexity for the game engine (managing multiple processes, efficient IPC for game data). Significant performance overhead due to IPC. Very few games attempt this for modding.\nManaged Runtime Security (Deprecated/Ineffective) As mentioned, .NET’s Code Access Security (CAS) and Java’s Security Manager were attempts to allow restricting permissions for loaded assemblies/classes within the same process. However, CAS is deprecated and complex, and wasn’t fully supported in Mono/Unity anyway [12]. Modern consensus is that achieving reliable in-process sandboxing this way is extremely difficult, if not impossible [12]. Unity games using Harmony definitely don’t operate under any such restrictions.\nStatic Analysis / API Whitelisting Instead of trying to restrict at runtime, analyze the mod’s binary code before loading it (or at load time).\nTools like Unbreakable (mentioned in the GitHub discussion, used by SharpLab) analyze .NET assemblies to check which APIs they call [12]. It works by maintaining a whitelist of allowed namespaces/methods. If a mod tries to use anything forbidden (like System.IO or System.Net), the analysis fails [12].\nPros Can catch attempts to use obviously dangerous APIs without runtime overhead.\nCons Not foolproof (clever attackers might obfuscate calls or use reflection). Requires maintaining the whitelist. Might have false positives/negatives. Doesn’t prevent logic bombs or resource exhaustion attacks.\nPractical Use A game could scan mod DLLs using such a tool and refuse to load mods that fail the check, or (more pragmatically) simply warn the user that the mod uses potentially unsafe APIs and let them decide whether to proceed [12].\nSystem Call Interception / Runtime Monitoring Use techniques like API hooking or kernel-level monitoring to watch what the mod code actually does at runtime. If it tries to make a forbidden system call (e.g., CreateFile outside its allowed directory), the monitor could block it or prompt the user. This is complex to implement robustly and can have performance implications.\nThe Takeaway Effectively sandboxing compiled mods running in the same process is really hard with current mainstream technologies. Most games simply don’t attempt it, accepting the risk and relying on the community/platform defenses.\nMinecraft: A Tale of Two Editions Minecraft’s approach is illustrative. The original Java Edition allows compiled Java mods (via Forge/Fabric) that run with full JVM permissions – essentially unsandboxed. Mojang never implemented a robust security model for this. When faced with bringing mods to platforms where security is paramount (consoles, mobile), they created Bedrock Edition, which uses a completely different “Add-On” system. Bedrock Add-Ons are primarily data-driven (JSON files) with limited scripting capabilities using a sandboxed JavaScript-like API. This severely restricts what mods can do compared to Java Edition, but provides a much safer environment suitable for cross-platform play and curated marketplaces. It shows that sometimes the solution to retrofitting security onto an open system is to create a separate, more restricted system alongside it.\nWhere Does This Leave Us? For single-player PC games, the status quo is largely “modder/player beware,” especially for games allowing compiled mods. While outright malicious mods seem relatively rare compared to the sheer volume of mods available, the potential risk is undeniable and incidents do happen. Scripting languages offer a much clearer path to technical sandboxing via API control, and developers using them should absolutely leverage that capability. For compiled mods, the industry seems to be waiting for better, more practical sandboxing technologies to emerge (like WASM?) or relying on platform-level solutions (better Workshop scanning, OS sandboxing features).\nLet’s now see how these concepts play out in practice by looking at some specific games known for their modding scenes.\nReal-World Examples: Case Studies in Modding Tech Theory is great, but let’s see how different games have actually implemented mod support, embodying the choices and trade-offs we’ve discussed.\nCase Study 1: Paradox Grand Strategy Games (Clausewitz/Jomini Engine) - The DSL Kings Paradox Interactive’s titles (Europa Universalis IV, Crusader Kings III, Hearts of Iron IV, Stellaris, Victoria 3) are legendary for their depth and equally legendary for their moddability. Total conversion mods that create entirely new historical or fantasy settings are commonplace. How do they achieve this? Primarily through a data-driven approach using a proprietary Domain-Specific Language (DSL).\nEngine \u0026 Language These games run on the in-house Clausewitz engine (with newer games incorporating a shared layer called Jomini). Modding is done almost entirely by editing or adding plain text files (.txt, .yml, sometimes .lua for specific scripting tasks). These files use Paradox’s unique scripting syntax to define everything from countries, characters, events, decisions, technologies, graphics, and even AI weighting [3] [22]. It’s a declarative, key-value based language optimized for strategy game concepts. (See the DSL example snippet in the Languages section above).\nExecution The engine parses these script files at game startup. It doesn’t interpret them line-by-line during gameplay. Instead, it converts the logic (especially things like event triggers and AI weights) into an internal representation that can be evaluated very quickly by the core C++ engine [8]. This is key to maintaining performance even with thousands of potential events or complex AI calculations running in the background. The performance cost is front-loaded into the initial game load time.\nNo Arbitrary Code Crucially, mods cannot inject arbitrary compiled code (no DLLs). Modders are constrained to work within the vocabulary and structure provided by the Paradox scripting DSL. If you want to do something the DSL doesn’t support (like implement a radically new UI paradigm or a fundamentally different economic model), you’re generally out of luck unless Paradox adds the necessary script commands in a future update.\nLoading \u0026 Lifecycle Mods are managed via the game’s launcher, which reads .mod descriptor files. The launcher handles enabling mods and setting load order. The game then merges data from all active mods at startup. During gameplay, mod logic is typically triggered by the engine evaluating event conditions or AI decision factors based on the loaded scripts. Mods don’t usually run continuous code; they react to game state changes.\nSecurity Because mods are restricted to the DSL, they are inherently sandboxed from a system perspective. A Paradox mod can’t read your files or install malware. The worst it can do is mess up your game state (which can still be annoying!). This design choice neatly sidesteps the security nightmare of compiled mods. (The Cities: Skylines malware incident mentioned earlier involved a Paradox-published but not Paradox-developed game using the Unity engine with C# mods – a completely different technical scenario).\nCommunity \u0026 Tools Paradox actively supports modding with official wikis documenting the script commands [15] and integrates mod distribution via Paradox Mods and Steam Workshop [23]. The community has built extensive knowledge bases and tools (like syntax highlighters and validation utilities) around the Clausewitz scripting language.\nWhy this approach? It perfectly suits complex simulation games where performance and stability are paramount. It allows enormous content and rule modifications within a controlled framework, fostering a huge modding scene focused on historical accuracy, alternate history, or fantasy conversions. The limitations on arbitrary code are accepted as a reasonable trade-off for stability and inherent safety. Forsslund’s research showing their native script parsing outperformed embedded Lua likely solidified their commitment to this DSL-centric approach [8].\nCase Study 2: RimWorld - XML, C#, and Harmony Mayhem RimWorld, the sci-fi colony sim by Ludeon Studios, represents a different philosophy, embracing the power (and perils) of compiled code within the popular Unity engine.\nEngine \u0026 Language Built on Unity, RimWorld uses C# for its core logic. Modding leverages this directly:\nXML Definitions A huge amount of game content (items, pawns, buildings, research projects, incidents, etc.) is defined in XML files. This provides an accessible entry point for modders – adding a new rifle or alien race can often be done just by creating new XML defs or patching existing ones [4] [24]. This is the data-driven part.\nC# Assemblies For anything more complex – new behaviors, UI changes, altered game mechanics – modders write code in C# and compile it into .DLL assemblies. The game loads these DLLs at startup [4].\nThe “API” (and lack thereof) While RimWorld exposes many of its C# classes and methods as public, it doesn’t have a strictly defined, stable \" Modding API\" in the traditional sense. Modders often need to decompile the game’s assemblies (Assembly-CSharp.dll) using tools like dnSpy or ILSpy to understand how the base game works and find the classes/methods they need to interact with or modify [7]. Documentation is largely community-driven (like the RimWorld Wiki) [4].\nHarmony Patching This is the secret sauce (or Pandora’s Box) of RimWorld modding. The game includes the Harmony library, which allows mods to perform runtime IL patching of existing game methods (Prefix, Postfix, Transpiler) [12]. This means mods can fundamentally alter almost any aspect of the game’s behavior, even methods the developer never intended to be moddable, without needing source code access. Want to change how colonists prioritize tasks? Patch the job assignment methods. Want to add psychic space llamas? Patch the animal spawning logic. This provides incredible power and flexibility.\nExample Harmony Patch (Conceptual):\nusing HarmonyLib; using Verse; // RimWorld's core namespace [HarmonyPatch(typeof(Pawn_JobTracker), \"DetermineNextJob\")] // Target the job finding method public static class Patch_JobFinder { // Run *after* the original method finds a job static void Postfix(ref ThinkResult __result, Pawn ___pawn) { // If the original method found a job, and our mod wants pawns to prioritize hauling... if (__result.Job != null \u0026\u0026 ___pawn.story?.traits?.HasTrait(MyModDefOf.ObsessiveHauler) == true) { // ...maybe try to find a hauling job instead, even if it's lower priority originally. // (Actual logic would be more complex, finding hauling jobs etc.) // If we find a better hauling job, replace __result.Job with it. } } } Execution \u0026 Performance C# mods run as JIT-compiled .NET code, offering good performance. However, heavy use of Harmony patching can introduce overhead, as each patched method call might involve extra hops through prefix/postfix code. Poorly optimized mods, especially those hooking into frequent updates, can definitely impact game speed.\nLoading \u0026 Lifecycle Mods are loaded from a Mods folder or Steam Workshop at startup. Load order is crucial and user-configurable. Mods with code typically have a class inheriting from Verse.Mod; its constructor is called during initialization, often used to apply Harmony patches or load settings. Runtime execution depends on what the mod does – event subscriptions (via patching), Harmony patches triggering on specific method calls, or custom Comp (component) classes attached to game objects that receive updates.\nSecurity There is no sandbox. RimWorld mods run with full .NET permissions within the game’s process. A malicious mod could theoretically do anything. The community relies entirely on trust, platform moderation (Steam Workshop), and the fact that the developer (Tynan Sylvester) has fostered a generally positive and collaborative modding environment. Stability is also a concern; conflicting Harmony patches or buggy mod code can cause errors or crashes, though RimWorld’s error handling often catches these and allows the game to continue (with a red error log).\nCommunity \u0026 Tools Despite the lack of a formal API, the community thrives, using decompilers, community wikis, shared libraries like HugsLib (for common modding utilities), and tools to debug Harmony patch conflicts. The accessibility of XML combined with the power of C#/Harmony has created one of the most vibrant modding scenes around.\nWhy this approach? It maximizes modder freedom and creativity, leveraging the power of the Unity/C# environment. By including Harmony, the developers essentially acknowledged that modders would find ways to patch the game anyway and provided a standardized (if powerful) way to do it. The trade-off is a higher reliance on community knowledge, potential instability from conflicts, and a complete lack of technical security enforcement.\nCase Study 3: Mount \u0026 Blade II: Bannerlord - Official Modules, Unofficial Risks TaleWorlds Entertainment’s Mount \u0026 Blade II: Bannerlord, a medieval sandbox RPG/strategy game, was developed with modding explicitly in mind, offering official tools and a structured system based on .NET.\nEngine \u0026 Language Bannerlord uses a custom engine, but a significant portion of the game logic is written in C#. Modding follows suit, primarily using C# compiled into DLLs, alongside XML for data definition [5] [25].\nModule System The game itself is structured into modules (Native, Sandbox, Storymode, etc.). Mods are simply additional modules. Each module has a SubModule.xml descriptor file specifying its ID, version, dependencies, and crucially, the DLL to load and the entry point class [5]. This provides a clear, structured way to organize and manage mods.\nOfficial API \u0026 Tools TaleWorlds provides official modding tools (including a scene editor) and relatively extensive API documentation [26] [5]. Modders write C# code referencing the official TaleWorlds.*.dll assemblies. The API provides base classes (like MBSubModuleBase) and event systems (CampaignEvents) for mods to hook into.\nExample Bannerlord Behavior (Conceptual):\nusing TaleWorlds.CampaignSystem; using TaleWorlds.Core; using TaleWorlds.MountAndBlade; public class MyBanditModSubModule : MBSubModuleBase { // Called when the game starts a campaign protected override void OnGameStart(Game game, IGameStarter gameStarterObject) { if (game.GameType is Campaign) { CampaignGameStarter campaignStarter = (CampaignGameStarter)gameStarterObject; // Add our custom behavior to the campaign campaignStarter.AddBehavior(new EnhancedBanditBehavior()); } } } // Our custom behavior logic public class EnhancedBanditBehavior : CampaignBehaviorBase { public override void RegisterEvents() { // Subscribe to the hourly tick event CampaignEvents.HourlyTickEvent.AddNonSerializedListener(this, OnHourlyTick); } public override void SyncData(IDataStore dataStore) { /* Handle save/load */ } private void OnHourlyTick() { // Every hour, maybe make bandits smarter or more aggressive... // Access game state via Campaign.Current, MobileParty.All, etc. } } Execution \u0026 Performance Mods are compiled C# DLLs loaded by the .NET runtime, running with excellent performance.\nLoading \u0026 Lifecycle The game launcher reads SubModule.xml files, resolves dependencies, and determines load order. Users can enable/disable modules and adjust order in the launcher. The engine then loads the specified DLLs and calls methods on the mod’s MBSubModuleBase subclass at specific lifecycle points (OnSubModuleLoad, OnGameStart, OnApplicationTick, etc.) [5]. Mods can then register for further events or add behaviors as needed.\nSecurity Like RimWorld, Bannerlord does not sandbox compiled mods. The DLLs run with full permissions. This has been a point of discussion and concern within the community [21]. TaleWorlds relies on user caution and platform trust. The official launcher explicitly warns about running unsigned code.\nStability Compiled mods mean game updates can easily break compatibility. TaleWorlds has worked to improve API stability over time, but modders often need to update their mods for new game versions. The structured module system and dependency management help mitigate some conflicts compared to a free-for-all patching system. While Harmony can be used in Bannerlord, many common modding tasks can be achieved via the official API hooks, potentially leading to fewer direct method conflicts than in RimWorld.\nWhy this approach? TaleWorlds aimed to provide powerful, official modding support from the start, recognizing the importance of mods to the Mount \u0026 Blade franchise. They opted for compiled C# mods within a structured module system, providing official tools and APIs. This enables deep modifications needed for total conversions (like popular Game of Thrones or Warhammer mods) but sacrifices inherent security. It’s a middle ground between Paradox’s safe-but-limited DSL and RimWorld’s wild-west Harmony patching.\nCase Study 4: Minecraft (Java Edition) - Community Forged Power Minecraft is a fascinating case because its massive modding scene emerged largely without official support in the early days, forcing the community to build the infrastructure themselves.\nEngine \u0026 Language Minecraft: Java Edition is, unsurprisingly, written in Java. Modding involves writing Java code compiled into .jar files.\nCommunity Loaders (Forge \u0026 Fabric) Since Mojang didn’t provide a modding API for years, the community stepped in. Minecraft Forge became the dominant mod loader. Forge works by patching the vanilla Minecraft Java bytecode at runtime to insert hooks, an event bus, and a mod loading system. Fabric is a newer, more lightweight alternative that uses the Mixin library to apply bytecode modifications more surgically. Both essentially create a moddable version of the game engine on the fly.\nThe “API” Forge and Fabric provide APIs that modders code against. These APIs offer abstractions over the (often obfuscated) internal Minecraft code, providing access to game objects, events, and registration systems. Modders typically need mappings (provided by the community) to deobfuscate Minecraft’s code during development.\nExample Forge Mod Structure (Conceptual):\nimport net.minecraftforge.fml.common.Mod; import net.minecraftforge.fml.common.event.FMLInitializationEvent; import net.minecraftforge.fml.common.event.FMLPreInitializationEvent; import net.minecraftforge.common.MinecraftForge; import net.minecraft.item.Item; // ... other imports @Mod(modid = MyMod.MODID, name = MyMod.NAME, version = MyMod.VERSION) public class MyMod { public static final String MODID = \"mymod\"; public static final String NAME = \"My Awesome Mod\"; public static final String VERSION = \"1.0\"; // Reference to the mod instance @Mod.Instance public static MyMod instance; // Example Item instance public static Item myAwesomeItem; @Mod.EventHandler public void preInit(FMLPreInitializationEvent event) { // Phase to register blocks, items, entities, etc. myAwesomeItem = new MyItem(); // Assume MyItem extends Item // ForgeRegistries.ITEMS.register(...); // Actual registration logic Log.info(\"My Mod PreInitialization complete.\"); } @Mod.EventHandler public void init(FMLInitializationEvent event) { // Phase to register recipes, event handlers, etc. MinecraftForge.EVENT_BUS.register(new MyEventHandler()); Log.info(\"My Mod Initialization complete.\"); } // ... potentially other event handlers (PostInit, ServerStarting, etc.) } Execution \u0026 Performance Mods are compiled Java bytecode running within the same Java Virtual Machine (JVM) as the game. Performance is generally very good thanks to the JVM’s JIT compiler, though large modpacks can strain CPU and memory resources due to the sheer amount of added content and logic.\nLoading \u0026 Lifecycle Forge/Fabric scan a mods folder for JAR files. They handle dependencies and load order. They provide a structured lifecycle with distinct phases (preInit, init, postInit) ensuring mods initialize in a coordinated manner [14]. Forge even parallelized parts of this to speed up loading [14]. Mods typically interact with the game via event subscriptions on the Forge/Fabric event bus or by registering their custom blocks/items/entities which then get handled by the modified game loop.\nSecurity Zero technical sandboxing. Java mods run with full permissions within the JVM. The Java Security Manager could have potentially been used, but wasn’t, and is now deprecated anyway. The community relies heavily on downloading from trusted sources (CurseForge, Modrinth) and community vigilance. However, as noted earlier, malware incidents have occurred, highlighting the risks of this open, community-driven ecosystem [19]. The Log4Shell vulnerability also impacted Minecraft and potentially mods using the vulnerable library.\nStability \u0026 Compatibility Game updates frequently break mods, as Mojang doesn’t maintain a stable API for the community loaders. Mod authors often have to scramble to update their mods for new Minecraft versions. Compatibility between mods within large modpacks can also be a significant challenge, requiring careful configuration and sometimes community-made compatibility patches.\nWhy this approach? It wasn’t really a deliberate design by Mojang, but rather an emergent phenomenon. The community desperately wanted deep modding capabilities and built the tools to make it happen by reverse-engineering and patching the game. This resulted in unparalleled creative freedom but also significant challenges in maintenance, stability, and security. Mojang eventually provided obfuscation mappings to help the community, but largely left the Java modding scene to its own devices while focusing on the safer, more limited Add-On system for Bedrock Edition.\nThese case studies showcase the spectrum: Paradox’s controlled DSL garden; RimWorld’s hybrid XML/C# approach amplified by Harmony; Bannerlord’s official but unsandboxed C# module system; and Minecraft’s community-built Java powerhouse. Each reflects different priorities and results in a distinct modding culture.\nSo, where does modding tech go from here?\nLooking Ahead: The Future of Modding Tech The world of game modding technology isn’t static. Developers, engine creators, and researchers are constantly exploring ways to make modding safer, more powerful, and easier for both creators and players. Here are some promising directions and research ideas, drawing inspiration from the challenges and successes we’ve seen:\nSafer, Performant Sandboxing: The WASM Hope (and others) The holy grail is achieving the security of interpreted scripts with the performance of compiled code. WebAssembly ( WASM) keeps coming up as a potential solution.\nThe Idea Games could define their modding API. Modders could write mods in various languages (C++, Rust, C#, Swift, AssemblyScript) that compile to WASM modules. The game engine would then embed a WASM runtime (like Wasmer, Wasmtime, or even browser engines) to execute these modules.\nWhy it’s Promising Security WASM runs in a sandbox by default. It has no access to the host system (files, network, etc.) unless the host (the game engine) explicitly provides functions (imports) to allow it. The engine could expose only the necessary game API functions, creating a tightly controlled environment. Memory safety is also a core design principle.\nPerformance WASM is designed for near-native performance, often using JIT compilation. While there’s still a cost to calling between the host and WASM, it’s potentially much lower than traditional scripting VMs for complex computations within the mod.\nLanguage Agnostic Modders could potentially use their preferred language, broadening the pool of potential creators.\nChallenges Designing a robust, ergonomic, and performant API bridge between the game engine and WASM modules is non-trivial. Debugging WASM code can be more complex. Tooling and engine integration are still evolving.\nStatus While WASM is used for scripting in some contexts (e.g., some cloud platforms, even experimental game engine plugins), widespread adoption for user game modding is still largely a research/future direction.\nOther sandboxing avenues include improving OS-level containerization for games or exploring new language-level security features in managed runtimes (though progress here seems slow for in-process scenarios).\nSmarter Verification: Static Analysis and Capabilities Beyond runtime sandboxing, we can try to verify mods before they run.\nAdvanced Static Analysis Tools like Unbreakable (for .NET) [12] demonstrate the concept of scanning code for calls to disallowed APIs. Future tools could use more sophisticated techniques (symbolic execution, abstract interpretation) to check for more complex properties, like potential infinite loops, excessive resource usage, or violations of specific game rules, without actually running the code.\nCapability-Based Security Instead of just blacklisting bad things, analyze what capabilities a mod requires (e.g., “needs file access to save settings,” “needs network access to check for updates”). This information could be displayed to the user upon installation (“This mod wants to access your network. Allow?”), similar to mobile app permissions. Mod platforms could enforce policies based on declared capabilities.\nStandardization and Engine-Level Support Could modding become a standard feature provided by major game engines like Unity and Unreal, rather than something each developer has to implement from scratch?\nEngine Modding Middleware Imagine if Unity or Unreal offered a built-in, configurable modding framework – perhaps a secure scripting runtime ( maybe WASM-based?), a standard mod packaging format, and APIs for loading/managing mods. This could drastically lower the barrier for developers to add mod support. Projects like mod.io are trying to provide cross-engine solutions for mod distribution and management [16], but deeper engine integration could go further.\nStandardized APIs? Probably a long shot given the diversity of games, but perhaps standards could emerge for common modding tasks (e.g., asset loading, event handling), making it easier for modders to transfer skills between games using the same engine.\nBetter Mod Development Experiences Making modding easier and more interactive could unlock even more creativity.\nIn-Game Modding Tools Some games are blurring the lines between playing and creating (Roblox, Dreams, Core). Could traditional games offer better in-game tools for modding? Imagine live scripting environments where you can tweak mod code and see the results instantly without restarting the game. Hot-reloading for scripts or even compiled code (which some engines support during development) could be exposed to modders.\nAI-Assisted Modding AI code generation tools (like GitHub Copilot) can already help modders write boilerplate code. Future AI could potentially help with debugging, optimizing mod performance, generating assets, or even suggesting ways to ensure compatibility with other mods.\nTaming Complexity: Modularity and Inter-Mod Communication As mod lists grow, managing interactions becomes key.\nDesigning for Modularity Encourage mods to be small, focused, and expose clear APIs for other mods to use. This requires developers to provide mechanisms for mods to discover and interact with each other safely.\nCross-Mod Event Buses Expand the game’s event system to allow mods to publish and subscribe to custom events, enabling decoupled communication. Mod A could broadcast “NewResourceAdded” and Mod B could listen for it, without either needing direct knowledge of the other.\nConflict Resolution Tools Better tools (perhaps integrated into game launchers or mod managers) to automatically detect potential conflicts (e.g., two mods patching the same method, overriding the same data entry) and suggest solutions or load order adjustments.\nEnhanced Security via Platforms and Process Leveraging the distribution platform for better security.\nCloud-Based Verification Mod platforms (Steam Workshop, Nexus Mods, Paradox Mods) could implement automated cloud-based sandboxing and analysis. Before a mod is publicly listed, it could be run in a secure environment to monitor its behavior (file access, network calls, crashes). This is akin to how mobile app stores vet submissions.\nClearer Labeling Platforms could require mods to declare their capabilities and display clear security warnings (e.g., “This mod uses compiled code and runs with full permissions,” “This mod only uses sandboxed scripts”).\nTiered Modding Support Recognizing that not all mods need the same level of power or risk, developers could offer tiered support:\nTier 1 (Data/Config) Safest level. Mods can only modify data files (XML, JSON) or use a very limited, declarative DSL. Suitable for content additions, balance tweaks. Could potentially be allowed even in multiplayer or on consoles.\nTier 2 (Sandboxed Scripting) Mods use an embedded scripting language (Lua, WASM) running within a strict sandbox, using only approved APIs. Allows more complex logic but contained.\nTier 3 (Compiled Code) Full power, full risk. Mods are compiled DLLs/JARs running unsandboxed. Requires explicit user consent and warnings. Reserved for total conversions and deep system changes where performance is paramount.\nThis allows players and developers to choose the level of risk/reward they are comfortable with.\nThe future of modding tech likely involves combining several of these ideas – perhaps WASM for safe-but-performant code execution, coupled with better platform-level verification and clearer user communication about the risks involved with different types of mods.\nWrapping Up: The Takeaway Whew, that was a deep dive! Supporting user-created mods is clearly far more complex than just throwing a Mods folder into the game directory. It involves fundamental choices about software architecture, language design, execution environments, and security posture.\nWe’ve seen a spectrum of approaches:\nParadox’s controlled, performant, safe DSL-driven world. RimWorld’s open, flexible, slightly chaotic XML + C# + Harmony ecosystem. Bannerlord’s attempt at a structured, official C# module system (still lacking a sandbox). Minecraft’s community-built Java framework rising from a lack of official support. Each approach reflects different priorities and trade-offs between modder flexibility, runtime performance, development ease, and security/stability. There’s no single “right” answer; the best approach depends heavily on the type of game, the engine technology, the performance budget, and the kind of modding community the developers want to foster. Forsslund’s work highlighted the stark performance cost of embedding Lua vs. native parsing in EU3 [8], underscoring why performance-sensitive games might favor DSLs or compiled code, while games prioritizing creativity might accept the overhead of scripts or the risks of DLLs.\nDesigning for moddability means designing a game as a platform. It requires extra effort in architecting for extensibility, maintaining API stability, and providing documentation or tools. But the payoff – immense player engagement, extended game lifespan, unexpected innovation – is often well worth the investment.\nThe biggest unresolved challenge remains security, especially for compiled mods. The current reliance on community trust and platform vetting feels increasingly inadequate in the face of potential threats [21] [11]. Moving towards more technically robust solutions like WASM-based execution, better static analysis, and clearer capability management seems essential for the long-term health and safety of modding ecosystems.\nUltimately, the technologies supporting game mods are constantly evolving. It’s an exciting space where the creativity of players pushes the boundaries, and developers respond with new tools and frameworks. By understanding the technical underpinnings, we can better appreciate the delicate balancing act developers perform and anticipate how modding might become even more powerful, accessible, and secure in the future.\nReferences [1] W. Scacchi, ‘Modding as a basis for developing game systems’, in Proceedings of the 1st International Workshop on Games and Software Engineering, Waikiki, Honolulu HI USA: ACM, May 2011, pp. 5–8. doi: 10.1145/1984674.1984677. [2] ‘A Comprehensive Introduction to Unreal Engine Modding’. Sep. 25, 2024. [Online]. Available: https://buckminsterfullerene02.github.io/dev-guide/ [3] ‘Modding’, CK3 Wiki. [Online]. Available: https://ck3.paradoxwikis.com/Modding [4] ‘Modding Tutorials’, RimWorld Wiki. [Online]. Available: https://rimworldwiki.com/wiki/Modding_Tutorials [5] ‘Bannerlord Documentation’. [Online]. Available: https://docs.bannerlordmodding.com [6] ‘Tutorial:Scripting’, Factorio Wiki. [Online]. Available: https://wiki.factorio.com/Tutorial:Scripting [7] ‘A question about the modding API, the relationship between, C# and Xml thru .dll’, Ludeon Forums. [Online]. Available: https://ludeon.com/forums/index.php?topic=29176.0 [8] O. Forsslund, ‘Evaluating Lua for Usein Computer Game Event Handling’, Master of Science Thesis, KTH Royal Institute of Technology, Stockholm, Sweden, 2013. [Online]. Available: https://www.diva-portal.org/smash/get/diva2:678986/FULLTEXT01.pdf [9] D. Perelman, ‘A newbie’s introduction to Factorio modding’, A Weird Imagination. [Online]. Available: https://aweirdimagination.net/2024/06/23/a-newbies-introduction-to-factorio-modding/ [10] ‘Modding API’, Cities: Skylines Wiki. [Online]. Available: https://skylines.paradoxwikis.com/Modding_API [11] J. Vijayan, ‘Malicious Game Mods Target Dota 2 Game Users’, Dark Reading. [Online]. Available: https://www.darkreading.com/cloud-security/malicious-game-mods-target-dota-2-game-users [12] ‘Running untrusted code (video game modding)’, GitHub dotnet/roslyn Discussion. [Online]. Available: https://github.com/dotnet/roslyn/discussions/48726 [13] ‘Modding’, Europa Universalis 4 Wiki. [Online]. Available: https://eu4.paradoxwikis.com/Modding [14] ‘Stages of Modloading’, Forge Community Wiki. [Online]. Available: https://forge.gemwire.uk/wiki/Stages_of_Modloading [15] ‘Scripting’, Crusader Kings II Wiki. [Online]. Available: https://ck2.paradoxwikis.com/Scripting [16] S. Reismanis, ‘Add mod support to a Unity game in 48 hours with mod.io’, Medium. [Online]. Available: https://blog.mod.io/add-mod-support-to-a-unity-game-in-48-hours-with-mod-io-412a4346731 [17] ‘Sandbox games and mods for security’, Steam Forums. [Online]. Available: https://steamcommunity.com/discussions/forum/10/4625853880055444527/ [18] ‘Additional information regarding malware suspicion on the Mod “Traffic” on Cities: Skylines II.’, Paradox Interactive Forums. [Online]. Available: https://forum.paradoxplaza.com/forum/threads/additional-information-regarding-malware-suspicion-on-the-mod-traffic-on-cities-skylines-ii.1713439/ [19] M. Szabó, ‘How Minecraft and game modding can undermine your security’, ESET Blog. [Online]. Available: https://www.eset.com/blog/consumer/how-minecraft-and-game-modding-can-undermine-your-security/ [20] V. Constantinescu, ‘Minecraft Mods Hit by Massive “BleedingPipe” Vulnerability, Leaving Thousands at Risk’, Bitdefender. [Online]. Available: https://www.bitdefender.com/en-gb/blog/hotforsecurity/minecraft-mods-hit-by-massive-bleedingpipe-vulnerability-leaving-thousands-at-risk [21] ‘Concerning about security vulnerability of bannerlord modding’, TaleWorlds Forums. [Online]. Available: https://forums.taleworlds.com/index.php?threads/concerning-about-security-vulnerability-of-bannerlord-modding.464024/ [22] ‘Modding’, Stellaris Wiki. [Online]. Available: https://stellaris.paradoxwikis.com/Modding [23] ‘Paradox Mods’. [Online]. Available: https://mods.paradoxplaza.com [24] ‘User:Dninemfive’, RimWorld Wiki. [Online]. Available: https://rimworldwiki.com/wiki/User:Dninemfive [25] ‘Taleworlds Documentation’. [Online]. Available: https://moddocs.bannerlord.com/ [26] ‘Official Modding Documentation’, TaleWorlds Forums. [Online]. Available: https://forums.taleworlds.com/index.php?threads/official-modding-documentation.431644/ [27] A. Buckwell, ‘Video Game Modding: What It Is and How to Get Started’, Acer Corner. [Online]. Available: https://blog.acer.com/en/discussion/574/video-game-modding-what-it-is-and-how-to-get-started [28] A. Beskazalioglu, ‘Compiled and Interpreted Programming Languages: Advantages, Disadvantages, and Language Selection Guide for Projects’, Medium. [Online]. Available: https://medium.com/@ahmetbeskazalioglu/compiled-and-interpreted-programming-languages-advantages-disadvantages-and-language-selection-b260ff8d2a50 [29] A. Amador, ‘Gaming Engines: An Undetected Playground for Malware Loaders’, Check Point Research, Nov. 2024. [Online]. Available: https://research.checkpoint.com/2024/gaming-engines-an-undetected-playground-for-malware-loaders/ [30] B. Francis, ‘The Risks of Video Game Mods: An Easy Way for Malware to Spread’, Dynacomp IT Solutions. [Online]. Available: https://www.dynacompusa.com/post/the-risks-of-video-game-mods-an-easy-way-for-malware-to-spread [31] E. Leblond, ‘Godot sandbox \u0026 modding support’, GitHub godotengine/godot Issues. [Online]. Available: https://github.com/godotengine/godot/issues/7753 [32] D. J. Torrey, ‘Building a mod system for a game’, Medium. [Online]. Available: https://medium.com/@davidjamestorreysr/building-a-mod-system-for-a-game-fd566b00759b [33] A. Ivora, ‘Securing the mod system of BeamNG.drive’, Master’s Thesis, Masaryk University, Brno, Czech, 2023. [Online]. Available: https://is.muni.cz/th/x5p5j/?lang=en [34] ‘Is interpreted malware easier to detect than compiled malware?’, Information Security Stack Exchange. [Online]. Available: https://security.stackexchange.com/q/33990 [35] ‘Gaming Mods Security Risks’, Information Security Stack Exchange. [Online]. Available: https://security.stackexchange.com/a/81230 ","wordCount":"11988","inLanguage":"en","datePublished":"2025-03-27T17:33:26+08:00","dateModified":"2025-03-27T17:33:26+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/under-the-hood-the-technologies-powering-your-favorite-game-mods/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Under the Hood: The Technologies Powering Your Favorite Game Mods</h1><div class=post-meta><span title='2025-03-27 17:33:26 +0800 +0800'>March 27, 2025</span>&nbsp;·&nbsp;57 min&nbsp;·&nbsp;11988 words&nbsp;·&nbsp;Tategoto Azarasi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#the-foundations-what-makes-a-game-moddable>The Foundations: What Makes a Game Moddable?</a><ol><li><a href=#designing-for-extensibility>Designing for Extensibility</a><ol><li><a href=#modular-design>Modular Design</a></li><li><a href=#data-driven-architecture>Data-Driven Architecture</a></li><li><a href=#software-product-lines>Software Product Lines</a></li></ol></li><li><a href=#data-driven-vs-code-driven-modding>Data-Driven vs. Code-Driven Modding</a><ol><li><a href=#data-driven-modding>Data-Driven Modding</a></li><li><a href=#code-driven-modding>Code-Driven Modding</a></li></ol></li><li><a href=#the-modding-api-the-gateway>The Modding API: The Gateway</a><ol><li><a href=#file-formats-and-loaders>File Formats and Loaders</a></li><li><a href=#scripting-hooks-and-bindings>Scripting Hooks and Bindings</a></li><li><a href=#code-libraries-and-interfaces>Code Libraries and Interfaces</a></li><li><a href=#powerful-enough>Powerful enough</a></li><li><a href=#stable-enough>Stable enough</a></li><li><a href=#safe-enough>Safe enough</a></li><li><a href=#documented-enough>Documented enough</a></li></ol></li></ol></li><li><a href=#choosing-the-right-tools-languages-for-modders>Choosing the Right Tools: Languages for Modders</a><ol><li><a href=#the-big-question-general-purpose-language-vs-domain-specific-language-dsl>The Big Question: General-Purpose Language vs. Domain-Specific Language (DSL)?</a><ol><li><a href=#option-1-embed-a-general-purpose-language>Option 1: Embed a General-Purpose Language</a><ol><li><a href=#lua>Lua</a></li><li><a href=#python>Python</a></li><li><a href=#c>C#</a></li><li><a href=#javascript>JavaScript</a></li><li><a href=#pros-of-general-purpose-languages>Pros of General-Purpose Languages</a><ol><li><a href=#familiarity>Familiarity</a></li><li><a href=#power--expressiveness>Power & Expressiveness</a></li><li><a href=#ecosystem>Ecosystem</a></li></ol></li><li><a href=#cons-of-general-purpose-languages>Cons of General-Purpose Languages</a><ol><li><a href=#integration-complexity>Integration Complexity</a></li><li><a href=#performance-overhead>Performance Overhead</a></li><li><a href=#security-risks>Security Risks</a></li><li><a href=#api-surface>API Surface</a></li></ol></li><li><a href=#mitigating-performance>Mitigating Performance:</a></li></ol></li><li><a href=#option-2-create-a-domain-specific-language-dsl>Option 2: Create a Domain-Specific Language (DSL)</a><ol><li><a href=#paradox-interactives-clausewitz-scripting>Paradox Interactive&rsquo;s Clausewitz Scripting</a></li><li><a href=#bethesdas-papyrus>Bethesda&rsquo;s Papyrus</a></li><li><a href=#pros-of-dsls>Pros of DSLs</a><ol><li><a href=#performance>Performance</a></li><li><a href=#safety-by-design>Safety by Design</a></li><li><a href=#ease-of-use-potentially>Ease of Use (Potentially)</a></li><li><a href=#enforces-game-structure>Enforces Game Structure</a></li></ol></li><li><a href=#cons-of-dsls>Cons of DSLs</a><ol><li><a href=#learning-curve>Learning Curve</a></li><li><a href=#limited-power>Limited Power</a></li><li><a href=#developer-burden>Developer Burden</a></li></ol></li></ol></li><li><a href=#hybrid-approaches>Hybrid Approaches</a></li><li><a href=#so-which-to-choose>So, Which to Choose?</a></li></ol></li></ol></li><li><a href=#how-mods-run-interpreted-vs-compiled-execution>How Mods Run: Interpreted vs. Compiled Execution</a><ol><li><a href=#scenario-a-interpreted-mod>Scenario A: Interpreted Mod</a></li><li><a href=#scenario-b-compiled-mod>Scenario B: Compiled Mod</a></li><li><a href=#interpreted-mods-runtime-scripting>Interpreted Mods (Runtime Scripting)</a><ol><li><a href=#how-it-works>How it Works</a></li><li><a href=#examples>Examples</a></li><li><a href=#pros-of-interpreted-mods>Pros of Interpreted Mods</a><ol><li><a href=#easier-development>Easier Development</a></li><li><a href=#cross-platform-compatibility>Cross-Platform Compatibility</a></li><li><a href=#easier-sandboxing>Easier Sandboxing</a></li></ol></li><li><a href=#cons-of-interpreted-mods>Cons of Interpreted Mods</a><ol><li><a href=#performance-1>Performance</a></li><li><a href=#requires-embedding-runtime>Requires Embedding Runtime</a></li></ol></li></ol></li><li><a href=#compiled-mods-native-or-bytecode-plugins>Compiled Mods (Native or Bytecode Plugins)</a><ol><li><a href=#how-it-works-1>How it Works</a></li><li><a href=#examples-1>Examples</a></li><li><a href=#pros-of-compiled-mods>Pros of Compiled Mods</a><ol><li><a href=#performance-2>Performance</a></li><li><a href=#power--flexibility>Power & Flexibility</a></li></ol></li><li><a href=#cons-of-compiled-mods>Cons of Compiled Mods</a><ol><li><a href=#development-complexity>Development Complexity</a></li><li><a href=#compatibility-issues>Compatibility Issues</a></li><li><a href=#platform-dependence>Platform Dependence</a></li><li><a href=#security-nightmare>Security Nightmare</a></li><li><a href=#stability-risks>Stability Risks</a></li></ol></li></ol></li><li><a href=#a-potential-middle-ground-managed-runtimes-and-future-tech>A Potential Middle Ground: Managed Runtimes and Future Tech</a></li><li><a href=#summary-table-interpreted-vs-compiled>Summary Table: Interpreted vs. Compiled</a></li></ol></li><li><a href=#bringing-mods-to-life-loading-and-lifecycle-integration>Bringing Mods to Life: Loading and Lifecycle Integration</a><ol><li><a href=#finding-and-identifying-mods>Finding and Identifying Mods</a><ol><li><a href=#dedicated-mods-folder>Dedicated <code>Mods</code> Folder</a></li><li><a href=#launcher-manifests>Launcher Manifests</a></li><li><a href=#platform-integration>Platform Integration</a></li></ol></li><li><a href=#loading-mods-order-matters>Loading Mods: Order Matters!</a></li><li><a href=#the-mod-lifecycle-initialization-and-execution-hooks>The Mod Lifecycle: Initialization and Execution Hooks</a><ol><li><a href=#load>Load</a></li><li><a href=#initialize>Initialize</a></li><li><a href=#runtime-hooks>Runtime Hooks</a></li><li><a href=#initialization>Initialization:</a><ol><li><a href=#script-mods>Script Mods</a></li><li><a href=#compiled-mods>Compiled Mods</a></li></ol></li><li><a href=#runtime-execution-hooks>Runtime Execution Hooks</a><ol><li><a href=#event-callbacks--subscriptions>Event Callbacks / Subscriptions</a></li><li><a href=#method-overrides--subclassing>Method Overrides / Subclassing</a></li><li><a href=#direct-patching-eg-harmony>Direct Patching (e.g., Harmony)</a><ol><li><a href=#prefix>Prefix</a></li><li><a href=#postfix>Postfix</a></li><li><a href=#transpiler>Transpiler</a></li></ol></li><li><a href=#tickupdate-hooks>Tick/Update Hooks</a></li></ol></li><li><a href=#handling-mod-errors>Handling Mod Errors:</a></li></ol></li><li><a href=#dynamic-loading-hot-swapping>Dynamic Loading (Hot Swapping)?</a></li><li><a href=#resource-loading>Resource Loading</a><ol><li><a href=#file-overrides>File Overrides</a></li><li><a href=#virtual-file-systems--archives>Virtual File Systems / Archives</a></li><li><a href=#data-merging>Data Merging</a></li><li><a href=#api-driven-loading>API-Driven Loading</a></li></ol></li></ol></li><li><a href=#the-elephant-in-the-room-security-and-sandboxing>The Elephant in the Room: Security and Sandboxing</a><ol><li><a href=#the-current-reality-trust-community-and-hope>The Current Reality: Trust, Community, and Hope</a><ol><li><a href=#reputable-sources>Reputable Sources</a></li><li><a href=#community-vetting>Community Vetting</a></li><li><a href=#antivirus-software>Antivirus Software</a></li><li><a href=#developer-warnings>Developer Warnings</a></li><li><a href=#dota-2-mods-2023>Dota 2 Mods (2023)</a></li><li><a href=#minecraft-mods-various>Minecraft Mods (Various)</a></li><li><a href=#cities-skylines-malware-2022>Cities: Skylines Malware (2022)</a></li><li><a href=#bannerlord-concerns>Bannerlord Concerns</a></li></ol></li><li><a href=#sandboxing-script-mods-the-easier-path>Sandboxing Script Mods: The Easier Path</a><ol><li><a href=#how-it-works-2>How it Works</a></li><li><a href=#effectiveness>Effectiveness</a></li></ol></li><li><a href=#sandboxing-compiled-mods-the-herculean-task>Sandboxing Compiled Mods: The Herculean Task</a><ol><li><a href=#why-its-hard>Why it&rsquo;s Hard:</a></li><li><a href=#approaches-mostly-theoretical-or-limited>Approaches (Mostly Theoretical or Limited)</a><ol><li><a href=#os-level-sandboxing>OS-Level Sandboxing</a></li><li><a href=#process-isolation>Process Isolation:</a><ol><li><a href=#pros>Pros</a></li><li><a href=#cons>Cons</a></li></ol></li><li><a href=#managed-runtime-security-deprecatedineffective>Managed Runtime Security (Deprecated/Ineffective)</a></li><li><a href=#static-analysis--api-whitelisting>Static Analysis / API Whitelisting</a><ol><li><a href=#pros-1>Pros</a></li><li><a href=#cons-1>Cons</a></li><li><a href=#practical-use>Practical Use</a></li></ol></li><li><a href=#system-call-interception--runtime-monitoring>System Call Interception / Runtime Monitoring</a></li></ol></li><li><a href=#the-takeaway>The Takeaway</a></li></ol></li><li><a href=#minecraft-a-tale-of-two-editions>Minecraft: A Tale of Two Editions</a></li><li><a href=#where-does-this-leave-us>Where Does This Leave Us?</a></li></ol></li><li><a href=#real-world-examples-case-studies-in-modding-tech>Real-World Examples: Case Studies in Modding Tech</a><ol><li><a href=#case-study-1-paradox-grand-strategy-games-clausewitzjomini-engine---the-dsl-kings>Case Study 1: Paradox Grand Strategy Games (Clausewitz/Jomini Engine) - The DSL Kings</a><ol><li><a href=#engine--language>Engine & Language</a></li><li><a href=#execution>Execution</a></li><li><a href=#no-arbitrary-code>No Arbitrary Code</a></li><li><a href=#loading--lifecycle>Loading & Lifecycle</a></li><li><a href=#security>Security</a></li><li><a href=#community--tools>Community & Tools</a></li><li><a href=#why-this-approach>Why this approach?</a></li></ol></li><li><a href=#case-study-2-rimworld---xml-c-and-harmony-mayhem>Case Study 2: <em>RimWorld</em> - XML, C#, and Harmony Mayhem</a><ol><li><a href=#engine--language-1>Engine & Language</a><ol><li><a href=#xml-definitions>XML Definitions</a></li><li><a href=#c-assemblies>C# Assemblies</a></li></ol></li><li><a href=#the-api-and-lack-thereof>The &ldquo;API&rdquo; (and lack thereof)</a></li><li><a href=#harmony-patching>Harmony Patching</a></li><li><a href=#execution--performance>Execution & Performance</a></li><li><a href=#loading--lifecycle-1>Loading & Lifecycle</a></li><li><a href=#security-1>Security</a></li><li><a href=#community--tools-1>Community & Tools</a></li><li><a href=#why-this-approach-1>Why this approach?</a></li></ol></li><li><a href=#case-study-3-mount--blade-ii-bannerlord---official-modules-unofficial-risks>Case Study 3: <em>Mount & Blade II: Bannerlord</em> - Official Modules, Unofficial Risks</a><ol><li><a href=#engine--language-2>Engine & Language</a></li><li><a href=#module-system>Module System</a></li><li><a href=#official-api--tools>Official API & Tools</a></li><li><a href=#execution--performance-1>Execution & Performance</a></li><li><a href=#loading--lifecycle-2>Loading & Lifecycle</a></li><li><a href=#security-2>Security</a></li><li><a href=#stability>Stability</a></li><li><a href=#why-this-approach-2>Why this approach?</a></li></ol></li><li><a href=#case-study-4-minecraft-java-edition---community-forged-power>Case Study 4: <em>Minecraft</em> (Java Edition) - Community Forged Power</a><ol><li><a href=#engine--language-3>Engine & Language</a></li><li><a href=#community-loaders-forge--fabric>Community Loaders (Forge & Fabric)</a></li><li><a href=#the-api>The &ldquo;API&rdquo;</a></li><li><a href=#execution--performance-2>Execution & Performance</a></li><li><a href=#loading--lifecycle-3>Loading & Lifecycle</a></li><li><a href=#security-3>Security</a></li><li><a href=#stability--compatibility>Stability & Compatibility</a></li><li><a href=#why-this-approach-3>Why this approach?</a></li></ol></li></ol></li><li><a href=#looking-ahead-the-future-of-modding-tech>Looking Ahead: The Future of Modding Tech</a><ol><li><a href=#safer-performant-sandboxing-the-wasm-hope-and-others>Safer, Performant Sandboxing: The WASM Hope (and others)</a><ol><li><a href=#the-idea>The Idea</a></li><li><a href=#why-its-promising>Why it&rsquo;s Promising</a><ol><li><a href=#security-4>Security</a></li><li><a href=#performance-3>Performance</a></li><li><a href=#language-agnostic>Language Agnostic</a></li></ol></li><li><a href=#challenges>Challenges</a></li><li><a href=#status>Status</a></li></ol></li><li><a href=#smarter-verification-static-analysis-and-capabilities>Smarter Verification: Static Analysis and Capabilities</a><ol><li><a href=#advanced-static-analysis>Advanced Static Analysis</a></li><li><a href=#capability-based-security>Capability-Based Security</a></li></ol></li><li><a href=#standardization-and-engine-level-support>Standardization and Engine-Level Support</a><ol><li><a href=#engine-modding-middleware>Engine Modding Middleware</a></li><li><a href=#standardized-apis>Standardized APIs?</a></li></ol></li><li><a href=#better-mod-development-experiences>Better Mod Development Experiences</a><ol><li><a href=#in-game-modding-tools>In-Game Modding Tools</a></li><li><a href=#ai-assisted-modding>AI-Assisted Modding</a></li></ol></li><li><a href=#taming-complexity-modularity-and-inter-mod-communication>Taming Complexity: Modularity and Inter-Mod Communication</a><ol><li><a href=#designing-for-modularity>Designing for Modularity</a></li><li><a href=#cross-mod-event-buses>Cross-Mod Event Buses</a></li><li><a href=#conflict-resolution-tools>Conflict Resolution Tools</a></li></ol></li><li><a href=#enhanced-security-via-platforms-and-process>Enhanced Security via Platforms and Process</a><ol><li><a href=#cloud-based-verification>Cloud-Based Verification</a></li><li><a href=#clearer-labeling>Clearer Labeling</a></li></ol></li><li><a href=#tiered-modding-support>Tiered Modding Support</a><ol><li><a href=#tier-1-dataconfig>Tier 1 (Data/Config)</a></li><li><a href=#tier-2-sandboxed-scripting>Tier 2 (Sandboxed Scripting)</a></li><li><a href=#tier-3-compiled-code>Tier 3 (Compiled Code)</a></li></ol></li></ol></li><li><a href=#wrapping-up-the-takeaway>Wrapping Up: The Takeaway</a></li><li><a href=#references>References</a></li></ol></nav></div></details></div><div class=post-content><p>If you&rsquo;ve spent any time in the PC gaming world, you know mods. They&rsquo;re the lifeblood that keeps games fresh years after
release, the sparks of creativity that turn a fun experience into a personalized obsession, and sometimes, the
foundation for entirely new genres. Think about it: <em>Counter-Strike</em> started as a <em>Half-Life</em> mod, <em>Dota</em> emerged from
<em>Warcraft III</em>, and countless other innovations bubbled up from player communities tinkering with the games they
loved [1]. Modding isn&rsquo;t just about adding silly hats (though that&rsquo;s important too!); it&rsquo;s a powerful form of user
engagement, creativity, and even end-user software engineering [1].</p><p>But here&rsquo;s the thing: enabling this creative chaos isn&rsquo;t magic. It requires deliberate, often complex, technical
decisions from the game developers themselves. While some hardcore modders might reverse-engineer games without official
help, the most vibrant modding scenes often flourish where developers have intentionally built <em>support</em> for mods right
into the game&rsquo;s architecture.</p><p>Supporting mods properly is <em>hard</em>. Developers have to grapple with fundamental questions:</p><ul><li>What kind of tools or languages should modders use? Should it be something familiar like Python or Lua, or a custom
language built just for the game?</li><li>How will the mod code actually <em>run</em>? Will it be interpreted on the fly, or compiled into faster (but potentially
riskier) binary code?</li><li>How do we let mods interact with the game without crashing everything or, worse, opening up security holes?</li><li>How do we balance giving modders enough power to be creative against maintaining game stability and performance?</li></ul><p>This isn&rsquo;t just a technical puzzle; it&rsquo;s a strategic one that shapes the entire modding community around a game. Get it
right, and you foster decades of player loyalty and innovation (think <em>Skyrim</em> or <em>Minecraft</em>). Get it wrong, and you
might stifle creativity or end up with a buggy, insecure mess.</p><p>In this (rather extensive) post, we&rsquo;re going to unpack the technologies developers use on <em>their</em> side to make modding
possible for single-player PC games.</p><p>Our focus here is strictly on the <em>developer-side</em> technology for <em>single-player PC games</em>. Multiplayer introduces a
whole other layer of complexity (anti-cheat, synchronization, server hosting) that&rsquo;s beyond our scope today. Console
modding is also a different beast due to platform restrictions and certification processes.</p><p>So, let&rsquo;s pop the hood and see what makes modding tick.</p><h2 id=the-foundations-what-makes-a-game-moddable>The Foundations: What Makes a Game Moddable?<a hidden class=anchor aria-hidden=true href=#the-foundations-what-makes-a-game-moddable>#</a></h2><p>Before we even talk about specific languages or execution methods, we need to understand that supporting mods isn&rsquo;t
usually an afterthought bolted onto a finished game. Truly moddable games are often designed with <em>extensibility</em> in
mind from the ground up.</p><h3 id=designing-for-extensibility>Designing for Extensibility<a hidden class=anchor aria-hidden=true href=#designing-for-extensibility>#</a></h3><p>This idea isn&rsquo;t unique to games. Back in the day, software engineering pioneers like David Parnas talked about designing
software for change and extension [1]. The core principle is building systems in a modular way, with well-defined
interfaces between components, so that you can swap parts out or add new ones without breaking the whole thing.</p><p>Walt Scacchi, who has written extensively on game modding, framed it as a form of &ldquo;open software extension&rdquo; [1]. Games
that do this well often employ architectural patterns like:</p><h4 id=modular-design>Modular Design<a hidden class=anchor aria-hidden=true href=#modular-design>#</a></h4><p>Breaking the game down into distinct systems (AI, physics, UI, gameplay logic) that communicate through clear
interfaces. This makes it easier to expose specific parts to modders without revealing the entire messy internals. Think
of how Unreal Engine uses modules, which can facilitate plugin-based modding [2].</p><h4 id=data-driven-architecture>Data-Driven Architecture<a hidden class=anchor aria-hidden=true href=#data-driven-architecture>#</a></h4><p>Instead of hardcoding game rules, content, or parameters directly into the compiled code, developers store this
information in external files (like XML, JSON, YAML, or custom formats). The game engine reads these files at runtime to
configure itself. This is <em>huge</em> for modding because it means players can change significant aspects of the game simply
by editing or adding these data files, without needing to write any code. We&rsquo;ll see a great example of this with
<em>RimWorld</em>.</p><h4 id=software-product-lines>Software Product Lines<a hidden class=anchor aria-hidden=true href=#software-product-lines>#</a></h4><p>Some researchers view moddable games as instances of software product lines, where the base game is the core platform
and mods represent variations or features added to that platform [1]. Designing with this mindset encourages developers
to think about commonality and variability, isolating the core engine from the customizable game content.</p><h3 id=data-driven-vs-code-driven-modding>Data-Driven vs. Code-Driven Modding<a hidden class=anchor aria-hidden=true href=#data-driven-vs-code-driven-modding>#</a></h3><p>This leads to a fundamental distinction in <em>how</em> mods interact with the game:</p><h4 id=data-driven-modding>Data-Driven Modding<a hidden class=anchor aria-hidden=true href=#data-driven-modding>#</a></h4><p>Mods primarily consist of data files that the game engine reads and interprets. This could be adding new items by
defining them in an XML file, creating new quests via configuration files, or adjusting weapon stats in a
spreadsheet-like format. The power here comes from the engine being designed to <em>read</em> this external data. Paradox games
are masters of this, allowing huge swathes of game logic and content to be defined in text files [3].</p><h4 id=code-driven-modding>Code-Driven Modding<a hidden class=anchor aria-hidden=true href=#code-driven-modding>#</a></h4><p>Mods include actual executable code (scripts or compiled binaries) that runs alongside the game&rsquo;s own code. This code
typically uses an Application Programming Interface (API) exposed by the game engine to query game state, react to
events, or modify game behavior. This allows for much deeper, more complex changes, like implementing entirely new
gameplay systems or altering core AI. Games like <em>RimWorld</em> (C# mods) [4] or <em>Mount & Blade II: Bannerlord</em> (C#
mods) [5] heavily rely on this.</p><p>Many games actually use a <em>hybrid</em> approach. They might allow simple content additions via data files (easy entry point
for beginners) and provide a scripting or code API for more advanced modders. <em>RimWorld</em> is a perfect example: add new
guns via XML, write complex AI behaviors in C# [4].</p><h3 id=the-modding-api-the-gateway>The Modding API: The Gateway<a hidden class=anchor aria-hidden=true href=#the-modding-api-the-gateway>#</a></h3><p>Whether data-driven or code-driven, the core mechanism enabling mods is some form of interface provided by the
developers. This could be:</p><h4 id=file-formats-and-loaders>File Formats and Loaders<a hidden class=anchor aria-hidden=true href=#file-formats-and-loaders>#</a></h4><p>For data mods, the &ldquo;API&rdquo; is the specification of the data file formats (e.g., the structure of the XML definitions in
<em>RimWorld</em>) and the engine&rsquo;s ability to find and load these files from mod directories.</p><h4 id=scripting-hooks-and-bindings>Scripting Hooks and Bindings<a hidden class=anchor aria-hidden=true href=#scripting-hooks-and-bindings>#</a></h4><p>For script mods, the API consists of the functions and objects the scripting language can access to interact with the
game world (e.g., the Lua functions exposed by <em>Factorio</em> to let mods react to events like <code>on_player_crafted_item</code> [6].</p><h4 id=code-libraries-and-interfaces>Code Libraries and Interfaces<a hidden class=anchor aria-hidden=true href=#code-libraries-and-interfaces>#</a></h4><p>For compiled mods, the API is often a set of libraries (like DLLs or JARs) that mods link against, providing classes and
methods to interact with the engine (e.g., the <code>TaleWorlds.*.dll</code> assemblies that <em>Bannerlord</em> modders reference [5].</p><p>Designing a good modding API is an art. It needs to be:</p><h4 id=powerful-enough>Powerful enough<a hidden class=anchor aria-hidden=true href=#powerful-enough>#</a></h4><p>Expose enough functionality to allow meaningful mods.</p><h4 id=stable-enough>Stable enough<a hidden class=anchor aria-hidden=true href=#stable-enough>#</a></h4><p>Avoid changing constantly, which breaks existing mods with every game update.</p><h4 id=safe-enough>Safe enough<a hidden class=anchor aria-hidden=true href=#safe-enough>#</a></h4><p>Not expose functions that could easily crash the game or compromise security.</p><h4 id=documented-enough>Documented enough<a hidden class=anchor aria-hidden=true href=#documented-enough>#</a></h4><p>Modders need to know what&rsquo;s available and how to use it! (Though community reverse-engineering often fills gaps, as seen
in <em>RimWorld</em> [7].</p><p>With these foundational concepts in mind, let&rsquo;s dive into one of the biggest decisions developers face: what language
should mods be written in?</p><h2 id=choosing-the-right-tools-languages-for-modders>Choosing the Right Tools: Languages for Modders<a hidden class=anchor aria-hidden=true href=#choosing-the-right-tools-languages-for-modders>#</a></h2><p>Okay, so you&rsquo;ve decided to let players mod your game with code or scripts. Now what? Do you embed a popular language
like Lua or Python? Or do you invent your own special language just for your game? This choice has massive ripple
effects on performance, flexibility, security, and the kind of modding community that grows around your game.</p><h3 id=the-big-question-general-purpose-language-vs-domain-specific-language-dsl>The Big Question: General-Purpose Language vs. Domain-Specific Language (DSL)?<a hidden class=anchor aria-hidden=true href=#the-big-question-general-purpose-language-vs-domain-specific-language-dsl>#</a></h3><p>This is the core dilemma. Let&rsquo;s break down the options.</p><h4 id=option-1-embed-a-general-purpose-language>Option 1: Embed a General-Purpose Language<a hidden class=anchor aria-hidden=true href=#option-1-embed-a-general-purpose-language>#</a></h4><p>This involves integrating an existing, off-the-shelf programming language interpreter or runtime into your game engine.
Modders then write their logic in that language.</p><h5 id=lua>Lua<a hidden class=anchor aria-hidden=true href=#lua>#</a></h5><p>The reigning champion of embedded game scripting. Why? It&rsquo;s small, fast (for a script), designed explicitly for
embedding in C/C++ applications, and relatively easy to learn [8]. Countless games use it, from <em>World of Warcraft</em>&rsquo;s UI
mods to <em>Factorio</em>&rsquo;s extensive modding system [9] to experiments in Paradox games [8]. Its C API makes it
straightforward (relatively speaking) to bridge the gap between the game&rsquo;s native code and the Lua scripts.</p><h5 id=python>Python<a hidden class=anchor aria-hidden=true href=#python>#</a></h5><p>Another popular choice, known for its readability and vast libraries. <em>Civilization IV</em> famously used Python for a lot
of its game logic scripting, allowing extensive modding. The downside? Python interpreters are generally heavier than
Lua&rsquo;s, and performance can be a concern for high-frequency tasks in games. Integration also requires careful handling of
the Global Interpreter Lock (GIL) if multithreading is involved.</p><h5 id=c>C#<a hidden class=anchor aria-hidden=true href=#c>#</a></h5><p>Particularly relevant for games built with the Unity engine. Since Unity itself uses C# for scripting, it&rsquo;s natural for
developers to expose parts of their C# codebase for modding. <em>RimWorld</em> [4], <em>Cities: Skylines</em> [10], and <em>Mount & Blade
II: Bannerlord</em> [5] all allow mods written as compiled C# assemblies (.DLLs). This provides immense power and
performance (thanks to the .NET JIT compiler) but comes with compilation hurdles and security headaches (more on that
later).</p><h5 id=javascript>JavaScript<a hidden class=anchor aria-hidden=true href=#javascript>#</a></h5><p>While primarily a web language, its ubiquity and mature engines (like V8) have led to its use in some game contexts,
especially for UI scripting. Valve&rsquo;s Source 2 engine, for example, uses JavaScript (specifically Panorama UI) for UI
elements in games like <em>Dota 2</em> [11]. Security is a major consideration here, as browser engines have incredibly
sophisticated sandboxes built over decades – something game engines usually lack.</p><h5 id=pros-of-general-purpose-languages>Pros of General-Purpose Languages<a hidden class=anchor aria-hidden=true href=#pros-of-general-purpose-languages>#</a></h5><h6 id=familiarity>Familiarity<a hidden class=anchor aria-hidden=true href=#familiarity>#</a></h6><p>Modders can leverage existing programming skills. The learning curve is lower if they already know Lua, Python, or C#.</p><h6 id=power--expressiveness>Power & Expressiveness<a hidden class=anchor aria-hidden=true href=#power--expressiveness>#</a></h6><p>These are real programming languages! Modders can implement complex algorithms, data structures, and logic that might be
impossible in a more limited system.</p><h6 id=ecosystem>Ecosystem<a hidden class=anchor aria-hidden=true href=#ecosystem>#</a></h6><p>Access to existing libraries (though often restricted for security), documentation, and development tools (debuggers,
IDEs).</p><h5 id=cons-of-general-purpose-languages>Cons of General-Purpose Languages<a hidden class=anchor aria-hidden=true href=#cons-of-general-purpose-languages>#</a></h5><h6 id=integration-complexity>Integration Complexity<a hidden class=anchor aria-hidden=true href=#integration-complexity>#</a></h6><p>Developers need to embed the interpreter/runtime, create bindings (the C/C++ API bridge), and carefully manage data
transfer between the game and the script environment. This binding layer can be tricky to get right and maintain.</p><h6 id=performance-overhead>Performance Overhead<a hidden class=anchor aria-hidden=true href=#performance-overhead>#</a></h6><p>Scripting is almost always slower than native compiled code. Oskar Forsslund&rsquo;s Master&rsquo;s thesis provides a stark example:
evaluating <em>Europa Universalis III</em>&rsquo;s event triggers in Lua was roughly <strong>six times slower</strong> than the original C++
implementation that parsed custom script files [8] [8]. The overhead comes from interpretation/JIT compilation itself,
but also significantly from the &ldquo;context switching&rdquo; and data marshaling required to call script functions from C++ and
vice-versa [8].</p><h6 id=security-risks>Security Risks<a hidden class=anchor aria-hidden=true href=#security-risks>#</a></h6><p>These languages are powerful. Unless carefully sandboxed, a mod script could potentially access the file system (
<code>io.open</code> in Lua), make network connections, or execute arbitrary OS commands (<code>os.execute</code> in Lua). Sandboxing requires
deliberately restricting the available functions and libraries, which takes effort.</p><h6 id=api-surface>API Surface<a hidden class=anchor aria-hidden=true href=#api-surface>#</a></h6><p>Developers need to decide <em>what</em> parts of the game to expose to the scripting language. They are constantly balancing
giving modders enough power versus overwhelming them or exposing internals that shouldn&rsquo;t be touched. As one developer
noted in a discussion, you&rsquo;re &ldquo;on the hook for anticipating their needs&rdquo; [12].</p><h5 id=mitigating-performance>Mitigating Performance:<a hidden class=anchor aria-hidden=true href=#mitigating-performance>#</a></h5><p>Just-In-Time (JIT) compilers can help bridge the performance gap. Forsslund found that using LuaJIT significantly sped
up the Lua event handling in his EU3 tests, getting closer to the performance target Paradox had set (though still
slower than native C++) [8]. However, even with a JIT, frequent calls across the native/script boundary can remain
costly. Developers often design around this by triggering scripts only for higher-level events rather than inside tight
loops that run every frame.</p><h4 id=option-2-create-a-domain-specific-language-dsl>Option 2: Create a Domain-Specific Language (DSL)<a hidden class=anchor aria-hidden=true href=#option-2-create-a-domain-specific-language-dsl>#</a></h4><p>Instead of embedding an existing language, some developers create their <em>own</em> custom language tailored specifically for
modding their game. These DSLs are often not full-fledged programming languages but rather specialized formats for
configuring game behavior or defining content.</p><h5 id=paradox-interactives-clausewitz-scripting>Paradox Interactive&rsquo;s Clausewitz Scripting<a hidden class=anchor aria-hidden=true href=#paradox-interactives-clausewitz-scripting>#</a></h5><p>This is the quintessential example. Games like <em>Europa Universalis IV</em>, <em>Crusader Kings III</em>, <em>Hearts of Iron IV</em>,
<em>Stellaris</em>, etc., use a proprietary scripting syntax (often in <code>.txt</code> files, despite sometimes involving Lua for
specific functions internally) to define almost everything: events, decisions, national focuses, technologies, AI
behavior, map data, etc. [3] [13]. It uses a nested key-value structure with braces, looking somewhat declarative.</p><p>Here&rsquo;s a <em>hypothetical</em> snippet resembling a Paradox event script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span># Example Event Definition in a Paradox-style DSL
</span></span><span style=display:flex><span>country_event = {
</span></span><span style=display:flex><span>    id = my_awesome_mod.101
</span></span><span style=display:flex><span>    title = &#34;MY_MOD_EVENT_101_TITLE&#34; # Loc key
</span></span><span style=display:flex><span>    desc = &#34;MY_MOD_EVENT_101_DESC&#34;  # Loc key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    picture = GFX_event_mymod_picture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    is_triggered_only = yes # Means it won&#39;t fire randomly
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    trigger = {
</span></span><span style=display:flex><span>        # Conditions for the event to be possible
</span></span><span style=display:flex><span>        has_dlc = &#34;My Awesome DLC&#34; # Example check
</span></span><span style=display:flex><span>        government = democracy
</span></span><span style=display:flex><span>        NOT = { has_country_modifier = recently_had_event_101 }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mean_time_to_happen = {
</span></span><span style=display:flex><span>        months = 120 # Average time for it to fire if conditions met
</span></span><span style=display:flex><span>        modifier = {
</span></span><span style=display:flex><span>            factor = 0.8 # Faster if...
</span></span><span style=display:flex><span>            has_idea_group = economic_ideas
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    immediate = {
</span></span><span style=display:flex><span>        # Effects that happen instantly when the event fires
</span></span><span style=display:flex><span>        add_stability = -1
</span></span><span style=display:flex><span>        add_country_modifier = {
</span></span><span style=display:flex><span>            name = &#34;recently_had_event_101&#34;
</span></span><span style=display:flex><span>            duration = 3650 # 10 years
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    option = {
</span></span><span style=display:flex><span>        # First choice for the player
</span></span><span style=display:flex><span>        name = &#34;MY_MOD_EVENT_101_OPT_A&#34; # Loc key
</span></span><span style=display:flex><span>        ai_chance = { factor = 70 }
</span></span><span style=display:flex><span>        add_treasury = 100
</span></span><span style=display:flex><span>        add_prestige = 5
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    option = {
</span></span><span style=display:flex><span>        # Second choice
</span></span><span style=display:flex><span>        name = &#34;MY_MOD_EVENT_101_OPT_B&#34; # Loc key
</span></span><span style=display:flex><span>        ai_chance = { factor = 30 }
</span></span><span style=display:flex><span>        add_inflation = 2.0
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice how it&rsquo;s structured around game concepts (<code>trigger</code>, <code>mean_time_to_happen</code>, <code>option</code>, <code>effect</code> like
<code>add_stability</code>) rather than generic programming constructs like <code>if/else</code> or <code>for</code> loops (though the engine evaluates
these triggers logically).</p><h5 id=bethesdas-papyrus>Bethesda&rsquo;s Papyrus<a hidden class=anchor aria-hidden=true href=#bethesdas-papyrus>#</a></h5><p>Used in games like <em>Skyrim</em> and <em>Fallout 4</em>, Papyrus <em>looks</em> more like a traditional scripting language but is still a
DSL created specifically for Bethesda&rsquo;s Creation Engine. It&rsquo;s event-driven and designed for attaching scripts to objects
in the game world. While more powerful than Paradox&rsquo;s declarative style, it&rsquo;s still limited compared to a
general-purpose language (e.g., no direct file I/O for mods).</p><h5 id=pros-of-dsls>Pros of DSLs<a hidden class=anchor aria-hidden=true href=#pros-of-dsls>#</a></h5><h6 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h6><p>DSLs can be heavily optimized. The game engine parses the DSL script (often at load time) and converts it into an
internal representation that can be executed very efficiently in native code (like C++). Forsslund&rsquo;s study confirmed
this: the original EU3 event system using parsed DSL scripts was <em>significantly faster</em> than his Lua prototype [8].
Paradox likely stuck with their DSL approach precisely because performance is critical in their complex simulations.</p><h6 id=safety-by-design>Safety by Design<a hidden class=anchor aria-hidden=true href=#safety-by-design>#</a></h6><p>Because the DSL only includes commands relevant to the game, it&rsquo;s inherently sandboxed. There&rsquo;s simply no syntax in
Paradox script for &ldquo;delete file&rdquo; or &ldquo;connect to internet.&rdquo; The language itself restricts mods to interacting with the
game through predefined, controlled mechanisms (like specific triggers and effects). Security comes from <em>limited
expressiveness</em>.</p><h6 id=ease-of-use-potentially>Ease of Use (Potentially)<a hidden class=anchor aria-hidden=true href=#ease-of-use-potentially>#</a></h6><p>For non-programmers, a well-designed DSL that uses game-specific terminology might be easier to grasp than learning a
full programming language. Adding a new country event in Paradox script might feel more intuitive than writing
equivalent logic in Lua or C#.</p><h6 id=enforces-game-structure>Enforces Game Structure<a hidden class=anchor aria-hidden=true href=#enforces-game-structure>#</a></h6><p>DSLs can guide modders into creating content that fits the game&rsquo;s intended structure and rules.</p><h5 id=cons-of-dsls>Cons of DSLs<a hidden class=anchor aria-hidden=true href=#cons-of-dsls>#</a></h5><h6 id=learning-curve>Learning Curve<a hidden class=anchor aria-hidden=true href=#learning-curve>#</a></h6><p>Every DSL is unique. Modders have to learn a new, often proprietary, syntax and vocabulary for each game (or game
engine). Documentation might be sparse or community-driven.</p><h6 id=limited-power>Limited Power<a hidden class=anchor aria-hidden=true href=#limited-power>#</a></h6><p>DSLs are, by definition, domain-specific. Modders might hit a wall if they want to implement something complex or novel
that the DSL wasn&rsquo;t designed for. You can&rsquo;t easily write a new pathfinding algorithm or a complex economic simulation
using only Paradox event script commands. Modders sometimes have to resort to clever workarounds or request new features
from the developers.</p><h6 id=developer-burden>Developer Burden<a hidden class=anchor aria-hidden=true href=#developer-burden>#</a></h6><p>The game developers have to design, implement, document, and <em>maintain</em> the DSL and its parser/interpreter. If modders
need new functionality, developers might have to add new keywords or commands to the language itself, which can be
time-consuming.</p><h4 id=hybrid-approaches>Hybrid Approaches<a hidden class=anchor aria-hidden=true href=#hybrid-approaches>#</a></h4><p>Some games try to get the best of both worlds. They might use a simple data format or DSL for common tasks (like
defining items or basic quests) and embed a general-purpose language (like Lua) for more complex scripting needs (like
custom AI behaviors or intricate quest logic). This offers an easier entry point while still providing power for
advanced users. Forsslund even mused about using Lua for prototyping event logic due to its flexibility and then
potentially translating it back to the faster DSL format for release, though this seems rare in practice [8] [8].</p><h4 id=so-which-to-choose>So, Which to Choose?<a hidden class=anchor aria-hidden=true href=#so-which-to-choose>#</a></h4><p>The decision often boils down to the game&rsquo;s specific needs and the developer&rsquo;s philosophy:</p><ul><li>If <strong>performance</strong> is absolutely critical (e.g., complex simulations running thousands of checks per second) and the
types of mods expected are mostly content-focused within predictable boundaries, a <strong>DSL</strong> might be the better
choice (Paradox).</li><li>If <strong>flexibility</strong> and empowering modders to create truly novel systems is the priority, and the performance overhead
is acceptable (or can be managed), an <strong>embedded general-purpose language</strong> is often preferred (<em>Factorio</em> with Lua,
<em>RimWorld</em> with C#).</li><li>If the game is built in an engine like Unity or uses .NET, allowing mods in the <strong>same language (C#)</strong> becomes a
natural, powerful option, effectively turning the game&rsquo;s own codebase/API into the &ldquo;language&rdquo; for mods (<em>RimWorld</em>,
<em>Bannerlord</em>).</li></ul><p>Now that we&rsquo;ve considered the <em>language</em> mods are written in, let&rsquo;s look at <em>how</em> that code actually gets executed by
the game.</p><h2 id=how-mods-run-interpreted-vs-compiled-execution>How Mods Run: Interpreted vs. Compiled Execution<a hidden class=anchor aria-hidden=true href=#how-mods-run-interpreted-vs-compiled-execution>#</a></h2><p>This is another fundamental fork in the road for modding architecture. Does the game run mod code directly from source
files (or intermediate bytecode) at runtime, or does it load pre-compiled binary files (like DLLs)? This choice deeply
impacts performance, security, and the mod development workflow.</p><p>Let&rsquo;s visualize the difference conceptually (imagine a diagram here, as generating one directly is tricky):</p><h3 id=scenario-a-interpreted-mod>Scenario A: Interpreted Mod<a hidden class=anchor aria-hidden=true href=#scenario-a-interpreted-mod>#</a></h3><ol><li>Modder writes <code>MyMod.lua</code> (source code).</li><li>Player installs <code>MyMod.lua</code>.</li><li>Game starts, loads <code>MyMod.lua</code>.</li><li>Game embeds a Lua Virtual Machine (VM).</li><li>When needed, the Game Engine tells the Lua VM: &ldquo;Run this function from <code>MyMod.lua</code>.&rdquo;</li><li>The Lua VM interprets (or JITs) the Lua code and executes it, calling back into the Game Engine API for game
data/actions.</li></ol><h3 id=scenario-b-compiled-mod>Scenario B: Compiled Mod<a hidden class=anchor aria-hidden=true href=#scenario-b-compiled-mod>#</a></h3><ol><li>Modder writes <code>MyMod.cs</code> (source code).</li><li>Modder uses a C# compiler (like <code>csc</code> or via Visual Studio) to build <code>MyMod.dll</code> (binary code).</li><li>Player installs <code>MyMod.dll</code>.</li><li>Game starts, uses the operating system or .NET runtime to load <code>MyMod.dll</code> directly into its own process memory.</li><li>When needed, the Game Engine directly calls functions within <code>MyMod.dll</code> (like methods in a C# class).</li><li>The code inside <code>MyMod.dll</code> runs as native (or JIT-compiled) code, calling back into the Game Engine API.</li></ol><p>Now let&rsquo;s unpack the implications.</p><h3 id=interpreted-mods-runtime-scripting>Interpreted Mods (Runtime Scripting)<a hidden class=anchor aria-hidden=true href=#interpreted-mods-runtime-scripting>#</a></h3><p>In this model, the mod code isn&rsquo;t native machine instructions when the player installs it. The game itself contains the
necessary machinery (an interpreter or a VM) to execute the mod scripts on the fly.</p><h4 id=how-it-works>How it Works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h4><p>The game loads the script files (e.g., <code>.lua</code>, <code>.py</code>). It might parse them line-by-line (very slow, rare nowadays) or,
more commonly, compile them into an intermediate bytecode format first (Lua does this automatically). Then, an
interpreter executes this bytecode. Sometimes, a Just-In-Time (JIT) compiler might even translate frequently used parts
of the bytecode into native machine code at runtime for better speed.</p><h4 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h4><p>Games using Lua (like <em>Factorio</em>), Python (<em>Civ IV</em>), or potentially JavaScript. Even Paradox&rsquo;s DSLs are essentially
interpreted – the engine parses the <code>.txt</code> files and executes the logic they represent.</p><h4 id=pros-of-interpreted-mods>Pros of Interpreted Mods<a hidden class=anchor aria-hidden=true href=#pros-of-interpreted-mods>#</a></h4><h5 id=easier-development>Easier Development<a hidden class=anchor aria-hidden=true href=#easier-development>#</a></h5><p>Modders often just need a text editor. There&rsquo;s no separate compilation step. They can make changes and (sometimes) see
results quickly, leading to faster iteration.</p><h5 id=cross-platform-compatibility>Cross-Platform Compatibility<a hidden class=anchor aria-hidden=true href=#cross-platform-compatibility>#</a></h5><p>A Lua script mod will generally work identically on Windows, macOS, or Linux versions of the game, as long as the game
itself includes the Lua interpreter for each platform. The mod code is platform-agnostic.</p><h5 id=easier-sandboxing>Easier Sandboxing<a hidden class=anchor aria-hidden=true href=#easier-sandboxing>#</a></h5><p>As we discussed, the interpreter acts as a natural choke point. The game developer can control the environment the
interpreter provides to the script, removing dangerous functions or libraries (like file I/O or network access). This
makes sandboxing <em>much</em> more feasible than with compiled code.</p><h4 id=cons-of-interpreted-mods>Cons of Interpreted Mods<a hidden class=anchor aria-hidden=true href=#cons-of-interpreted-mods>#</a></h4><h5 id=performance-1>Performance<a hidden class=anchor aria-hidden=true href=#performance-1>#</a></h5><p>This is the big one. Even with bytecode compilation and JITs, interpreted code is generally slower than fully
pre-compiled native code. We saw Forsslund&rsquo;s 6x slowdown figure for Lua vs C++ [8]. The overhead comes from the
interpretation/JIT process itself and the cost of crossing the boundary between the native game engine and the scripting
VM (data marshaling, function call setup) [8]. This might be perfectly acceptable if mods only run occasionally for
non-critical tasks, but prohibitive if mods need to run complex logic every frame.</p><h5 id=requires-embedding-runtime>Requires Embedding Runtime<a hidden class=anchor aria-hidden=true href=#requires-embedding-runtime>#</a></h5><p>The game developer needs to integrate and ship the language interpreter/VM with the game.</p><h3 id=compiled-mods-native-or-bytecode-plugins>Compiled Mods (Native or Bytecode Plugins)<a hidden class=anchor aria-hidden=true href=#compiled-mods-native-or-bytecode-plugins>#</a></h3><p>Here, mods are distributed as binary files (like <code>.dll</code> on Windows, <code>.so</code> on Linux, or <code>.jar</code> containing Java bytecode)
that the game loads directly into its process space.</p><h4 id=how-it-works-1>How it Works<a hidden class=anchor aria-hidden=true href=#how-it-works-1>#</a></h4><p>The game uses the operating system&rsquo;s dynamic library loading mechanism (like <code>LoadLibrary</code> on Windows) or a runtime
environment&rsquo;s assembly loading feature (like .NET&rsquo;s <code>Assembly.Load</code> or the Java Virtual Machine&rsquo;s classloader) to load
the mod&rsquo;s binary file. The code in the mod then runs essentially as part of the game itself.</p><h4 id=examples-1>Examples<a hidden class=anchor aria-hidden=true href=#examples-1>#</a></h4><p><em>Mount & Blade II: Bannerlord</em> (C# DLLs loaded via .NET) [5], <em>RimWorld</em> (C# DLLs loaded via Unity/.NET), <em>Minecraft</em> (
Java JARs loaded by Forge/Fabric via the JVM), <em>Kerbal Space Program</em> (C# DLLs). Many games using engines like Unity or
Unreal might implicitly support compiled mods if modders can figure out how to get their compiled assemblies loaded,
even without official sanction.</p><h4 id=pros-of-compiled-mods>Pros of Compiled Mods<a hidden class=anchor aria-hidden=true href=#pros-of-compiled-mods>#</a></h4><h5 id=performance-2>Performance<a hidden class=anchor aria-hidden=true href=#performance-2>#</a></h5><p>This is the main advantage. Compiled code runs at or near native speed. A C# mod in <em>Bannerlord</em> or <em>RimWorld</em> executes
much like the game&rsquo;s own C# code. A C++ mod compiled to a DLL would run just as fast as the engine&rsquo;s C++. This enables
incredibly complex mods – total conversions, new physics systems, sophisticated AI – that might be computationally
infeasible with slower scripting languages.</p><h5 id=power--flexibility>Power & Flexibility<a hidden class=anchor aria-hidden=true href=#power--flexibility>#</a></h5><p>Modders typically get access to the full power of the language the mod is written in (C++, C#, Java). They can use
complex language features, interact more deeply with the engine&rsquo;s API (if exposed), and potentially link against
external libraries (though this adds complexity and risk).</p><h4 id=cons-of-compiled-mods>Cons of Compiled Mods<a hidden class=anchor aria-hidden=true href=#cons-of-compiled-mods>#</a></h4><h5 id=development-complexity>Development Complexity<a hidden class=anchor aria-hidden=true href=#development-complexity>#</a></h5><p>Modders need a proper development environment: a compiler, potentially the game&rsquo;s specific SDK or header files/library
references. The workflow involves writing code, compiling, packaging, and then testing in-game. This is a higher barrier
to entry than editing a script file.</p><h5 id=compatibility-issues>Compatibility Issues<a hidden class=anchor aria-hidden=true href=#compatibility-issues>#</a></h5><p>Compiled mods are often tightly coupled to a specific version of the game or engine API. When the game updates, internal
changes (like function signatures changing, classes being refactored, memory layouts shifting in C++) can easily break
compiled mods, requiring the mod author to update and recompile. This is a constant headache in communities like
<em>Minecraft</em> or <em>Bannerlord</em>.</p><h5 id=platform-dependence>Platform Dependence<a hidden class=anchor aria-hidden=true href=#platform-dependence>#</a></h5><p>A DLL compiled for Windows won&rsquo;t work on Linux or macOS. While managed runtimes like .NET and Java offer better
cross-platform potential (compile to intermediate bytecode), native C/C++ mods are inherently platform-specific.</p><h5 id=security-nightmare>Security Nightmare<a hidden class=anchor aria-hidden=true href=#security-nightmare>#</a></h5><p>This is the biggest drawback. By default, a compiled mod loaded into the game&rsquo;s process has the <em>exact same permissions</em>
as the game itself. If the game is running as the user, the mod can do <em>anything</em> the user can do: read/write arbitrary
files, connect to the internet, launch other processes, install malware, delete <code>system32</code> (okay, maybe not that easily,
but you get the idea). There is <strong>no inherent sandbox</strong>. We&rsquo;ll talk more about security later, but compiled mods
basically operate on trust [12].</p><h5 id=stability-risks>Stability Risks<a hidden class=anchor aria-hidden=true href=#stability-risks>#</a></h5><p>A bug in a compiled mod (like a null pointer dereference, an unhandled exception, or an infinite loop) can easily crash
the entire game process, not just the mod&rsquo;s operation.</p><h3 id=a-potential-middle-ground-managed-runtimes-and-future-tech>A Potential Middle Ground: Managed Runtimes and Future Tech<a hidden class=anchor aria-hidden=true href=#a-potential-middle-ground-managed-runtimes-and-future-tech>#</a></h3><p>It&rsquo;s worth noting that compiled mods in managed languages like C# or Java occupy a slightly different space than native
C++ DLLs. The runtime environment (CLR for .NET, JVM for Java) does provide <em>some</em> layer of abstraction and safety (
e.g., memory safety, garbage collection). Historically, these runtimes also had security managers or code access
security systems (like .NET CAS) designed to run untrusted code with limited permissions [12]. However, these features
are largely deprecated or considered ineffective/too complex for robust sandboxing in modern versions, especially within
a single process [12]. So, in practice, C# mods in <em>RimWorld</em> or <em>Bannerlord</em> still run with full trust.</p><p>Looking ahead, technologies like <strong>WebAssembly (WASM)</strong> offer a tantalizing possibility. WASM is a binary instruction
format designed to be a portable compilation target for high-level languages, enabling deployment on the web for client
and server applications. Crucially, it&rsquo;s designed to run <em>safely</em> in a sandboxed environment, with near-native
performance. Could future games allow mods compiled to WASM? It might offer the speed benefits of compiled code with the
security benefits of a sandbox. This is an active area of interest we&rsquo;ll revisit in the &ldquo;Future Directions&rdquo; section.</p><h3 id=summary-table-interpreted-vs-compiled>Summary Table: Interpreted vs. Compiled<a hidden class=anchor aria-hidden=true href=#summary-table-interpreted-vs-compiled>#</a></h3><table><thead><tr><th>Feature</th><th>Interpreted Mods (e.g., Lua, Python, DSLs)</th><th>Compiled Mods (e.g., C# DLLs, Java JARs, C++ DLLs)</th></tr></thead><tbody><tr><td><strong>Performance</strong></td><td>Generally Slower (VM overhead, boundary crossing)</td><td>Generally Faster (Native or near-native speed)</td></tr><tr><td><strong>Dev Ease</strong></td><td>Easier (Text editor, no compile step, faster iteration)</td><td>Harder (Compiler, SDK, build process needed)</td></tr><tr><td><strong>Flexibility</strong></td><td>Limited by exposed API & language features</td><td>High (Full language power, potentially external libraries)</td></tr><tr><td><strong>Compatibility</strong></td><td>Often better survives game updates (if API stable)</td><td>Often breaks with game updates (tight coupling)</td></tr><tr><td><strong>Cross-Platform</strong></td><td>Good (Script runs on any platform with game+VM)</td><td>Poor (Native DLLs), Better (Managed bytecode like .NET/Java)</td></tr><tr><td><strong>Security</strong></td><td>Easier to Sandbox (Control VM environment, limit API)</td><td>Very Hard to Sandbox (Runs with full game permissions)</td></tr><tr><td><strong>Stability</strong></td><td>Errors might be caught by VM (less likely to crash game)</td><td>Errors can easily crash the entire game process</td></tr></tbody></table><p>Developers must weigh these factors carefully. If they want to enable deep, complex mods and trust their community (or
implement external security measures), compiled mods offer the most power. If they prioritize accessibility, safety, and
easier maintenance, interpreted scripts are often the way to go. Many successful modding scenes exist at both ends of
this spectrum.</p><p>Now, assuming we&rsquo;ve chosen a language and execution model, how does the game actually <em>find</em>, <em>load</em>, and <em>run</em> these
mods?</p><h2 id=bringing-mods-to-life-loading-and-lifecycle-integration>Bringing Mods to Life: Loading and Lifecycle Integration<a hidden class=anchor aria-hidden=true href=#bringing-mods-to-life-loading-and-lifecycle-integration>#</a></h2><p>Okay, so players have downloaded some mods. How does the game actually know they exist, load their content and code, and
make sure they run at the right moments without stepping on each other&rsquo;s toes? This involves designing a robust mod
loading system and integrating mods into the game&rsquo;s lifecycle.</p><h3 id=finding-and-identifying-mods>Finding and Identifying Mods<a hidden class=anchor aria-hidden=true href=#finding-and-identifying-mods>#</a></h3><p>First, the game needs to locate installed mods. Common strategies include:</p><h4 id=dedicated-mods-folder>Dedicated <code>Mods</code> Folder<a hidden class=anchor aria-hidden=true href=#dedicated-mods-folder>#</a></h4><p>The simplest approach. The game looks inside a specific folder (e.g., <code>My Documents/MyGame/Mods/</code> or
<code>&lt;GameInstall>/Mods/</code>) for subfolders or archive files representing individual mods.</p><h4 id=launcher-manifests>Launcher Manifests<a hidden class=anchor aria-hidden=true href=#launcher-manifests>#</a></h4><p>Some games use a launcher application that manages mods. The launcher might maintain a list or configuration file
specifying which mods are enabled and where they are located. <em>Bannerlord</em>&rsquo;s launcher does this, reading module
information before starting the game proper [5].</p><h4 id=platform-integration>Platform Integration<a hidden class=anchor aria-hidden=true href=#platform-integration>#</a></h4><p>Increasingly common is integration with platforms like Steam Workshop. Players subscribe to mods on Workshop, and the
Steam client downloads them to a specific location. The game then uses the Steam API to find and load subscribed mods.</p><p>Once found, each mod usually needs a <strong>descriptor file</strong> (sometimes called a manifest). This file contains metadata
about the mod, such as:</p><ul><li>Unique ID, Name, Author, Version</li><li>Description</li><li>Dependencies (other mods it requires)</li><li>Load order hints</li><li>Entry points (e.g., the main script file to run, or the DLL and class name to load).</li></ul><p><em>Bannerlord</em>&rsquo;s <code>SubModule.xml</code> is a prime example of such a descriptor, containing all this information [5] [5].
<em>RimWorld</em> uses an <code>About.xml</code> file for basic metadata [4].</p><h3 id=loading-mods-order-matters>Loading Mods: Order Matters!<a hidden class=anchor aria-hidden=true href=#loading-mods-order-matters>#</a></h3><p>The game (or its launcher/mod manager) reads these descriptors, decides which mods are active, and then proceeds to load
them. This typically happens during game startup, before the main menu appears.</p><p>A critical aspect here is <strong>load order</strong>. If two mods modify the same game asset or piece of logic, which one &ldquo;wins&rdquo;?
Most systems adopt a &ldquo;last loaded wins&rdquo; rule. Mod A changes weapon damage to 10, Mod B loads later and changes it to
15 – the final damage will be 15.</p><p>This makes the <em>order</em> in which mods are loaded crucial for compatibility. Many games allow players to manually set the
load order through a mod manager UI (common in Bethesda games, Paradox games via launchers). The mod descriptor file
might also specify dependencies (e.g., &ldquo;MyMod requires CoreLibraryMod version 1.2+&rdquo;). The mod loader must respect these
dependencies, ensuring CoreLibraryMod is loaded <em>before</em> MyMod. If dependencies are missing or versions conflict, the
loader should ideally warn the user or disable the problematic mod. Tools like LOOT (Load Order Optimization Tool) for
Bethesda games automate the process of sorting mods based on known compatibility rules.</p><h3 id=the-mod-lifecycle-initialization-and-execution-hooks>The Mod Lifecycle: Initialization and Execution Hooks<a hidden class=anchor aria-hidden=true href=#the-mod-lifecycle-initialization-and-execution-hooks>#</a></h3><p>Once a mod&rsquo;s files (data, scripts, binaries) are loaded into memory, its code often needs to run at specific points in
the game&rsquo;s lifecycle. A typical flow looks like this:</p><h4 id=load>Load<a hidden class=anchor aria-hidden=true href=#load>#</a></h4><p>The game loads the mod&rsquo;s assets and code.</p><h4 id=initialize>Initialize<a hidden class=anchor aria-hidden=true href=#initialize>#</a></h4><p>The game calls an initialization function or method in the mod. This is where the mod usually sets itself up, registers
things with the game engine, or applies patches.</p><h4 id=runtime-hooks>Runtime Hooks<a hidden class=anchor aria-hidden=true href=#runtime-hooks>#</a></h4><p>During gameplay, the game triggers the mod&rsquo;s code in response to specific events or at regular intervals.</p><h4 id=initialization>Initialization:<a hidden class=anchor aria-hidden=true href=#initialization>#</a></h4><h5 id=script-mods>Script Mods<a hidden class=anchor aria-hidden=true href=#script-mods>#</a></h5><p>Might have a specific <code>init()</code> function the engine calls after loading the script. Or the script might just run
top-to-bottom, registering event handlers as it goes.</p><h5 id=compiled-mods>Compiled Mods<a hidden class=anchor aria-hidden=true href=#compiled-mods>#</a></h5><p>Often have a designated entry point class. <em>Bannerlord</em> mods inherit from <code>MBSubModuleBase</code> and override methods like
<code>OnSubModuleLoad()</code> [5]. <em>RimWorld</em> mods can have a class inheriting from <code>Verse.Mod</code>, whose constructor acts as the
init hook [4]. <em>Minecraft Forge</em> defines a whole sequence of initialization events (<code>FMLPreInitializationEvent</code>,
<code>FMLInitializationEvent</code>, <code>FMLPostInitializationEvent</code>) that mods listen for, ensuring things happen in the right
order (e.g., all items registered before recipes) [14].</p><p>This initialization phase is crucial for mods to tell the game &ldquo;I exist, and here&rsquo;s what I do.&rdquo; They might register new
item types, add UI elements, subscribe to game events, or (in the case of patching libraries like Harmony) apply their
modifications to the game&rsquo;s base code.</p><h4 id=runtime-execution-hooks>Runtime Execution Hooks<a hidden class=anchor aria-hidden=true href=#runtime-execution-hooks>#</a></h4><p>After initialization, how does mod code get triggered during actual gameplay? Developers provide various &ldquo;hooks&rdquo;:</p><h5 id=event-callbacks--subscriptions>Event Callbacks / Subscriptions<a hidden class=anchor aria-hidden=true href=#event-callbacks--subscriptions>#</a></h5><p>This is very common. The game engine defines a set of events (e.g., <code>OnPlayerDamaged</code>, <code>OnQuestStarted</code>, <code>OnTick</code>,
<code>OnGuiRender</code>). Mods can register functions (callbacks) to be executed whenever a specific event occurs. The engine
manages firing these events and calling all subscribed mod functions, often passing event-specific data (like the amount
of damage taken, or the quest ID).</p><ul><li><em>Factorio</em>&rsquo;s <code>script.on_event(defines.events.EVENT_NAME, function(event_data) ... end)</code> is a classic example [6].</li><li>Paradox&rsquo;s DSL works similarly; event blocks have <code>trigger</code> conditions the engine constantly checks, and <code>immediate</code> or
<code>option</code> effects that run when triggered [15].</li><li><em>Minecraft Forge</em> has an extensive event bus (<code>MinecraftForge.EVENT_BUS</code>) covering hundreds of game actions.</li><li><em>Bannerlord</em>&rsquo;s <code>CampaignEvents</code> system allows mods to subscribe to things like <code>DailyTickEvent</code>.</li></ul><h5 id=method-overrides--subclassing>Method Overrides / Subclassing<a hidden class=anchor aria-hidden=true href=#method-overrides--subclassing>#</a></h5><p>If the game&rsquo;s architecture uses object-oriented principles heavily, it might allow mods to subclass existing game
classes and override virtual methods to change behavior. <em>Bannerlord</em> does this with its <code>CampaignBehaviorBase</code>,
allowing mods to add custom logic to the campaign loop.</p><h5 id=direct-patching-eg-harmony>Direct Patching (e.g., Harmony)<a hidden class=anchor aria-hidden=true href=#direct-patching-eg-harmony>#</a></h5><p>This is a more invasive but powerful technique, extremely popular in the Unity C# modding scene (<em>RimWorld</em>, <em>Kerbal
Space Program</em>, <em>Cities: Skylines</em>, sometimes <em>Bannerlord</em>). Libraries like Harmony allow mods to dynamically modify the
intermediate language (IL) bytecode of existing game methods <em>at runtime</em>. Mods can:</p><h6 id=prefix>Prefix<a hidden class=anchor aria-hidden=true href=#prefix>#</a></h6><p>Run code <em>before</em> the original method executes. Can modify arguments or even skip the original method entirely.</p><h6 id=postfix>Postfix<a hidden class=anchor aria-hidden=true href=#postfix>#</a></h6><p>Run code <em>after</em> the original method executes. Can access the return value and modify it.</p><h6 id=transpiler>Transpiler<a hidden class=anchor aria-hidden=true href=#transpiler>#</a></h6><p>Directly rewrite the IL instructions of the original method. Extremely powerful, but complex and fragile.</p><p><em>RimWorld</em> mods use Harmony extensively to alter core game mechanics without needing the developers to provide explicit
hooks for everything [12]. While powerful, multiple mods patching the same method can lead to compatibility nightmares
if not carefully managed.</p><h5 id=tickupdate-hooks>Tick/Update Hooks<a hidden class=anchor aria-hidden=true href=#tickupdate-hooks>#</a></h5><p>Some systems allow mods to register a function that gets called every game frame or every simulation tick (e.g.,
<code>OnApplicationTick</code> in <em>Bannerlord</em>, or update loops in Unity). This is necessary for mods that need continuous
processing, but must be used cautiously to avoid performance degradation.</p><h4 id=handling-mod-errors>Handling Mod Errors:<a hidden class=anchor aria-hidden=true href=#handling-mod-errors>#</a></h4><p>What happens if a mod script has a bug or a compiled mod throws an exception? A robust modding framework should
anticipate this. Ideally, the game engine should wrap calls into mod code within error handlers (like <code>try-catch</code>
blocks). If a mod crashes:</p><ul><li>Log the error clearly, indicating which mod caused it.</li><li>Prevent the error from crashing the entire game if possible.</li><li>Potentially disable the faulty mod for the rest of the session.</li><li>Notify the user about the issue.</li></ul><p>Games like <em>RimWorld</em> are pretty good at catching mod errors and displaying a debug log window without necessarily
crashing, allowing the player to continue (though the game state might be compromised).</p><h3 id=dynamic-loading-hot-swapping>Dynamic Loading (Hot Swapping)?<a hidden class=anchor aria-hidden=true href=#dynamic-loading-hot-swapping>#</a></h3><p>Can you install or uninstall mods while the game is running? Usually, no. Most games require a restart for mod changes
to take effect. Why? Because mods often need to integrate deeply during the initial loading phase (registering items,
patching code). Injecting or removing this integration into a live, running simulation state is extremely complex and
prone to errors. It&rsquo;s much simpler and safer to load everything upfront.</p><p>However, some systems are exploring partial runtime loading, especially for assets or data-driven content [16], but
runtime code injection/removal remains rare in mainstream modding.</p><p>An interesting related concept is <strong>parallelized loading</strong>. <em>Minecraft Forge</em>, facing long startup times with large
modpacks, implemented parallel loading for certain initialization phases to speed things up, carefully managing
dependencies and synchronization between stages [14].</p><h3 id=resource-loading>Resource Loading<a hidden class=anchor aria-hidden=true href=#resource-loading>#</a></h3><p>Mods aren&rsquo;t just code; they often include assets (textures, models, sounds) and new data definitions. The modding
framework needs to handle loading these too. Common approaches include:</p><h4 id=file-overrides>File Overrides<a hidden class=anchor aria-hidden=true href=#file-overrides>#</a></h4><p>A simple method where mod files placed in the correct directory structure simply override the base game files with the
same name. Older games often used this. Fragile, as multiple mods overriding the same file causes conflicts.</p><h4 id=virtual-file-systems--archives>Virtual File Systems / Archives<a hidden class=anchor aria-hidden=true href=#virtual-file-systems--archives>#</a></h4><p>Games like <em>Skyrim</em> use archive files (<code>.bsa</code>) and a system where loose files in a <code>Data</code> folder (often managed by mod
managers) take precedence over archives, and load order determines which loose file wins if multiple mods provide the
same one.</p><h4 id=data-merging>Data Merging<a hidden class=anchor aria-hidden=true href=#data-merging>#</a></h4><p>For structured data (like lists of items or events), the engine might merge data from multiple mods. Paradox games
effectively do this, combining event files, localization strings, etc., from all active mods into the game&rsquo;s runtime
database.</p><h4 id=api-driven-loading>API-Driven Loading<a hidden class=anchor aria-hidden=true href=#api-driven-loading>#</a></h4><p>The modding API might provide functions for mods to explicitly load their own assets (e.g.,
<code>LoadTexture("mymod/textures/cool_gun.png")</code>) or register new data entries programmatically.</p><p>A well-designed system makes it clear how mod resources are integrated and how conflicts are resolved.</p><p>In essence, managing the mod lifecycle is about orchestrating the discovery, loading, initialization, and runtime
execution of potentially many independent pieces of user content, ensuring they play nicely together (as much as
possible) and integrate seamlessly into the game&rsquo;s flow.</p><p>Now, for the part that keeps developers up at night&mldr;</p><h2 id=the-elephant-in-the-room-security-and-sandboxing>The Elephant in the Room: Security and Sandboxing<a hidden class=anchor aria-hidden=true href=#the-elephant-in-the-room-security-and-sandboxing>#</a></h2><p>Okay, let&rsquo;s talk security. We&rsquo;ve established that mods, especially compiled ones, can be incredibly powerful. They run
code directly on the player&rsquo;s machine, often within the game&rsquo;s own process. What stops a malicious mod author from
slipping malware into their &ldquo;Awesome New Sword&rdquo; mod?</p><p>Honestly? In many cases, <strong>not much technical enforcement</strong>.</p><h3 id=the-current-reality-trust-community-and-hope>The Current Reality: Trust, Community, and Hope<a hidden class=anchor aria-hidden=true href=#the-current-reality-trust-community-and-hope>#</a></h3><p>A recurring theme in discussions about mod security for single-player PC games is that the primary defense mechanism is
<em>not</em> a technical sandbox, but rather <strong>community trust and platform curation</strong>. A GitHub discussion involving
developers wrestling with this exact problem concluded: <em>&ldquo;Most games do not impose any kind of security restrictions on
mods and rely on community trust.&rdquo;</em> [12].</p><p>This plays out in several ways:</p><h4 id=reputable-sources>Reputable Sources<a hidden class=anchor aria-hidden=true href=#reputable-sources>#</a></h4><p>Players are generally advised to download mods only from well-known platforms (Steam Workshop, Nexus Mods, official game
forums, reputable community sites like ModDB). These platforms often have moderation teams and community reporting
systems to catch malicious uploads.</p><h4 id=community-vetting>Community Vetting<a hidden class=anchor aria-hidden=true href=#community-vetting>#</a></h4><p>Popular mods are downloaded and used by thousands of players, including many technically savvy ones. If a mod started
doing suspicious things (like making weird network calls or messing with system files), it would likely be noticed and
reported quickly. Open-source mods are even easier to inspect.</p><h4 id=antivirus-software>Antivirus Software<a hidden class=anchor aria-hidden=true href=#antivirus-software>#</a></h4><p>Basic antivirus scanning might catch known malware signatures packaged within mod files [17]. After a malware scare
involving a <em>Cities: Skylines</em> mod, Paradox stated that mods uploaded to their Paradox Mods platform undergo antivirus
scanning [18].</p><h4 id=developer-warnings>Developer Warnings<a hidden class=anchor aria-hidden=true href=#developer-warnings>#</a></h4><p>Some developers explicitly warn players about the risks. The <em>Bannerlord</em> launcher, for example, displays a message
cautioning users about running unverified DLLs from mods.</p><p><strong>But is this enough?</strong> History suggests maybe not. There have been notable incidents:</p><h4 id=dota-2-mods-2023>Dota 2 Mods (2023)<a hidden class=anchor aria-hidden=true href=#dota-2-mods-2023>#</a></h4><p>Malicious mods uploaded to the Steam Workshop exploited a vulnerability in the game&rsquo;s JavaScript engine (Panorama UI) to
gain remote code execution capabilities on users&rsquo; machines [11]. This wasn&rsquo;t just a mod using legitimate APIs
maliciously; it was exploiting a flaw in the sandbox itself.</p><h4 id=minecraft-mods-various>Minecraft Mods (Various)<a hidden class=anchor aria-hidden=true href=#minecraft-mods-various>#</a></h4><p>The large, somewhat unregulated <em>Minecraft</em> modding scene has seen multiple instances of malware distributed through
mods on platforms like CurseForge, ranging from credential stealers to ransomware [19] [20].</p><h4 id=cities-skylines-malware-2022>Cities: Skylines Malware (2022)<a hidden class=anchor aria-hidden=true href=#cities-skylines-malware-2022>#</a></h4><p>A mod author was found distributing malware through several popular mods on the Steam Workshop.</p><h4 id=bannerlord-concerns>Bannerlord Concerns<a hidden class=anchor aria-hidden=true href=#bannerlord-concerns>#</a></h4><p>Even without specific major incidents (yet), the community has voiced unease about the inherent risk of loading
arbitrary DLLs, questioning why a potentially safer scripting approach wasn&rsquo;t chosen [21].</p><p>These cases highlight that relying solely on trust and community moderation isn&rsquo;t foolproof, especially as modding
becomes more mainstream and potentially attracts more malicious actors. So, what <em>technical</em> solutions exist or could be
used?</p><h3 id=sandboxing-script-mods-the-easier-path>Sandboxing Script Mods: The Easier Path<a hidden class=anchor aria-hidden=true href=#sandboxing-script-mods-the-easier-path>#</a></h3><p>If your game uses an interpreted scripting language like Lua or Python, you have a much better chance of effectively
sandboxing mods. The interpreter itself provides a natural boundary.</p><h4 id=how-it-works-2>How it Works<a hidden class=anchor aria-hidden=true href=#how-it-works-2>#</a></h4><p>When the game engine initializes the scripting environment for a mod, it can deliberately <em>limit</em> the functions and
libraries available to that script.</p><ul><li>For <strong>Lua</strong>, this is relatively straightforward. The host application (the game) controls the global environment table
that scripts run in. You can simply <em>not</em> load dangerous standard libraries like <code>io</code> (file input/output) and <code>os</code> (
operating system commands). You can also replace or wrap built-in functions. The mod only gets access to the functions
and game objects explicitly exposed through the C API bindings created by the developer.</li><li><em>World of Warcraft</em>&rsquo;s UI modding system is a prime example of a heavily sandboxed Lua environment. Addons can
manipulate the UI and query some game data, but they absolutely cannot access the local file system or make arbitrary
network calls. Certain sensitive API calls are even restricted during combat to prevent automation (&ldquo;protected
functions&rdquo;).</li><li><strong>Python</strong> sandboxing is possible but generally considered harder due to the language&rsquo;s size and dynamic nature.
Techniques involve using restricted execution modes, customizing the available built-in modules, or running the Python
interpreter within an OS-level sandbox.</li></ul><h4 id=effectiveness>Effectiveness<a hidden class=anchor aria-hidden=true href=#effectiveness>#</a></h4><p>API-level sandboxing for scripts is quite effective at preventing mods from directly causing harm <em>outside</em> the game (
like deleting files). It doesn&rsquo;t necessarily prevent mods from crashing the game or behaving badly <em>within</em> the game&rsquo;s
logic (e.g., infinite loops, excessive resource consumption), but it significantly contains the risk.</p><h3 id=sandboxing-compiled-mods-the-herculean-task>Sandboxing Compiled Mods: The Herculean Task<a hidden class=anchor aria-hidden=true href=#sandboxing-compiled-mods-the-herculean-task>#</a></h3><p>This is where things get really difficult. Compiled code (C++, C#, Java bytecode) running in the same process as the
game has, by default, the same access rights. Truly isolating it is a major challenge.</p><h4 id=why-its-hard>Why it&rsquo;s Hard:<a hidden class=anchor aria-hidden=true href=#why-its-hard>#</a></h4><p>There&rsquo;s no natural interpreter boundary to control. The mod code is executing directly (or via a JIT) on the CPU.
Preventing it from making system calls (like opening files or network sockets) requires intervening at a lower level.</p><h4 id=approaches-mostly-theoretical-or-limited>Approaches (Mostly Theoretical or Limited)<a hidden class=anchor aria-hidden=true href=#approaches-mostly-theoretical-or-limited>#</a></h4><h5 id=os-level-sandboxing>OS-Level Sandboxing<a hidden class=anchor aria-hidden=true href=#os-level-sandboxing>#</a></h5><p>Run the <em>entire game process</em> within an operating system sandbox (like a container, Windows AppContainer, macOS App
Sandbox). This limits what the <em>whole game</em> (including mods) can do. While effective for security, it can be overly
restrictive, potentially breaking legitimate game features (like saving games anywhere, interacting with peripherals)
and might not be feasible for traditional PC game distribution models (e.g., Steam games usually run with full user
privileges).</p><h5 id=process-isolation>Process Isolation:<a hidden class=anchor aria-hidden=true href=#process-isolation>#</a></h5><p>Run each mod (or the modding subsystem) in a <em>separate process</em> with lower privileges. The main game process
communicates with the mod process via Inter-Process Communication (IPC). This is how web browsers sandbox
tabs/extensions [12].</p><h6 id=pros>Pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h6><p>Strong isolation. A crash in the mod process doesn&rsquo;t take down the game. OS enforces privilege separation.</p><h6 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h6><p>Huge architectural complexity for the game engine (managing multiple processes, efficient IPC for game data).
Significant performance overhead due to IPC. Very few games attempt this for modding.</p><h5 id=managed-runtime-security-deprecatedineffective>Managed Runtime Security (Deprecated/Ineffective)<a hidden class=anchor aria-hidden=true href=#managed-runtime-security-deprecatedineffective>#</a></h5><p>As mentioned, .NET&rsquo;s Code Access Security (CAS) and Java&rsquo;s Security Manager were attempts to allow restricting
permissions for loaded assemblies/classes <em>within the same process</em>. However, CAS is deprecated and complex, and wasn&rsquo;t
fully supported in Mono/Unity anyway [12]. Modern consensus is that achieving reliable in-process sandboxing this way is
extremely difficult, if not impossible [12]. Unity games using Harmony definitely don&rsquo;t operate under any such
restrictions.</p><h5 id=static-analysis--api-whitelisting>Static Analysis / API Whitelisting<a hidden class=anchor aria-hidden=true href=#static-analysis--api-whitelisting>#</a></h5><p>Instead of trying to restrict at runtime, analyze the mod&rsquo;s binary code <em>before</em> loading it (or at load time).</p><p>Tools like <strong>Unbreakable</strong> (mentioned in the GitHub discussion, used by SharpLab) analyze .NET assemblies to check which
APIs they call [12]. It works by maintaining a <em>whitelist</em> of allowed namespaces/methods. If a mod tries to use anything
forbidden (like <code>System.IO</code> or <code>System.Net</code>), the analysis fails [12].</p><h6 id=pros-1>Pros<a hidden class=anchor aria-hidden=true href=#pros-1>#</a></h6><p>Can catch attempts to use obviously dangerous APIs without runtime overhead.</p><h6 id=cons-1>Cons<a hidden class=anchor aria-hidden=true href=#cons-1>#</a></h6><p>Not foolproof (clever attackers might obfuscate calls or use reflection). Requires maintaining the whitelist. Might have
false positives/negatives. Doesn&rsquo;t prevent logic bombs or resource exhaustion attacks.</p><h6 id=practical-use>Practical Use<a hidden class=anchor aria-hidden=true href=#practical-use>#</a></h6><p>A game could scan mod DLLs using such a tool and refuse to load mods that fail the check, or (more pragmatically) simply
<em>warn</em> the user that the mod uses potentially unsafe APIs and let them decide whether to proceed [12].</p><h5 id=system-call-interception--runtime-monitoring>System Call Interception / Runtime Monitoring<a hidden class=anchor aria-hidden=true href=#system-call-interception--runtime-monitoring>#</a></h5><p>Use techniques like API hooking or kernel-level monitoring to watch what the mod code <em>actually does</em> at runtime. If it
tries to make a forbidden system call (e.g., <code>CreateFile</code> outside its allowed directory), the monitor could block it or
prompt the user. This is complex to implement robustly and can have performance implications.</p><h4 id=the-takeaway>The Takeaway<a hidden class=anchor aria-hidden=true href=#the-takeaway>#</a></h4><p>Effectively sandboxing compiled mods running in the same process is <em>really hard</em> with current mainstream technologies.
Most games simply don&rsquo;t attempt it, accepting the risk and relying on the community/platform defenses.</p><h3 id=minecraft-a-tale-of-two-editions>Minecraft: A Tale of Two Editions<a hidden class=anchor aria-hidden=true href=#minecraft-a-tale-of-two-editions>#</a></h3><p>Minecraft&rsquo;s approach is illustrative. The original <strong>Java Edition</strong> allows compiled Java mods (via Forge/Fabric) that
run with full JVM permissions – essentially unsandboxed. Mojang never implemented a robust security model for this. When
faced with bringing mods to platforms where security is paramount (consoles, mobile), they created <strong>Bedrock Edition</strong>,
which uses a completely different &ldquo;Add-On&rdquo; system. Bedrock Add-Ons are primarily data-driven (JSON files) with limited
scripting capabilities using a sandboxed JavaScript-like API. This severely restricts what mods can do compared to Java
Edition, but provides a much safer environment suitable for cross-platform play and curated marketplaces. It shows that
sometimes the solution to retrofitting security onto an open system is to create a separate, more restricted system
alongside it.</p><h3 id=where-does-this-leave-us>Where Does This Leave Us?<a hidden class=anchor aria-hidden=true href=#where-does-this-leave-us>#</a></h3><p>For single-player PC games, the status quo is largely &ldquo;modder/player beware,&rdquo; especially for games allowing compiled
mods. While outright malicious mods seem relatively rare compared to the sheer volume of mods available, the potential
risk is undeniable and incidents do happen. Scripting languages offer a much clearer path to technical sandboxing via
API control, and developers using them should absolutely leverage that capability. For compiled mods, the industry seems
to be waiting for better, more practical sandboxing technologies to emerge (like WASM?) or relying on platform-level
solutions (better Workshop scanning, OS sandboxing features).</p><p>Let&rsquo;s now see how these concepts play out in practice by looking at some specific games known for their modding scenes.</p><h2 id=real-world-examples-case-studies-in-modding-tech>Real-World Examples: Case Studies in Modding Tech<a hidden class=anchor aria-hidden=true href=#real-world-examples-case-studies-in-modding-tech>#</a></h2><p>Theory is great, but let&rsquo;s see how different games have actually implemented mod support, embodying the choices and
trade-offs we&rsquo;ve discussed.</p><h3 id=case-study-1-paradox-grand-strategy-games-clausewitzjomini-engine---the-dsl-kings>Case Study 1: Paradox Grand Strategy Games (Clausewitz/Jomini Engine) - The DSL Kings<a hidden class=anchor aria-hidden=true href=#case-study-1-paradox-grand-strategy-games-clausewitzjomini-engine---the-dsl-kings>#</a></h3><p>Paradox Interactive&rsquo;s titles (<em>Europa Universalis IV</em>, <em>Crusader Kings III</em>, <em>Hearts of Iron IV</em>, <em>Stellaris</em>, <em>Victoria
3</em>) are legendary for their depth and equally legendary for their moddability. Total conversion mods that create
entirely new historical or fantasy settings are commonplace. How do they achieve this? Primarily through a <strong>data-driven
approach using a proprietary Domain-Specific Language (DSL)</strong>.</p><h4 id=engine--language>Engine & Language<a hidden class=anchor aria-hidden=true href=#engine--language>#</a></h4><p>These games run on the in-house Clausewitz engine (with newer games incorporating a shared layer called Jomini). Modding
is done almost entirely by editing or adding plain text files (<code>.txt</code>, <code>.yml</code>, sometimes <code>.lua</code> for specific scripting
tasks). These files use Paradox&rsquo;s unique scripting syntax to define everything from countries, characters, events,
decisions, technologies, graphics, and even AI weighting [3] [22]. It&rsquo;s a declarative, key-value based language
optimized for strategy game concepts. (See the DSL example snippet in the Languages section above).</p><h4 id=execution>Execution<a hidden class=anchor aria-hidden=true href=#execution>#</a></h4><p>The engine parses these script files at game startup. It doesn&rsquo;t interpret them line-by-line during gameplay. Instead,
it converts the logic (especially things like event triggers and AI weights) into an internal representation that can be
evaluated very quickly by the core C++ engine [8]. This is key to maintaining performance even with thousands of
potential events or complex AI calculations running in the background. The performance cost is front-loaded into the
initial game load time.</p><h4 id=no-arbitrary-code>No Arbitrary Code<a hidden class=anchor aria-hidden=true href=#no-arbitrary-code>#</a></h4><p>Crucially, mods cannot inject arbitrary compiled code (no DLLs). Modders are constrained to work within the vocabulary
and structure provided by the Paradox scripting DSL. If you want to do something the DSL doesn&rsquo;t support (like implement
a radically new UI paradigm or a fundamentally different economic model), you&rsquo;re generally out of luck unless Paradox
adds the necessary script commands in a future update.</p><h4 id=loading--lifecycle>Loading & Lifecycle<a hidden class=anchor aria-hidden=true href=#loading--lifecycle>#</a></h4><p>Mods are managed via the game&rsquo;s launcher, which reads <code>.mod</code> descriptor files. The launcher handles enabling mods and
setting load order. The game then merges data from all active mods at startup. During gameplay, mod logic is typically
triggered by the engine evaluating event conditions or AI decision factors based on the loaded scripts. Mods don&rsquo;t
usually run continuous code; they react to game state changes.</p><h4 id=security>Security<a hidden class=anchor aria-hidden=true href=#security>#</a></h4><p>Because mods are restricted to the DSL, they are inherently sandboxed from a system perspective. A Paradox mod can&rsquo;t
read your files or install malware. The worst it can do is mess up your game state (which can still be annoying!). This
design choice neatly sidesteps the security nightmare of compiled mods. (The <em>Cities: Skylines</em> malware incident
mentioned earlier involved a Paradox-published but not Paradox-developed game using the Unity engine with C# mods – a
completely different technical scenario).</p><h4 id=community--tools>Community & Tools<a hidden class=anchor aria-hidden=true href=#community--tools>#</a></h4><p>Paradox actively supports modding with official wikis documenting the script commands [15] and integrates mod
distribution via Paradox Mods and Steam Workshop [23]. The community has built extensive knowledge bases and tools (like
syntax highlighters and validation utilities) around the Clausewitz scripting language.</p><h4 id=why-this-approach>Why this approach?<a hidden class=anchor aria-hidden=true href=#why-this-approach>#</a></h4><p>It perfectly suits complex simulation games where performance and stability are paramount. It allows enormous content
and rule modifications within a controlled framework, fostering a huge modding scene focused on historical accuracy,
alternate history, or fantasy conversions. The limitations on arbitrary code are accepted as a reasonable trade-off for
stability and inherent safety. Forsslund&rsquo;s research showing their native script parsing outperformed embedded Lua likely
solidified their commitment to this DSL-centric approach [8].</p><h3 id=case-study-2-rimworld---xml-c-and-harmony-mayhem>Case Study 2: <em>RimWorld</em> - XML, C#, and Harmony Mayhem<a hidden class=anchor aria-hidden=true href=#case-study-2-rimworld---xml-c-and-harmony-mayhem>#</a></h3><p><em>RimWorld</em>, the sci-fi colony sim by Ludeon Studios, represents a different philosophy, embracing the power (and perils)
of compiled code within the popular Unity engine.</p><h4 id=engine--language-1>Engine & Language<a hidden class=anchor aria-hidden=true href=#engine--language-1>#</a></h4><p>Built on Unity, <em>RimWorld</em> uses C# for its core logic. Modding leverages this directly:</p><h5 id=xml-definitions>XML Definitions<a hidden class=anchor aria-hidden=true href=#xml-definitions>#</a></h5><p>A huge amount of game content (items, pawns, buildings, research projects, incidents, etc.) is defined in XML files.
This provides an accessible entry point for modders – adding a new rifle or alien race can often be done just by
creating new XML defs or patching existing ones [4] [24]. This is the data-driven part.</p><h5 id=c-assemblies>C# Assemblies<a hidden class=anchor aria-hidden=true href=#c-assemblies>#</a></h5><p>For anything more complex – new behaviors, UI changes, altered game mechanics – modders write code in C# and compile it
into .DLL assemblies. The game loads these DLLs at startup [4].</p><h4 id=the-api-and-lack-thereof>The &ldquo;API&rdquo; (and lack thereof)<a hidden class=anchor aria-hidden=true href=#the-api-and-lack-thereof>#</a></h4><p>While <em>RimWorld</em> exposes many of its C# classes and methods as public, it doesn&rsquo;t have a strictly defined, stable "
Modding API" in the traditional sense. Modders often need to decompile the game&rsquo;s assemblies (<code>Assembly-CSharp.dll</code>)
using tools like dnSpy or ILSpy to understand how the base game works and find the classes/methods they need to interact
with or modify [7]. Documentation is largely community-driven (like the RimWorld Wiki) [4].</p><h4 id=harmony-patching>Harmony Patching<a hidden class=anchor aria-hidden=true href=#harmony-patching>#</a></h4><p>This is the secret sauce (or Pandora&rsquo;s Box) of <em>RimWorld</em> modding. The game <em>includes</em> the Harmony library, which allows
mods to perform runtime IL patching of existing game methods (Prefix, Postfix, Transpiler) [12]. This means mods can
fundamentally alter almost <em>any</em> aspect of the game&rsquo;s behavior, even methods the developer never intended to be
moddable, without needing source code access. Want to change how colonists prioritize tasks? Patch the job assignment
methods. Want to add psychic space llamas? Patch the animal spawning logic. This provides incredible power and
flexibility.</p><p><em>Example Harmony Patch (Conceptual):</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> HarmonyLib;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Verse; <span style=color:#75715e>// RimWorld&#39;s core namespace</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[HarmonyPatch(typeof(Pawn_JobTracker), &#34;DetermineNextJob&#34;)]</span> <span style=color:#75715e>// Target the job finding method</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Patch_JobFinder</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Run *after* the original method finds a job</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Postfix(<span style=color:#66d9ef>ref</span> ThinkResult __result, Pawn ___pawn) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If the original method found a job, and our mod wants pawns to prioritize hauling...</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (__result.Job != <span style=color:#66d9ef>null</span> &amp;&amp; ___pawn.story?.traits?.HasTrait(MyModDefOf.ObsessiveHauler) == <span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...maybe try to find a hauling job instead, even if it&#39;s lower priority originally.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// (Actual logic would be more complex, finding hauling jobs etc.)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we find a better hauling job, replace __result.Job with it.</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=execution--performance>Execution & Performance<a hidden class=anchor aria-hidden=true href=#execution--performance>#</a></h4><p>C# mods run as JIT-compiled .NET code, offering good performance. However, heavy use of Harmony patching can introduce
overhead, as each patched method call might involve extra hops through prefix/postfix code. Poorly optimized mods,
especially those hooking into frequent updates, can definitely impact game speed.</p><h4 id=loading--lifecycle-1>Loading & Lifecycle<a hidden class=anchor aria-hidden=true href=#loading--lifecycle-1>#</a></h4><p>Mods are loaded from a Mods folder or Steam Workshop at startup. Load order is crucial and user-configurable. Mods with
code typically have a class inheriting from <code>Verse.Mod</code>; its constructor is called during initialization, often used to
apply Harmony patches or load settings. Runtime execution depends on what the mod does – event subscriptions (via
patching), Harmony patches triggering on specific method calls, or custom <code>Comp</code> (component) classes attached to game
objects that receive updates.</p><h4 id=security-1>Security<a hidden class=anchor aria-hidden=true href=#security-1>#</a></h4><p>There is <strong>no sandbox</strong>. RimWorld mods run with full .NET permissions within the game&rsquo;s process. A malicious mod could
theoretically do anything. The community relies entirely on trust, platform moderation (Steam Workshop), and the fact
that the developer (Tynan Sylvester) has fostered a generally positive and collaborative modding environment. Stability
is also a concern; conflicting Harmony patches or buggy mod code can cause errors or crashes, though RimWorld&rsquo;s error
handling often catches these and allows the game to continue (with a red error log).</p><h4 id=community--tools-1>Community & Tools<a hidden class=anchor aria-hidden=true href=#community--tools-1>#</a></h4><p>Despite the lack of a formal API, the community thrives, using decompilers, community wikis, shared libraries like
HugsLib (for common modding utilities), and tools to debug Harmony patch conflicts. The accessibility of XML combined
with the power of C#/Harmony has created one of the most vibrant modding scenes around.</p><h4 id=why-this-approach-1>Why this approach?<a hidden class=anchor aria-hidden=true href=#why-this-approach-1>#</a></h4><p>It maximizes modder freedom and creativity, leveraging the power of the Unity/C# environment. By including Harmony, the
developers essentially acknowledged that modders <em>would</em> find ways to patch the game anyway and provided a
standardized (if powerful) way to do it. The trade-off is a higher reliance on community knowledge, potential
instability from conflicts, and a complete lack of technical security enforcement.</p><h3 id=case-study-3-mount--blade-ii-bannerlord---official-modules-unofficial-risks>Case Study 3: <em>Mount & Blade II: Bannerlord</em> - Official Modules, Unofficial Risks<a hidden class=anchor aria-hidden=true href=#case-study-3-mount--blade-ii-bannerlord---official-modules-unofficial-risks>#</a></h3><p>TaleWorlds Entertainment&rsquo;s <em>Mount & Blade II: Bannerlord</em>, a medieval sandbox RPG/strategy game, was developed with
modding explicitly in mind, offering official tools and a structured system based on .NET.</p><h4 id=engine--language-2>Engine & Language<a hidden class=anchor aria-hidden=true href=#engine--language-2>#</a></h4><p><em>Bannerlord</em> uses a custom engine, but a significant portion of the game logic is written in C#. Modding follows suit,
primarily using C# compiled into DLLs, alongside XML for data definition [5] [25].</p><h4 id=module-system>Module System<a hidden class=anchor aria-hidden=true href=#module-system>#</a></h4><p>The game itself is structured into modules (Native, Sandbox, Storymode, etc.). Mods are simply additional modules. Each
module has a <code>SubModule.xml</code> descriptor file specifying its ID, version, dependencies, and crucially, the DLL to load
and the entry point class [5]. This provides a clear, structured way to organize and manage mods.</p><h4 id=official-api--tools>Official API & Tools<a hidden class=anchor aria-hidden=true href=#official-api--tools>#</a></h4><p>TaleWorlds provides official modding tools (including a scene editor) and relatively extensive API
documentation [26] [5]. Modders write C# code referencing the official <code>TaleWorlds.*.dll</code> assemblies. The API provides
base classes (like <code>MBSubModuleBase</code>) and event systems (<code>CampaignEvents</code>) for mods to hook into.</p><p><em>Example Bannerlord Behavior (Conceptual):</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> TaleWorlds.CampaignSystem;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TaleWorlds.Core;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TaleWorlds.MountAndBlade;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyBanditModSubModule</span> : MBSubModuleBase {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Called when the game starts a campaign</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnGameStart(Game game, IGameStarter gameStarterObject) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (game.GameType <span style=color:#66d9ef>is</span> Campaign) {
</span></span><span style=display:flex><span>            CampaignGameStarter campaignStarter = (CampaignGameStarter)gameStarterObject;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Add our custom behavior to the campaign</span>
</span></span><span style=display:flex><span>            campaignStarter.AddBehavior(<span style=color:#66d9ef>new</span> EnhancedBanditBehavior());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Our custom behavior logic</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EnhancedBanditBehavior</span> : CampaignBehaviorBase {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> RegisterEvents() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Subscribe to the hourly tick event</span>
</span></span><span style=display:flex><span>        CampaignEvents.HourlyTickEvent.AddNonSerializedListener(<span style=color:#66d9ef>this</span>, OnHourlyTick);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> SyncData(IDataStore dataStore) { <span style=color:#75715e>/* Handle save/load */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnHourlyTick() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Every hour, maybe make bandits smarter or more aggressive...</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Access game state via Campaign.Current, MobileParty.All, etc.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=execution--performance-1>Execution & Performance<a hidden class=anchor aria-hidden=true href=#execution--performance-1>#</a></h4><p>Mods are compiled C# DLLs loaded by the .NET runtime, running with excellent performance.</p><h4 id=loading--lifecycle-2>Loading & Lifecycle<a hidden class=anchor aria-hidden=true href=#loading--lifecycle-2>#</a></h4><p>The game launcher reads <code>SubModule.xml</code> files, resolves dependencies, and determines load order. Users can
enable/disable modules and adjust order in the launcher. The engine then loads the specified DLLs and calls methods on
the mod&rsquo;s <code>MBSubModuleBase</code> subclass at specific lifecycle points (<code>OnSubModuleLoad</code>, <code>OnGameStart</code>,
<code>OnApplicationTick</code>, etc.) [5]. Mods can then register for further events or add behaviors as needed.</p><h4 id=security-2>Security<a hidden class=anchor aria-hidden=true href=#security-2>#</a></h4><p>Like <em>RimWorld</em>, <em>Bannerlord</em> <strong>does not sandbox</strong> compiled mods. The DLLs run with full permissions. This has been a
point of discussion and concern within the community [21]. TaleWorlds relies on user caution and platform trust. The
official launcher explicitly warns about running unsigned code.</p><h4 id=stability>Stability<a hidden class=anchor aria-hidden=true href=#stability>#</a></h4><p>Compiled mods mean game updates can easily break compatibility. TaleWorlds has worked to improve API stability over
time, but modders often need to update their mods for new game versions. The structured module system and dependency
management help mitigate some conflicts compared to a free-for-all patching system. While Harmony <em>can</em> be used in
Bannerlord, many common modding tasks can be achieved via the official API hooks, potentially leading to fewer direct
method conflicts than in RimWorld.</p><h4 id=why-this-approach-2>Why this approach?<a hidden class=anchor aria-hidden=true href=#why-this-approach-2>#</a></h4><p>TaleWorlds aimed to provide powerful, official modding support from the start, recognizing the importance of mods to the
<em>Mount & Blade</em> franchise. They opted for compiled C# mods within a structured module system, providing official tools
and APIs. This enables deep modifications needed for total conversions (like popular <em>Game of Thrones</em> or <em>Warhammer</em>
mods) but sacrifices inherent security. It&rsquo;s a middle ground between Paradox&rsquo;s safe-but-limited DSL and RimWorld&rsquo;s
wild-west Harmony patching.</p><h3 id=case-study-4-minecraft-java-edition---community-forged-power>Case Study 4: <em>Minecraft</em> (Java Edition) - Community Forged Power<a hidden class=anchor aria-hidden=true href=#case-study-4-minecraft-java-edition---community-forged-power>#</a></h3><p><em>Minecraft</em> is a fascinating case because its massive modding scene emerged largely <em>without</em> official support in the
early days, forcing the community to build the infrastructure themselves.</p><h4 id=engine--language-3>Engine & Language<a hidden class=anchor aria-hidden=true href=#engine--language-3>#</a></h4><p><em>Minecraft: Java Edition</em> is, unsurprisingly, written in Java. Modding involves writing Java code compiled into <code>.jar</code>
files.</p><h4 id=community-loaders-forge--fabric>Community Loaders (Forge & Fabric)<a hidden class=anchor aria-hidden=true href=#community-loaders-forge--fabric>#</a></h4><p>Since Mojang didn&rsquo;t provide a modding API for years, the community stepped in. <strong>Minecraft Forge</strong> became the dominant
mod loader. Forge works by patching the vanilla Minecraft Java bytecode at runtime to insert hooks, an event bus, and a
mod loading system. <strong>Fabric</strong> is a newer, more lightweight alternative that uses the <strong>Mixin</strong> library to apply
bytecode modifications more surgically. Both essentially create a moddable version of the game engine on the fly.</p><h4 id=the-api>The &ldquo;API&rdquo;<a hidden class=anchor aria-hidden=true href=#the-api>#</a></h4><p>Forge and Fabric provide APIs that modders code against. These APIs offer abstractions over the (often obfuscated)
internal Minecraft code, providing access to game objects, events, and registration systems. Modders typically need
mappings (provided by the community) to deobfuscate Minecraft&rsquo;s code during development.</p><p><em>Example Forge Mod Structure (Conceptual):</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> net.minecraftforge.fml.common.Mod;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> net.minecraftforge.fml.common.event.FMLInitializationEvent;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> net.minecraftforge.common.MinecraftForge;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> net.minecraft.item.Item;
</span></span><span style=display:flex><span><span style=color:#75715e>// ... other imports</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Mod</span>(modid <span style=color:#f92672>=</span> MyMod.<span style=color:#a6e22e>MODID</span>, name <span style=color:#f92672>=</span> MyMod.<span style=color:#a6e22e>NAME</span>, version <span style=color:#f92672>=</span> MyMod.<span style=color:#a6e22e>VERSION</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyMod</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String MODID <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;mymod&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;My Awesome Mod&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String VERSION <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1.0&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reference to the mod instance</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Mod.Instance</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> MyMod instance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Example Item instance</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Item myAwesomeItem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Mod.EventHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>preInit</span>(FMLPreInitializationEvent event) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Phase to register blocks, items, entities, etc.</span>
</span></span><span style=display:flex><span>        myAwesomeItem <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyItem(); <span style=color:#75715e>// Assume MyItem extends Item</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ForgeRegistries.ITEMS.register(...); // Actual registration logic</span>
</span></span><span style=display:flex><span>        Log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;My Mod PreInitialization complete.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Mod.EventHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>(FMLInitializationEvent event) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Phase to register recipes, event handlers, etc.</span>
</span></span><span style=display:flex><span>        MinecraftForge.<span style=color:#a6e22e>EVENT_BUS</span>.<span style=color:#a6e22e>register</span>(<span style=color:#66d9ef>new</span> MyEventHandler());
</span></span><span style=display:flex><span>        Log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;My Mod Initialization complete.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... potentially other event handlers (PostInit, ServerStarting, etc.)</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=execution--performance-2>Execution & Performance<a hidden class=anchor aria-hidden=true href=#execution--performance-2>#</a></h4><p>Mods are compiled Java bytecode running within the same Java Virtual Machine (JVM) as the game. Performance is generally
very good thanks to the JVM&rsquo;s JIT compiler, though large modpacks can strain CPU and memory resources due to the sheer
amount of added content and logic.</p><h4 id=loading--lifecycle-3>Loading & Lifecycle<a hidden class=anchor aria-hidden=true href=#loading--lifecycle-3>#</a></h4><p>Forge/Fabric scan a <code>mods</code> folder for JAR files. They handle dependencies and load order. They provide a structured
lifecycle with distinct phases (preInit, init, postInit) ensuring mods initialize in a coordinated manner [14]. Forge
even parallelized parts of this to speed up loading [14]. Mods typically interact with the game via event subscriptions
on the Forge/Fabric event bus or by registering their custom blocks/items/entities which then get handled by the
modified game loop.</p><h4 id=security-3>Security<a hidden class=anchor aria-hidden=true href=#security-3>#</a></h4><p>Zero technical sandboxing. Java mods run with full permissions within the JVM. The Java Security Manager <em>could</em> have
potentially been used, but wasn&rsquo;t, and is now deprecated anyway. The community relies heavily on downloading from
trusted sources (CurseForge, Modrinth) and community vigilance. However, as noted earlier, malware incidents <em>have</em>
occurred, highlighting the risks of this open, community-driven ecosystem [19]. The Log4Shell vulnerability also
impacted Minecraft and potentially mods using the vulnerable library.</p><h4 id=stability--compatibility>Stability & Compatibility<a hidden class=anchor aria-hidden=true href=#stability--compatibility>#</a></h4><p>Game updates frequently break mods, as Mojang doesn&rsquo;t maintain a stable API for the community loaders. Mod authors often
have to scramble to update their mods for new Minecraft versions. Compatibility between mods within large modpacks can
also be a significant challenge, requiring careful configuration and sometimes community-made compatibility patches.</p><h4 id=why-this-approach-3>Why this approach?<a hidden class=anchor aria-hidden=true href=#why-this-approach-3>#</a></h4><p>It wasn&rsquo;t really a deliberate <em>design</em> by Mojang, but rather an <em>emergent phenomenon</em>. The community desperately wanted
deep modding capabilities and built the tools to make it happen by reverse-engineering and patching the game. This
resulted in unparalleled creative freedom but also significant challenges in maintenance, stability, and security.
Mojang eventually provided obfuscation mappings to help the community, but largely left the Java modding scene to its
own devices while focusing on the safer, more limited Add-On system for Bedrock Edition.</p><p>These case studies showcase the spectrum: Paradox&rsquo;s controlled DSL garden; RimWorld&rsquo;s hybrid XML/C# approach amplified
by Harmony; Bannerlord&rsquo;s official but unsandboxed C# module system; and Minecraft&rsquo;s community-built Java powerhouse.
Each reflects different priorities and results in a distinct modding culture.</p><p>So, where does modding tech go from here?</p><h2 id=looking-ahead-the-future-of-modding-tech>Looking Ahead: The Future of Modding Tech<a hidden class=anchor aria-hidden=true href=#looking-ahead-the-future-of-modding-tech>#</a></h2><p>The world of game modding technology isn&rsquo;t static. Developers, engine creators, and researchers are constantly exploring
ways to make modding safer, more powerful, and easier for both creators and players. Here are some promising directions
and research ideas, drawing inspiration from the challenges and successes we&rsquo;ve seen:</p><h3 id=safer-performant-sandboxing-the-wasm-hope-and-others>Safer, Performant Sandboxing: The WASM Hope (and others)<a hidden class=anchor aria-hidden=true href=#safer-performant-sandboxing-the-wasm-hope-and-others>#</a></h3><p>The holy grail is achieving the security of interpreted scripts with the performance of compiled code. <strong>WebAssembly (
WASM)</strong> keeps coming up as a potential solution.</p><h4 id=the-idea>The Idea<a hidden class=anchor aria-hidden=true href=#the-idea>#</a></h4><p>Games could define their modding API. Modders could write mods in various languages (C++, Rust, C#, Swift,
AssemblyScript) that compile to WASM modules. The game engine would then embed a WASM runtime (like Wasmer, Wasmtime, or
even browser engines) to execute these modules.</p><h4 id=why-its-promising>Why it&rsquo;s Promising<a hidden class=anchor aria-hidden=true href=#why-its-promising>#</a></h4><h5 id=security-4>Security<a hidden class=anchor aria-hidden=true href=#security-4>#</a></h5><p>WASM runs in a sandbox by default. It has no access to the host system (files, network, etc.) <em>unless</em> the host (the
game engine) explicitly provides functions (imports) to allow it. The engine could expose only the necessary game API
functions, creating a tightly controlled environment. Memory safety is also a core design principle.</p><h5 id=performance-3>Performance<a hidden class=anchor aria-hidden=true href=#performance-3>#</a></h5><p>WASM is designed for near-native performance, often using JIT compilation. While there&rsquo;s still a cost to calling between
the host and WASM, it&rsquo;s potentially much lower than traditional scripting VMs for complex computations <em>within</em> the mod.</p><h5 id=language-agnostic>Language Agnostic<a hidden class=anchor aria-hidden=true href=#language-agnostic>#</a></h5><p>Modders could potentially use their preferred language, broadening the pool of potential creators.</p><h4 id=challenges>Challenges<a hidden class=anchor aria-hidden=true href=#challenges>#</a></h4><p>Designing a robust, ergonomic, and performant API bridge between the game engine and WASM modules is non-trivial.
Debugging WASM code can be more complex. Tooling and engine integration are still evolving.</p><h4 id=status>Status<a hidden class=anchor aria-hidden=true href=#status>#</a></h4><p>While WASM is used for scripting in some contexts (e.g., some cloud platforms, even experimental game engine plugins),
widespread adoption for <em>user game modding</em> is still largely a research/future direction.</p><p>Other sandboxing avenues include improving OS-level containerization for games or exploring new language-level security
features in managed runtimes (though progress here seems slow for in-process scenarios).</p><h3 id=smarter-verification-static-analysis-and-capabilities>Smarter Verification: Static Analysis and Capabilities<a hidden class=anchor aria-hidden=true href=#smarter-verification-static-analysis-and-capabilities>#</a></h3><p>Beyond runtime sandboxing, we can try to verify mods <em>before</em> they run.</p><h4 id=advanced-static-analysis>Advanced Static Analysis<a hidden class=anchor aria-hidden=true href=#advanced-static-analysis>#</a></h4><p>Tools like Unbreakable (for .NET) [12] demonstrate the concept of scanning code for calls to disallowed APIs. Future
tools could use more sophisticated techniques (symbolic execution, abstract interpretation) to check for more complex
properties, like potential infinite loops, excessive resource usage, or violations of specific game rules, without
actually running the code.</p><h4 id=capability-based-security>Capability-Based Security<a hidden class=anchor aria-hidden=true href=#capability-based-security>#</a></h4><p>Instead of just blacklisting bad things, analyze what <em>capabilities</em> a mod requires (e.g., &ldquo;needs file access to save
settings,&rdquo; &ldquo;needs network access to check for updates&rdquo;). This information could be displayed to the user upon
installation (&ldquo;This mod wants to access your network. Allow?&rdquo;), similar to mobile app permissions. Mod platforms could
enforce policies based on declared capabilities.</p><h3 id=standardization-and-engine-level-support>Standardization and Engine-Level Support<a hidden class=anchor aria-hidden=true href=#standardization-and-engine-level-support>#</a></h3><p>Could modding become a standard feature provided by major game engines like Unity and Unreal, rather than something each
developer has to implement from scratch?</p><h4 id=engine-modding-middleware>Engine Modding Middleware<a hidden class=anchor aria-hidden=true href=#engine-modding-middleware>#</a></h4><p>Imagine if Unity or Unreal offered a built-in, configurable modding framework – perhaps a secure scripting runtime (
maybe WASM-based?), a standard mod packaging format, and APIs for loading/managing mods. This could drastically lower
the barrier for developers to add mod support. Projects like <code>mod.io</code> are trying to provide cross-engine solutions for
mod distribution and management [16], but deeper engine integration could go further.</p><h4 id=standardized-apis>Standardized APIs?<a hidden class=anchor aria-hidden=true href=#standardized-apis>#</a></h4><p>Probably a long shot given the diversity of games, but perhaps standards could emerge for common modding tasks (e.g.,
asset loading, event handling), making it easier for modders to transfer skills between games using the same engine.</p><h3 id=better-mod-development-experiences>Better Mod Development Experiences<a hidden class=anchor aria-hidden=true href=#better-mod-development-experiences>#</a></h3><p>Making modding easier and more interactive could unlock even more creativity.</p><h4 id=in-game-modding-tools>In-Game Modding Tools<a hidden class=anchor aria-hidden=true href=#in-game-modding-tools>#</a></h4><p>Some games are blurring the lines between playing and creating (<em>Roblox</em>, <em>Dreams</em>, <em>Core</em>). Could traditional games
offer better in-game tools for modding? Imagine live scripting environments where you can tweak mod code and see the
results instantly without restarting the game. Hot-reloading for scripts or even compiled code (which some engines
support during development) could be exposed to modders.</p><h4 id=ai-assisted-modding>AI-Assisted Modding<a hidden class=anchor aria-hidden=true href=#ai-assisted-modding>#</a></h4><p>AI code generation tools (like GitHub Copilot) can already help modders write boilerplate code. Future AI could
potentially help with debugging, optimizing mod performance, generating assets, or even suggesting ways to ensure
compatibility with other mods.</p><h3 id=taming-complexity-modularity-and-inter-mod-communication>Taming Complexity: Modularity and Inter-Mod Communication<a hidden class=anchor aria-hidden=true href=#taming-complexity-modularity-and-inter-mod-communication>#</a></h3><p>As mod lists grow, managing interactions becomes key.</p><h4 id=designing-for-modularity>Designing for Modularity<a hidden class=anchor aria-hidden=true href=#designing-for-modularity>#</a></h4><p>Encourage mods to be small, focused, and expose clear APIs for other mods to use. This requires developers to provide
mechanisms for mods to discover and interact with each other safely.</p><h4 id=cross-mod-event-buses>Cross-Mod Event Buses<a hidden class=anchor aria-hidden=true href=#cross-mod-event-buses>#</a></h4><p>Expand the game&rsquo;s event system to allow mods to publish and subscribe to <em>custom</em> events, enabling decoupled
communication. Mod A could broadcast &ldquo;NewResourceAdded&rdquo; and Mod B could listen for it, without either needing direct
knowledge of the other.</p><h4 id=conflict-resolution-tools>Conflict Resolution Tools<a hidden class=anchor aria-hidden=true href=#conflict-resolution-tools>#</a></h4><p>Better tools (perhaps integrated into game launchers or mod managers) to automatically detect potential conflicts (e.g.,
two mods patching the same method, overriding the same data entry) and suggest solutions or load order adjustments.</p><h3 id=enhanced-security-via-platforms-and-process>Enhanced Security via Platforms and Process<a hidden class=anchor aria-hidden=true href=#enhanced-security-via-platforms-and-process>#</a></h3><p>Leveraging the distribution platform for better security.</p><h4 id=cloud-based-verification>Cloud-Based Verification<a hidden class=anchor aria-hidden=true href=#cloud-based-verification>#</a></h4><p>Mod platforms (Steam Workshop, Nexus Mods, Paradox Mods) could implement automated cloud-based sandboxing and analysis.
Before a mod is publicly listed, it could be run in a secure environment to monitor its behavior (file access, network
calls, crashes). This is akin to how mobile app stores vet submissions.</p><h4 id=clearer-labeling>Clearer Labeling<a hidden class=anchor aria-hidden=true href=#clearer-labeling>#</a></h4><p>Platforms could require mods to declare their capabilities and display clear security warnings (e.g., &ldquo;This mod uses
compiled code and runs with full permissions,&rdquo; &ldquo;This mod only uses sandboxed scripts&rdquo;).</p><h3 id=tiered-modding-support>Tiered Modding Support<a hidden class=anchor aria-hidden=true href=#tiered-modding-support>#</a></h3><p>Recognizing that not all mods need the same level of power or risk, developers could offer tiered support:</p><h4 id=tier-1-dataconfig>Tier 1 (Data/Config)<a hidden class=anchor aria-hidden=true href=#tier-1-dataconfig>#</a></h4><p>Safest level. Mods can only modify data files (XML, JSON) or use a very limited, declarative DSL. Suitable for content
additions, balance tweaks. Could potentially be allowed even in multiplayer or on consoles.</p><h4 id=tier-2-sandboxed-scripting>Tier 2 (Sandboxed Scripting)<a hidden class=anchor aria-hidden=true href=#tier-2-sandboxed-scripting>#</a></h4><p>Mods use an embedded scripting language (Lua, WASM) running within a strict sandbox, using only approved APIs. Allows
more complex logic but contained.</p><h4 id=tier-3-compiled-code>Tier 3 (Compiled Code)<a hidden class=anchor aria-hidden=true href=#tier-3-compiled-code>#</a></h4><p>Full power, full risk. Mods are compiled DLLs/JARs running unsandboxed. Requires explicit user consent and warnings.
Reserved for total conversions and deep system changes where performance is paramount.</p><p>This allows players and developers to choose the level of risk/reward they are comfortable with.</p><p>The future of modding tech likely involves combining several of these ideas – perhaps WASM for safe-but-performant code
execution, coupled with better platform-level verification and clearer user communication about the risks involved with
different types of mods.</p><h2 id=wrapping-up-the-takeaway>Wrapping Up: The Takeaway<a hidden class=anchor aria-hidden=true href=#wrapping-up-the-takeaway>#</a></h2><p>Whew, that was a deep dive! Supporting user-created mods is clearly far more complex than just throwing a <code>Mods</code> folder
into the game directory. It involves fundamental choices about software architecture, language design, execution
environments, and security posture.</p><p>We&rsquo;ve seen a spectrum of approaches:</p><ul><li>Paradox&rsquo;s controlled, performant, safe <strong>DSL-driven</strong> world.</li><li>RimWorld&rsquo;s open, flexible, slightly chaotic <strong>XML + C# + Harmony</strong> ecosystem.</li><li>Bannerlord&rsquo;s attempt at a structured, official <strong>C# module system</strong> (still lacking a sandbox).</li><li>Minecraft&rsquo;s <strong>community-built Java framework</strong> rising from a lack of official support.</li></ul><p>Each approach reflects different priorities and trade-offs between <strong>modder flexibility, runtime performance,
development ease, and security/stability</strong>. There&rsquo;s no single &ldquo;right&rdquo; answer; the best approach depends heavily on the
type of game, the engine technology, the performance budget, and the kind of modding community the developers want to
foster. Forsslund&rsquo;s work highlighted the stark performance cost of embedding Lua vs. native parsing in EU3 [8],
underscoring why performance-sensitive games might favor DSLs or compiled code, while games prioritizing creativity
might accept the overhead of scripts or the risks of DLLs.</p><p>Designing for moddability means designing a game as a <strong>platform</strong>. It requires extra effort in architecting for
extensibility, maintaining API stability, and providing documentation or tools. But the payoff – immense player
engagement, extended game lifespan, unexpected innovation – is often well worth the investment.</p><p>The biggest unresolved challenge remains <strong>security</strong>, especially for compiled mods. The current reliance on community
trust and platform vetting feels increasingly inadequate in the face of potential threats [21] [11]. Moving towards more
technically robust solutions like WASM-based execution, better static analysis, and clearer capability management seems
essential for the long-term health and safety of modding ecosystems.</p><p>Ultimately, the technologies supporting game mods are constantly evolving. It&rsquo;s an exciting space where the creativity
of players pushes the boundaries, and developers respond with new tools and frameworks. By understanding the technical
underpinnings, we can better appreciate the delicate balancing act developers perform and anticipate how modding might
become even more powerful, accessible, and secure in the future.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>[1] W. Scacchi, ‘Modding as a basis for developing game systems’, in Proceedings of the 1st International Workshop on
Games and Software Engineering, Waikiki, Honolulu HI USA: ACM, May 2011, pp. 5–8. doi: 10.1145/1984674.1984677.</li><li>[2] ‘A Comprehensive Introduction to Unreal Engine Modding’. Sep. 25, 2024. [Online].
Available: <a href=https://buckminsterfullerene02.github.io/dev-guide/>https://buckminsterfullerene02.github.io/dev-guide/</a></li><li>[3] ‘Modding’, CK3 Wiki. [Online]. Available: <a href=https://ck3.paradoxwikis.com/Modding>https://ck3.paradoxwikis.com/Modding</a></li><li>[4] ‘Modding Tutorials’, RimWorld Wiki. [Online]. Available: <a href=https://rimworldwiki.com/wiki/Modding_Tutorials>https://rimworldwiki.com/wiki/Modding_Tutorials</a></li><li>[5] ‘Bannerlord Documentation’. [Online]. Available: <a href=https://docs.bannerlordmodding.com>https://docs.bannerlordmodding.com</a></li><li>[6] ‘Tutorial:Scripting’, Factorio Wiki. [Online]. Available: <a href=https://wiki.factorio.com/Tutorial:Scripting>https://wiki.factorio.com/Tutorial:Scripting</a></li><li>[7] ‘A question about the modding API, the relationship between, C# and Xml thru .dll’, Ludeon Forums. [Online].
Available: <a href="https://ludeon.com/forums/index.php?topic=29176.0">https://ludeon.com/forums/index.php?topic=29176.0</a></li><li>[8] O. Forsslund, ‘Evaluating Lua for Usein Computer Game Event Handling’, Master of Science Thesis, KTH Royal
Institute of Technology, Stockholm, Sweden, 2013. [Online].
Available: <a href=https://www.diva-portal.org/smash/get/diva2:678986/FULLTEXT01.pdf>https://www.diva-portal.org/smash/get/diva2:678986/FULLTEXT01.pdf</a></li><li>[9] D. Perelman, ‘A newbie’s introduction to Factorio modding’, A Weird Imagination. [Online].
Available: <a href=https://aweirdimagination.net/2024/06/23/a-newbies-introduction-to-factorio-modding/>https://aweirdimagination.net/2024/06/23/a-newbies-introduction-to-factorio-modding/</a></li><li>[10] ‘Modding API’, Cities: Skylines Wiki. [Online]. Available: <a href=https://skylines.paradoxwikis.com/Modding_API>https://skylines.paradoxwikis.com/Modding_API</a></li><li>[11] J. Vijayan, ‘Malicious Game Mods Target Dota 2 Game Users’, Dark Reading. [Online].
Available: <a href=https://www.darkreading.com/cloud-security/malicious-game-mods-target-dota-2-game-users>https://www.darkreading.com/cloud-security/malicious-game-mods-target-dota-2-game-users</a></li><li>[12] ‘Running untrusted code (video game modding)’, GitHub dotnet/roslyn Discussion. [Online].
Available: <a href=https://github.com/dotnet/roslyn/discussions/48726>https://github.com/dotnet/roslyn/discussions/48726</a></li><li>[13] ‘Modding’, Europa Universalis 4 Wiki. [Online]. Available: <a href=https://eu4.paradoxwikis.com/Modding>https://eu4.paradoxwikis.com/Modding</a></li><li>[14] ‘Stages of Modloading’, Forge Community Wiki. [Online].
Available: <a href=https://forge.gemwire.uk/wiki/Stages_of_Modloading>https://forge.gemwire.uk/wiki/Stages_of_Modloading</a></li><li>[15] ‘Scripting’, Crusader Kings II Wiki. [Online]. Available: <a href=https://ck2.paradoxwikis.com/Scripting>https://ck2.paradoxwikis.com/Scripting</a></li><li>[16] S. Reismanis, ‘Add mod support to a Unity game in 48 hours with mod.io’, Medium. [Online].
Available: <a href=https://blog.mod.io/add-mod-support-to-a-unity-game-in-48-hours-with-mod-io-412a4346731>https://blog.mod.io/add-mod-support-to-a-unity-game-in-48-hours-with-mod-io-412a4346731</a></li><li>[17] ‘Sandbox games and mods for security’, Steam Forums. [Online].
Available: <a href=https://steamcommunity.com/discussions/forum/10/4625853880055444527/>https://steamcommunity.com/discussions/forum/10/4625853880055444527/</a></li><li>[18] ‘Additional information regarding malware suspicion on the Mod “Traffic” on Cities: Skylines II.’, Paradox
Interactive Forums. [Online].
Available: <a href=https://forum.paradoxplaza.com/forum/threads/additional-information-regarding-malware-suspicion-on-the-mod-traffic-on-cities-skylines-ii.1713439/>https://forum.paradoxplaza.com/forum/threads/additional-information-regarding-malware-suspicion-on-the-mod-traffic-on-cities-skylines-ii.1713439/</a></li><li>[19] M. Szabó, ‘How Minecraft and game modding can undermine your security’, ESET Blog. [Online].
Available: <a href=https://www.eset.com/blog/consumer/how-minecraft-and-game-modding-can-undermine-your-security/>https://www.eset.com/blog/consumer/how-minecraft-and-game-modding-can-undermine-your-security/</a></li><li>[20] V. Constantinescu, ‘Minecraft Mods Hit by Massive “BleedingPipe” Vulnerability, Leaving Thousands at Risk’,
Bitdefender. [Online].
Available: <a href=https://www.bitdefender.com/en-gb/blog/hotforsecurity/minecraft-mods-hit-by-massive-bleedingpipe-vulnerability-leaving-thousands-at-risk>https://www.bitdefender.com/en-gb/blog/hotforsecurity/minecraft-mods-hit-by-massive-bleedingpipe-vulnerability-leaving-thousands-at-risk</a></li><li>[21] ‘Concerning about security vulnerability of bannerlord modding’, TaleWorlds Forums. [Online].
Available: <a href=https://forums.taleworlds.com/index.php?threads/concerning-about-security-vulnerability-of-bannerlord-modding.464024/>https://forums.taleworlds.com/index.php?threads/concerning-about-security-vulnerability-of-bannerlord-modding.464024/</a></li><li>[22] ‘Modding’, Stellaris Wiki. [Online]. Available: <a href=https://stellaris.paradoxwikis.com/Modding>https://stellaris.paradoxwikis.com/Modding</a></li><li>[23] ‘Paradox Mods’. [Online]. Available: <a href=https://mods.paradoxplaza.com>https://mods.paradoxplaza.com</a></li><li>[24] ‘User:Dninemfive’, RimWorld Wiki. [Online]. Available: <a href=https://rimworldwiki.com/wiki/User:Dninemfive>https://rimworldwiki.com/wiki/User:Dninemfive</a></li><li>[25] ‘Taleworlds Documentation’. [Online]. Available: <a href=https://moddocs.bannerlord.com/>https://moddocs.bannerlord.com/</a></li><li>[26] ‘Official Modding Documentation’, TaleWorlds Forums. [Online].
Available: <a href=https://forums.taleworlds.com/index.php?threads/official-modding-documentation.431644/>https://forums.taleworlds.com/index.php?threads/official-modding-documentation.431644/</a></li><li>[27] A. Buckwell, ‘Video Game Modding: What It Is and How to Get Started’, Acer Corner. [Online].
Available: <a href=https://blog.acer.com/en/discussion/574/video-game-modding-what-it-is-and-how-to-get-started>https://blog.acer.com/en/discussion/574/video-game-modding-what-it-is-and-how-to-get-started</a></li><li>[28] A. Beskazalioglu, ‘Compiled and Interpreted Programming Languages: Advantages, Disadvantages, and Language
Selection Guide for Projects’, Medium. [Online].
Available: <a href=https://medium.com/@ahmetbeskazalioglu/compiled-and-interpreted-programming-languages-advantages-disadvantages-and-language-selection-b260ff8d2a50>https://medium.com/@ahmetbeskazalioglu/compiled-and-interpreted-programming-languages-advantages-disadvantages-and-language-selection-b260ff8d2a50</a></li><li>[29] A. Amador, ‘Gaming Engines: An Undetected Playground for Malware Loaders’, Check Point Research, Nov.
2024. [Online].
Available: <a href=https://research.checkpoint.com/2024/gaming-engines-an-undetected-playground-for-malware-loaders/>https://research.checkpoint.com/2024/gaming-engines-an-undetected-playground-for-malware-loaders/</a></li><li>[30] B. Francis, ‘The Risks of Video Game Mods: An Easy Way for Malware to Spread’, Dynacomp IT Solutions. [Online].
Available: <a href=https://www.dynacompusa.com/post/the-risks-of-video-game-mods-an-easy-way-for-malware-to-spread>https://www.dynacompusa.com/post/the-risks-of-video-game-mods-an-easy-way-for-malware-to-spread</a></li><li>[31] E. Leblond, ‘Godot sandbox & modding support’, GitHub godotengine/godot Issues. [Online].
Available: <a href=https://github.com/godotengine/godot/issues/7753>https://github.com/godotengine/godot/issues/7753</a></li><li>[32] D. J. Torrey, ‘Building a mod system for a game’, Medium. [Online].
Available: <a href=https://medium.com/@davidjamestorreysr/building-a-mod-system-for-a-game-fd566b00759b>https://medium.com/@davidjamestorreysr/building-a-mod-system-for-a-game-fd566b00759b</a></li><li>[33] A. Ivora, ‘Securing the mod system of BeamNG.drive’, Master’s Thesis, Masaryk University, Brno, Czech,
2023. [Online]. Available: <a href="https://is.muni.cz/th/x5p5j/?lang=en">https://is.muni.cz/th/x5p5j/?lang=en</a></li><li>[34] ‘Is interpreted malware easier to detect than compiled malware?’, Information Security Stack Exchange. [Online].
Available: <a href=https://security.stackexchange.com/q/33990>https://security.stackexchange.com/q/33990</a></li><li>[35] ‘Gaming Mods Security Risks’, Information Security Stack Exchange. [Online].
Available: <a href=https://security.stackexchange.com/a/81230>https://security.stackexchange.com/a/81230</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/game-modding/>Game-Modding</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/single-player-games/>Single-Player-Games</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/pc-gaming/>Pc-Gaming</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/modding-frameworks/>Modding-Frameworks</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/scripting-languages/>Scripting-Languages</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/domain-specific-languages/>Domain-Specific-Languages</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/lua/>Lua</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/python/>Python</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/c-sharp/>C-Sharp</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/interpreted-scripts/>Interpreted-Scripts</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/compiled-mods/>Compiled-Mods</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/mod-apis/>Mod-Apis</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/sandboxing/>Sandboxing</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/security/>Security</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-architecture/>Game-Architecture</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/extensibility/>Extensibility</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/mod-lifecycle/>Mod-Lifecycle</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/event-handling/>Event-Handling</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/paradox-games/>Paradox-Games</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/rimworld/>Rimworld</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/mount-and-blade-bannerlord/>Mount-and-Blade-Bannerlord</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/minecraft/>Minecraft</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/software-engineering/>Software-Engineering</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/user-created-content/>User-Created-Content</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/performance-trade-offs/>Performance-Trade-Offs</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/modding-technology/>Modding-Technology</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-development/>Game-Development</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/scripting-vs-compiled/>Scripting-vs-Compiled</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/mod-security/>Mod-Security</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/embedded-languages/>Embedded-Languages</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/dsl-design/>Dsl-Design</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/game-extensibility/>Game-Extensibility</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/sandbox-strategies/>Sandbox-Strategies</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/case-studies/>Case-Studies</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/future-research/>Future-Research</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/modding-tools/>Modding-Tools</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/api-design/>Api-Design</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/community-mods/>Community-Mods</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/gaming-platforms/>Gaming-Platforms</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/code-execution/>Code-Execution</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/building-new-worlds-a-deep-dive-into-procedural-generation-for-video-games/><span class=title>« Prev</span><br><span>Building New Worlds: A Deep Dive into Procedural Generation for Video Games</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>