<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Uol 2025 Wk2 Solutions | Tategoto Azarasi</title>
<meta name=keywords content="recount-problem-solution,set-card-game-solver,planting-trees-problem-solution,competitive-programming,c-plus-plus,algorithm-tutorial,data-structures-and-algorithms,bilingual-guide,greedy-algorithm,brute-force-search,hash-map-example,vote-counting-algorithm,combinatorial-game-programming,scheduling-optimization,time-complexity-analysis,space-complexity,exchange-argument-proof,coding-challenges,problem-solving-guide,chinese-english-programming-tutorial,c-plus-plus-code-explanation"><meta name=description content="Recount
Problem
The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high
school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise
real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the
polls have closed and a winner has yet to emerge!"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Uol 2025 Wk2 Solutions"><meta property="og:description" content="Recount Problem The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the polls have closed and a winner has yet to emerge!"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-01T21:47:12+01:00"><meta property="article:modified_time" content="2025-10-01T21:47:12+01:00"><meta property="article:tag" content="Recount-Problem-Solution"><meta property="article:tag" content="Set-Card-Game-Solver"><meta property="article:tag" content="Planting-Trees-Problem-Solution"><meta property="article:tag" content="Competitive-Programming"><meta property="article:tag" content="C-Plus-Plus"><meta property="article:tag" content="Algorithm-Tutorial"><meta name=twitter:card content="summary"><meta name=twitter:title content="Uol 2025 Wk2 Solutions"><meta name=twitter:description content="Recount
Problem
The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high
school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise
real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the
polls have closed and a winner has yet to emerge!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Uol 2025 Wk2 Solutions","item":"https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Uol 2025 Wk2 Solutions","name":"Uol 2025 Wk2 Solutions","description":"Recount Problem The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the polls have closed and a winner has yet to emerge!\n","keywords":["recount-problem-solution","set-card-game-solver","planting-trees-problem-solution","competitive-programming","c-plus-plus","algorithm-tutorial","data-structures-and-algorithms","bilingual-guide","greedy-algorithm","brute-force-search","hash-map-example","vote-counting-algorithm","combinatorial-game-programming","scheduling-optimization","time-complexity-analysis","space-complexity","exchange-argument-proof","coding-challenges","problem-solving-guide","chinese-english-programming-tutorial","c-plus-plus-code-explanation"],"articleBody":"Recount Problem The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the polls have closed and a winner has yet to emerge!\nIn their desperation, the election officials turn to you and ask you to write a program to count the vote!\nInput The input consists of a single test case, which is a list of votes cast. Each line in the input contains the name of a candidate for whom a vote was cast. A name may consist of multiple words, separated by spaces. Words contain letters or hyphens, but no other punctuation characters. There will be at least 2 votes on the list. The list of votes ends with a single line containing the characters ***. This line should not be counted. There can be up to 100 000 valid votes.\nOutput If a candidate obtained a simple or absolute majority of all votes cast (that is, more than any other candidate), output the name of this candidate! If no candidate obtained a simple majority, output: “Runoff!” (don’t forget to include the exclamation mark!)\nCode ##include ##include ##include ##include // using namespace std; // For brevity in a single file solution namespace recount { int main(istream \u0026cin, ostream \u0026cout) { // Use an unordered_map to store vote counts for each candidate. // The key is the candidate's name (string), and the value is their vote count (unsigned long). std::unordered_map\u003cstd::string, unsigned long\u003e m = std::unordered_map\u003cstd::string, unsigned long\u003e(); std::string line; // Read votes line by line until the sentinel value \"***\" is encountered. while(std::getline(cin, line)) { if(line == \"***\") { break; } // Increment the vote count for the candidate named in the current line. // If the candidate is not yet in the map, they are added with a count of 1. m[line]++; } // Initialize a string to hold the winner's name and a variable for the maximum vote count. std::string ans = \"***\"; // Sentinel value to check for ties. unsigned long max_vote = 0; // First pass: find the highest vote count among all candidates. for(const auto \u0026[k, v]: m) { max_vote = std::max(max_vote, v); } // Second pass: find the candidate(s) who achieved the maximum vote count. for(const auto \u0026[k, v]: m) { if(v == max_vote) { // If 'ans' is no longer the sentinel value, it means we have already found // one winner. Finding another one means there is a tie. if(ans != \"***\") { cout \u003c\u003c \"Runoff!\"; return 0; // Exit after printing the result for a tie. } // This is the first candidate found with the maximum vote count. ans = k; } } // If the loop completes and 'ans' has been updated exactly once, print the winner's name. cout \u003c\u003c ans; return 0; } } Solution This problem asks us to process a list of votes, where each vote is a string representing a candidate’s name. We need to find the candidate with the most votes. If there is a single candidate with the highest vote count, we print their name. If two or more candidates are tied for the highest count, we must declare a “Runoff!”. The list of votes is terminated by a special string, ***.\nTo solve this, we need an efficient way to store and count votes for potentially many different candidates. A hash map ( or dictionary) is the ideal data structure for this task. In C++, this is implemented as std::unordered_map. We can map each candidate’s name (a std::string) to their total vote count (an integer type like unsigned long).\nThe overall algorithm proceeds in three main stages:\nFirst, we read the input and count the votes. We iterate through each line of the input. For each line, which represents a single vote, we check if it is the terminator string ***. If it is, we stop reading. Otherwise, we use the candidate’s name as a key in our unordered_map and increment the corresponding value. The [] operator of std::unordered_map is very convenient here: if the key (the name) doesn’t exist in the map, it is automatically inserted with a default-constructed value (0 for integers), and then the increment operation ++ brings it to 1. If the key already exists, its value is simply incremented.\nSecond, after processing all votes, we need to determine the highest number of votes received by any candidate. We can achieve this by iterating through all the key-value pairs in our map and keeping track of the maximum value (vote count) seen so far. Let’s call this maximum value max_vote.\nThird, we must identify the winner or detect a tie. A single pass through the map is not sufficient to do this reliably while also finding the maximum value. Therefore, a second pass through the map is the simplest and clearest approach. In this second iteration, we compare each candidate’s vote count with the max_vote we found in the previous step. We use a string variable, say winner_name, initialized to a special sentinel value (like the *** from the input, as it cannot be a valid candidate name). When we find the first candidate whose vote count equals max_vote, we store their name in winner_name. If we then encounter another candidate whose vote count also equals max_vote, we know there is a tie. At this point, we can immediately print “Runoff!” and terminate the program. If the second loop completes without finding a second candidate with max_vote, it means there is a unique winner, whose name is now stored in our winner_name variable. We then print this name.\nComplexity Analysis Let N be the total number of votes cast, and C be the number of unique candidates. Let L be the maximum length of a candidate’s name.\nTime Complexity The process can be broken down into three parts.\nReading votes and populating the map: We loop N times. Inside the loop, std::getline takes O(L) time. Accessing the unordered_map with a string key involves hashing the string, which takes O(L) time on average. Therefore, this phase has an average-case time complexity of O(N * L). Finding the maximum vote count: We iterate through the C unique candidates stored in the map. This takes O(C) time. Identifying the winner or a tie: We again iterate through the C unique candidates, which takes O(C) time. The total time complexity is the sum of these parts: O(N * L + C + C) = O(N * L + C). Since the number of unique candidates C cannot exceed the total number of votes N (i.e., C ≤ N), the complexity is dominated by the first phase, resulting in a final average-case time complexity of O(N * L).\nSpace Complexity The primary space usage comes from the unordered_map. In the worst-case scenario, every vote is for a different candidate, meaning we would store N unique names. The space required for the map is proportional to the number of unique candidates (C) and the sum of the lengths of their names. In the worst case, this is O(N * L), where we store N names of average length L. Thus, the space complexity is O(N * L).\nSet Problem Set is a card game designed by Marsha Falco in 1974 which is marketed by Set Enterprises, Inc. It also appears in syndicated form on the website of the New York Times. The player is shown 12 cards, each of which contains 1, 2, or 3 symbols. The symbols are either diamonds, squiggles, or ovals. Symbols are drawn using either a solid, striped, or open fill style. Each symbol’s color is either red, green, or purple. On a given card, all symbols are of the same type, same color, and have the same fill style.\nTo make a set, you must select three cards for which all 4 characteristics are either the same or pairwise different. For instance, 3 cards where the first shows 2 striped red ovals, the second shows 3 striped green squiggles, and the third shows 1 striped purple diamond form a set. They show 2, 3, and 1 symbols (each has a different number); they show ovals, squiggles, and diamonds (each shows a different shape); they use colors red, green, and purple (3 different colors); and lastly, they all share the same fill style: striped.\nWrite a program that finds all sets for 12 provided cards!\nInput The input to your program will consist of 4 lines, each containing 3 strings representing 3 cards, each consisting of four characters ABCD where\nA ∈ {1, 2, 3}, corresponding to the number of symbols.\nB ∈ {D, S, O}, corresponding to diamonds (D), squiggles (S), and ovals (O).\nC ∈ {S, T, O}, corresponding to solid (S), striped (T), and open (O) fill styles.\nD ∈ {R, G, P}, corresponding to red (R), green (G), and purple (P).\nThink of the cards as being arranged in the input as follows:\n+———-+ | 1 2 3 | | 4 5 6 | | 7 8 9 | | 10 11 12 | +———-+\nOutput Output all sets you can find, one per line. For each set, output the numbers of the card in the set in sorted order. The sets should be listed in sorted order using the number of their first card, breaking ties using the numbers of the second and third card in the set. If no sets can be formed, output “no sets”.\nCode #include #include #include #include #include #include namespace set { std::vector\u003cstd::vector\u003cint\u003e\u003e ans = {}; class card { public: int id; char f[4]; card(int id, std::string s); }; class cardset { public: unsigned short mask = -1; int cnt = 0; std::unordered_set\u003ccard *\u003e cards{}; cardset() = default; cardset(card *c); void insert(card *c); }; cardset::cardset(card *c) { this-\u003ecards.insert(c); this-\u003ecnt = 1; } unsigned short calc_mask(card *c1, card *c2) { unsigned short mask = 0; for(int i = 0; i \u003c 4; i++) { mask \u003c\u003c= 1; mask |= c1-\u003ef[i] == c2-\u003ef[i]; } return mask; } card::card(int id, std::string s) { this-\u003eid = id; std::istringstream iss(s); iss \u003e\u003e this-\u003ef[0] \u003e\u003e this-\u003ef[1] \u003e\u003e this-\u003ef[2] \u003e\u003e this-\u003ef[3]; } void cardset::insert(card *c) { if(this-\u003emask == (unsigned short) (-1)) { this-\u003emask = calc_mask(c, *this-\u003ecards.begin()); } this-\u003ecards.insert(c); this-\u003ecnt++; if(this-\u003ecnt == 3) { std::vector\u003cint\u003e vec = {}; for(auto \u0026card_ptr: this-\u003ecards) { vec.emplace_back(card_ptr-\u003eid); } std::sort(vec.begin(), vec.end()); ans.emplace_back(vec); } } bool fit(card *c, const cardset *s) { if(s-\u003emask == (unsigned short) (-1)) { return true; } for(auto \u0026sc: s-\u003ecards) { if(calc_mask(sc, c) != s-\u003emask) { return false; } } return true; } int main(std::istream \u0026cin, std::ostream \u0026cout) { cardset sets[1 \u003c\u003c 10] = {}; int sets_cnt = 0; std::string input; for(int i = 1; i \u003c= 12; i++) { cin \u003e\u003e input; card *newcard = new card(i, input); for(int j = 0; j \u003c sets_cnt; j++) { if(fit(newcard, \u0026sets[j])) { cardset newset = sets[j]; newset.insert(newcard); sets[sets_cnt++] = (newset); } } cardset newset = cardset(newcard); sets[sets_cnt++] = (newset); } if(ans.size() == 0) { cout \u003c\u003c \"no sets\"; return 0; } std::sort(ans.begin(), ans.end(), [](const std::vector\u003cint\u003e \u0026a, const std::vector\u003cint\u003e \u0026b) { if(a[0] != b[0]) { return a[0] \u003c b[0]; } else if(a[1] != b[1]) { return a[1] \u003c b[1]; } else { return a[2] \u003c b[2]; } }); for(const auto \u0026s: ans) { cout \u003c\u003c s[0] \u003c\u003c ' ' \u003c\u003c s[1] \u003c\u003c ' ' \u003c\u003c s[2] \u003c\u003c std::endl; } return 0; } } Solution The problem asks us to find all valid “sets” from a given collection of 12 cards. A set consists of three cards where for each of their four features, the feature values are either all identical or all pairwise different.\nThe provided C++ code implements a constructive or incremental algorithm to find these sets. Instead of checking every possible combination of three cards (brute-force), it builds up potential sets by adding one card at a time.\nThe core logic revolves around a clever use of bitmasking to represent the relationship between two cards. The function calc_mask(card *c1, card *c2) generates a 4-bit integer. Each bit corresponds to one of the four features. The bit is set to 1 if the feature is the same on both cards, and 0 if it’s different. This “similarity mask” compactly describes how two cards relate to each other.\nThe rule for a set of three cards (A, B, C) can be rephrased using this mask: the similarity mask between A and B must be identical to the similarity mask between A and C, and also identical to the similarity mask between B and C. This ensures the “all same or all different” property for every feature.\nThe main algorithm proceeds as follows:\nIt processes cards one by one, from card 1 to card 12. It maintains an array, sets, which stores cardset objects. A cardset is a potential set, which can contain one or two cards.\nFor each new card newcard that is read:\nIt iterates through all cardset objects already created (sets[j]). A cardset can be of size 1 (a single card) or size 2 (a pair of cards). The function fit(newcard, \u0026sets[j]) checks if newcard can be validly added to the existing cardset. If sets[j] contains only one card, any newcard can “fit” to form a pair. A new cardset of size 2 is created from this pair. Its mask member is now calculated and stored, representing the similarity between these two cards. If sets[j] contains two cards, fit checks if newcard’s similarity mask with both cards in sets[j] matches the mask already stored in sets[j]. If it does, a valid set of three has been found. A new cardset of size 3 is created, and its card IDs are added to the global ans vector. After attempting to extend all existing cardsets, a new cardset containing only the newcard is created and added to the list. This allows newcard to start new potential sets with subsequently processed cards. After all 12 cards have been processed, the ans vector contains all found sets. The code then checks if any sets were found. If not, it prints “no sets”. Otherwise, it sorts the list of sets lexicographically as required by the problem statement and prints each set on a new line.\nComplexity Analysis: Let N be the number of cards (N=12).\nTime Complexity The outer loop runs N times. The inner loop iterates through sets_cnt, which is the number of existing cardsets. After processing i cards, the number of cardsets of size 1 is i and the number of size 2 is i*(i-1)/2. So, sets_cnt grows quadratically, O(i^2). The total work is approximately the sum of i^2 from i=1 to N-1, which results in a time complexity of O(N^3). For N=12, this is very efficient.\nSpace Complexity The sets array stores all cardset objects. The number of these objects is O(N^2). Each cardset stores pointers, so the space is dominated by the array itself, leading to O(N^2) space complexity.\nPlanting Trees Problem Farmer Jon has recently bought n tree seedlings that he wants to plant in his yard. It takes 1 day for Jon to plant a seedling, and for each tree Jon knows exactly in how many days after planting it grows to full maturity. Jon would also like to throw a party for his farmer friends, but in order to impress them he would like to organize the party only after all the trees have grown. More precisely, the party can be organized at earliest on the next day after the last tree has grown up.\nHelp Jon to find out when is the earliest day when the party can take place. Jon can choose the order of planting the trees as he likes, so he wants to plant the trees in such a way that the party will be as soon as possible.\nInput The input consists of two lines. The first line contains a single integer N (1 ≤ N ≤ 100 000) denoting the number of seedlings. Then a line with N integers t_i follows (1 ≤ t_i ≤ 1 000 000), where t_i denotes the number of days it takes for the i-th tree to grow.\nOutput You program should output exactly one line containing one integer, denoting the earliest day when the party can be organized. The days are numbered 1, 2, 3, … beginning from the current moment.\nCode ##include ##include ##include namespace plantingtrees { int main(std::istream \u0026cin, std::ostream \u0026cout) { int n; cin \u003e\u003e n; std::vector\u003cint\u003e vec(n); for(int i = 0; i \u003c n; i++) { cin \u003e\u003e vec[i]; } // Sort the tree growth times in descending order. // The rbegin() and rend() iterators are used for reverse sorting. std::sort(vec.rbegin(), vec.rend()); int ans = 0; // Iterate through the trees in the chosen planting order. // The tree at index 'i' is planted on day 'i + 1'. for(int i = 0; i \u003c n; i++) { // Day of planting: i + 1 // Growth time: vec[i] // Maturity day: (i + 1) + vec[i] // Party day must be after all trees mature, so we find the maximum maturity day. // The party is on the day AFTER the last tree matures. // The value `i + vec[i] + 2` corresponds to `(i + 1) + vec[i] + 1`, which is the earliest possible party day // if this tree is the last one to mature. ans = std::max(ans, i + vec[i] + 2); } cout \u003c\u003c ans; return 0; } } Solution The problem asks for the earliest possible day to hold a party, which must be the day after all planted trees have matured. We have N seedlings, and we know the time t_i each seedling takes to mature after being planted. Planting one seedling takes one day. We can decide the order of planting. The goal is to find a planting order that minimizes the final party day.\nLet’s analyze the timeline. If we decide on a planting order, the first tree is planted on day 1, the second on day 2, and so on, with the i-th tree in the sequence being planted on day i. If this i-th tree has a maturity time of t_i, it will be fully grown on day i + t_i. The party can only happen after all trees are mature. This means we need to find the latest maturity day among all trees. The party can be held on the day immediately following this latest maturity day. So, for a given planting sequence p_1, p_2, ..., p_N with corresponding growth times t_{p_1}, t_{p_2}, ..., t_{p_N}, the party day will be 1 + max(1 + t_{p_1}, 2 + t_{p_2}, ..., N + t_{p_N}). Our task is to find an ordering (a permutation p) of the trees that minimizes this value.\nThis problem can be solved using a greedy approach. The intuition is that trees requiring a longer time to grow should be planted as early as possible. This gives them a “head start” on their long maturation period. Conversely, trees that grow quickly can be planted later without significantly pushing back the final completion date.\nLet’s prove this greedy strategy is optimal. The strategy is: sort the trees in descending order of their growth times ( t_i) and plant them in that order. Consider any optimal planting schedule. If this schedule is not sorted by growth time in descending order, there must be at least one pair of adjacent trees in the planting sequence, say at day i and i+1, where the tree planted on day i (let’s call it tree A with growth time t_A) has a shorter growth time than the tree planted on day i+1 (tree B with growth time t_B). So, t_A \u003c t_B.\nThe maturity days for these two trees in this schedule are:\nMaturity of A: i + t_A\nMaturity of B: (i + 1) + t_B\nAll other trees in the sequence are unaffected by what we do with A and B. The latest maturity day for the schedule is max(..., i + t_A, (i + 1) + t_B, ...).\nNow, let’s swap the planting order of A and B. We plant B on day i and A on day i+1. The new maturity days are:\nNew Maturity of B: i + t_B\nNew Maturity of A: (i + 1) + t_A\nLet’s compare the latest maturity day of just this pair before and after the swap. Before swap, the latest is max(i + t_A, i + 1 + t_B). Since t_A \u003c t_B, it implies t_A \u003c= t_B - 1. So, i + t_A \u003c i + t_B - 1 \u003c i + 1 + t_B. The maximum is i + 1 + t_B. After swap, the latest is max(i + t_B, i + 1 + t_A). Since t_A \u003c t_B, it implies i + 1 + t_A \u003c i + 1 + t_B. And also i + t_B is greater than i + 1 + t_A if t_B - t_A \u003e 1. Regardless, the maximum is i + t_B.\nComparing the maximums: (i + t_B) (after swap) vs. (i + 1 + t_B) (before swap). Clearly, i + t_B \u003c i + 1 + t_B. The swap has reduced the latest maturity day for this pair. Since all other trees' maturity days remain unchanged, the overall latest maturity day for the entire schedule can only decrease or stay the same. It cannot increase. This “exchange argument” shows that we can always improve or maintain an unsorted schedule by moving longer-growth-time trees earlier. By repeatedly applying this logic, we can transform any optimal schedule into one that is sorted by growth time descending, without making the result worse. Therefore, the greedy strategy of planting trees with longer growth times first is indeed optimal.\nThe implementation is straightforward:\nRead N and all the growth times t_i into a vector. Sort the vector in descending order. Initialize a variable max_party_day to 0. Iterate through the sorted vector from i = 0 to N-1. The tree t_i is planted on day i+1. Its maturity day is (i+1) + t_i. The earliest party day considering this tree would be (i+1) + t_i + 1. We update our max_party_day with the maximum of its current value and this new calculated day. After the loop, max_party_day will hold the final answer. Complexity Analysis Let N be the number of seedlings.\nTime Complexity The dominant operation is sorting the growth times. Standard sorting algorithms take O(N log N) time. Reading the input takes O(N), and the final loop to calculate the maximum party day also takes O(N). Therefore, the total time complexity is O(N log N).\nSpace Complexity We need to store the N growth times in a vector, which requires O(N) space.\n","wordCount":"3838","inLanguage":"en","datePublished":"2025-10-01T21:47:12+01:00","dateModified":"2025-10-01T21:47:12+01:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/en/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/en/ title=Home><span>Home</span></a></li><li><a href=https://tategotoazarasi.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://tategotoazarasi.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Uol 2025 Wk2 Solutions</h1><div class=post-meta><span title='2025-10-01 21:47:12 +0100 +0100'>October 1, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;3838 words&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#recount>Recount</a><ol><li><a href=#problem>Problem</a><ol><li><a href=#input>Input</a></li><li><a href=#output>Output</a></li></ol></li><li><a href=#code>Code</a></li><li><a href=#solution>Solution</a></li><li><a href=#complexity-analysis>Complexity Analysis</a><ol><li><a href=#time-complexity>Time Complexity</a></li><li><a href=#space-complexity>Space Complexity</a></li></ol></li></ol></li><li><a href=#set>Set</a><ol><li><a href=#problem-1>Problem</a><ol><li><a href=#input-1>Input</a></li><li><a href=#output-1>Output</a></li></ol></li><li><a href=#code-1>Code</a></li><li><a href=#solution-1>Solution</a></li><li><a href=#complexity-analysis-1>Complexity Analysis:</a><ol><li><a href=#time-complexity-1>Time Complexity</a></li><li><a href=#space-complexity-1>Space Complexity</a></li></ol></li></ol></li><li><a href=#planting-trees>Planting Trees</a><ol><li><a href=#problem-2>Problem</a><ol><li><a href=#input-2>Input</a></li><li><a href=#output-2>Output</a></li></ol></li><li><a href=#code-2>Code</a></li><li><a href=#solution-2>Solution</a></li><li><a href=#complexity-analysis-2>Complexity Analysis</a><ol><li><a href=#time-complexity-2>Time Complexity</a></li><li><a href=#space-complexity-2>Space Complexity</a></li></ol></li></ol></li></ol></nav></div></details></div><div class=post-content><h2 id=recount>Recount<a hidden class=anchor aria-hidden=true href=#recount>#</a></h2><h3 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h3><p>The recent schoolboard elections were hotly contested: a proposal to swap school start times for elementary and high
school students, a controversial new dress code proposal that bans athletic clothes in school, and a proposal to raise
real-estate taxes to pay for a new football practice facility, and the list goes on and on. It is now hours after the
polls have closed and a winner has yet to emerge!</p><p>In their desperation, the election officials turn to you and ask you to write a program to count the vote!</p><h4 id=input>Input<a hidden class=anchor aria-hidden=true href=#input>#</a></h4><p>The input consists of a single test case, which is a list of votes cast. Each line in the input contains the name of a
candidate for whom a vote was cast. A name may consist of multiple words, separated by spaces. Words contain letters or
hyphens, but no other punctuation characters. There will be at least 2 votes on the list. The list of votes ends with a
single line containing the characters <code>***</code>. This line should not be counted. There can be up to 100 000 valid votes.</p><h4 id=output>Output<a hidden class=anchor aria-hidden=true href=#output>#</a></h4><p>If a candidate obtained a simple or absolute majority of all votes cast (that is, more than any other candidate), output
the name of this candidate! If no candidate obtained a simple majority, output: “<code>Runoff!</code>” (don’t forget to include the
exclamation mark!)</p><h3 id=code>Code<a hidden class=anchor aria-hidden=true href=#code>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>##include &lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;string&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;unordered_map&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// using namespace std; // For brevity in a single file solution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> recount {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(istream <span style=color:#f92672>&amp;</span>cin, ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use an unordered_map to store vote counts for each candidate.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The key is the candidate&#39;s name (string), and the value is their vote count (unsigned long).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string line;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Read votes line by line until the sentinel value &#34;***&#34; is encountered.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(std<span style=color:#f92672>::</span>getline(cin, line)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(line <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;***&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Increment the vote count for the candidate named in the current line.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// If the candidate is not yet in the map, they are added with a count of 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            m[line]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initialize a string to hold the winner&#39;s name and a variable for the maximum vote count.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>string ans             <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;***&#34;</span>; <span style=color:#75715e>// Sentinel value to check for ties.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max_vote <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// First pass: find the highest vote count among all candidates.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>[k, v]<span style=color:#f92672>:</span> m) {
</span></span><span style=display:flex><span>            max_vote <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(max_vote, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Second pass: find the candidate(s) who achieved the maximum vote count.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>[k, v]<span style=color:#f92672>:</span> m) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>==</span> max_vote) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If &#39;ans&#39; is no longer the sentinel value, it means we have already found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// one winner. Finding another one means there is a tie.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;***&#34;</span>) {
</span></span><span style=display:flex><span>                    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Runoff!&#34;</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// Exit after printing the result for a tie.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// This is the first candidate found with the maximum vote count.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                ans <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If the loop completes and &#39;ans&#39; has been updated exactly once, print the winner&#39;s name.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>This problem asks us to process a list of votes, where each vote is a string representing a candidate&rsquo;s name. We need to
find the candidate with the most votes. If there is a single candidate with the highest vote count, we print their name.
If two or more candidates are tied for the highest count, we must declare a &ldquo;Runoff!&rdquo;. The list of votes is terminated
by a special string, <code>***</code>.</p><p>To solve this, we need an efficient way to store and count votes for potentially many different candidates. A hash map (
or dictionary) is the ideal data structure for this task. In C++, this is implemented as <code>std::unordered_map</code>. We can
map each candidate&rsquo;s name (a <code>std::string</code>) to their total vote count (an integer type like <code>unsigned long</code>).</p><p>The overall algorithm proceeds in three main stages:</p><p>First, we read the input and count the votes. We iterate through each line of the input. For each line, which represents
a single vote, we check if it is the terminator string <code>***</code>. If it is, we stop reading. Otherwise, we use the
candidate&rsquo;s name as a key in our <code>unordered_map</code> and increment the corresponding value. The <code>[]</code> operator of
<code>std::unordered_map</code> is very convenient here: if the key (the name) doesn&rsquo;t exist in the map, it is automatically
inserted with a default-constructed value (0 for integers), and then the increment operation <code>++</code> brings it to 1. If the
key already exists, its value is simply incremented.</p><p>Second, after processing all votes, we need to determine the highest number of votes received by any candidate. We can
achieve this by iterating through all the key-value pairs in our map and keeping track of the maximum value (vote count)
seen so far. Let&rsquo;s call this maximum value <code>max_vote</code>.</p><p>Third, we must identify the winner or detect a tie. A single pass through the map is not sufficient to do this reliably
while also finding the maximum value. Therefore, a second pass through the map is the simplest and clearest approach. In
this second iteration, we compare each candidate&rsquo;s vote count with the <code>max_vote</code> we found in the previous step. We use
a string variable, say <code>winner_name</code>, initialized to a special sentinel value (like the <code>***</code> from the input, as it
cannot be a valid candidate name). When we find the first candidate whose vote count equals <code>max_vote</code>, we store their
name in <code>winner_name</code>. If we then encounter another candidate whose vote count also equals <code>max_vote</code>, we know there is
a tie. At this point, we can immediately print &ldquo;Runoff!&rdquo; and terminate the program. If the second loop completes without
finding a second candidate with <code>max_vote</code>, it means there is a unique winner, whose name is now stored in our
<code>winner_name</code> variable. We then print this name.</p><h3 id=complexity-analysis>Complexity Analysis<a hidden class=anchor aria-hidden=true href=#complexity-analysis>#</a></h3><p>Let N be the total number of votes cast, and C be the number of unique candidates. Let L be the maximum length of a
candidate&rsquo;s name.</p><h4 id=time-complexity>Time Complexity<a hidden class=anchor aria-hidden=true href=#time-complexity>#</a></h4><p>The process can be broken down into three parts.</p><ol><li>Reading votes and populating the map: We loop N times. Inside the loop, <code>std::getline</code> takes O(L) time. Accessing the
<code>unordered_map</code> with a string key involves hashing the string, which takes O(L) time on average. Therefore, this
phase has an average-case time complexity of O(N * L).</li><li>Finding the maximum vote count: We iterate through the C unique candidates stored in the map. This takes O(C) time.</li><li>Identifying the winner or a tie: We again iterate through the C unique candidates, which takes O(C) time.</li></ol><p>The total time complexity is the sum of these parts: O(N * L + C + C) = O(N * L + C). Since the number of unique
candidates C cannot exceed the total number of votes N (i.e., C ≤ N), the complexity is dominated by the first phase,
resulting in a final average-case time complexity of O(N * L).</p><h4 id=space-complexity>Space Complexity<a hidden class=anchor aria-hidden=true href=#space-complexity>#</a></h4><p>The primary space usage comes from the <code>unordered_map</code>. In the worst-case scenario, every vote is for a different
candidate, meaning we would store N unique names. The space required for the map is proportional to the number of unique
candidates (C) and the sum of the lengths of their names. In the worst case, this is O(N * L), where we store N names of
average length L. Thus, the space complexity is O(N * L).</p><h2 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h2><h3 id=problem-1>Problem<a hidden class=anchor aria-hidden=true href=#problem-1>#</a></h3><p>Set is a card game designed by Marsha Falco in 1974 which is marketed by Set Enterprises, Inc. It also appears in
syndicated form on the website of the New York Times. The player is shown 12 cards, each of which contains 1, 2, or 3
symbols. The symbols are either diamonds, squiggles, or ovals. Symbols are drawn using either a solid, striped, or open
fill style. Each symbol’s color is either red, green, or purple. On a given card, all symbols are of the same type, same
color, and have the same fill style.</p><p>To make a set, you must select three cards for which all 4 characteristics are either the same or pairwise different.
For instance, 3 cards where the first shows 2 striped red ovals, the second shows 3 striped green squiggles, and the
third shows 1 striped purple diamond form a set. They show 2, 3, and 1 symbols (each has a different number); they show
ovals, squiggles, and diamonds (each shows a different shape); they use colors red, green, and purple (3 different
colors); and lastly, they all share the same fill style: striped.</p><p>Write a program that finds all sets for 12 provided cards!</p><h4 id=input-1>Input<a hidden class=anchor aria-hidden=true href=#input-1>#</a></h4><p>The input to your program will consist of 4 lines, each containing 3 strings representing 3 cards, each consisting of
four characters ABCD where</p><p>A ∈ {1, 2, 3}, corresponding to the number of symbols.</p><p>B ∈ {D, S, O}, corresponding to diamonds (D), squiggles (S), and ovals (O).</p><p>C ∈ {S, T, O}, corresponding to solid (S), striped (T), and open (O) fill styles.</p><p>D ∈ {R, G, P}, corresponding to red (R), green (G), and purple (P).</p><p>Think of the cards as being arranged in the input as follows:</p><p>+&mdash;&mdash;&mdash;-+
| 1 2 3 |
| 4 5 6 |
| 7 8 9 |
| 10 11 12 |
+&mdash;&mdash;&mdash;-+</p><h4 id=output-1>Output<a hidden class=anchor aria-hidden=true href=#output-1>#</a></h4><p>Output all sets you can find, one per line. For each set, output the numbers of the card in the set in sorted order. The
sets should be listed in sorted order using the number of their first card, breaking ties using the numbers of the
second and third card in the set.
If no sets can be formed, output “no sets”.</p><h3 id=code-1>Code<a hidden class=anchor aria-hidden=true href=#code-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> set {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>card</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> f[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        card(<span style=color:#66d9ef>int</span> id, std<span style=color:#f92672>::</span>string s);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>cardset</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> mask <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cnt             <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>card <span style=color:#f92672>*&gt;</span> cards{};
</span></span><span style=display:flex><span>        cardset() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>        cardset(card <span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(card <span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cardset<span style=color:#f92672>::</span>cardset(card <span style=color:#f92672>*</span>c) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.insert(c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#a6e22e>calc_mask</span>(card <span style=color:#f92672>*</span>c1, card <span style=color:#f92672>*</span>c2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            mask <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            mask <span style=color:#f92672>|=</span> c1<span style=color:#f92672>-&gt;</span>f[i] <span style=color:#f92672>==</span> c2<span style=color:#f92672>-&gt;</span>f[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mask;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    card<span style=color:#f92672>::</span>card(<span style=color:#66d9ef>int</span> id, std<span style=color:#f92672>::</span>string s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>istringstream iss(s);
</span></span><span style=display:flex><span>        iss <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> cardset<span style=color:#f92672>::</span>insert(card <span style=color:#f92672>*</span>c) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>==</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>=</span> calc_mask(c, <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.begin());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.insert(c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>card_ptr: <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards) {
</span></span><span style=display:flex><span>                vec.emplace_back(card_ptr<span style=color:#f92672>-&gt;</span>id);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>sort(vec.begin(), vec.end());
</span></span><span style=display:flex><span>            ans.emplace_back(vec);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>fit</span>(card <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>const</span> cardset <span style=color:#f92672>*</span>s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(s<span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>==</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>sc: s<span style=color:#f92672>-&gt;</span>cards) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(calc_mask(sc, c) <span style=color:#f92672>!=</span> s<span style=color:#f92672>-&gt;</span>mask) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(std<span style=color:#f92672>::</span>istream <span style=color:#f92672>&amp;</span>cin, std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        cardset sets[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> sets_cnt          <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string input;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>12</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> input;
</span></span><span style=display:flex><span>            card <span style=color:#f92672>*</span>newcard <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> card(i, input);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> sets_cnt; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(fit(newcard, <span style=color:#f92672>&amp;</span>sets[j])) {
</span></span><span style=display:flex><span>                    cardset newset <span style=color:#f92672>=</span> sets[j];
</span></span><span style=display:flex><span>                    newset.insert(newcard);
</span></span><span style=display:flex><span>                    sets[sets_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> (newset);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cardset newset   <span style=color:#f92672>=</span> cardset(newcard);
</span></span><span style=display:flex><span>            sets[sets_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> (newset);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(ans.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;no sets&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sort(ans.begin(), ans.end(), [](<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>b) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> b[<span style=color:#ae81ff>0</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> b[<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>s: ans) {
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution-1>Solution<a hidden class=anchor aria-hidden=true href=#solution-1>#</a></h3><p>The problem asks us to find all valid &ldquo;sets&rdquo; from a given collection of 12 cards. A set consists of three cards where
for each of their four features, the feature values are either all identical or all pairwise different.</p><p>The provided C++ code implements a constructive or incremental algorithm to find these sets. Instead of checking every
possible combination of three cards (brute-force), it builds up potential sets by adding one card at a time.</p><p>The core logic revolves around a clever use of bitmasking to represent the relationship between two cards. The function
<code>calc_mask(card *c1, card *c2)</code> generates a 4-bit integer. Each bit corresponds to one of the four features. The bit is
set to <code>1</code> if the feature is the same on both cards, and <code>0</code> if it&rsquo;s different. This &ldquo;similarity mask&rdquo; compactly
describes how two cards relate to each other.</p><p>The rule for a set of three cards (A, B, C) can be rephrased using this mask: the similarity mask between A and B must
be identical to the similarity mask between A and C, and also identical to the similarity mask between B and C. This
ensures the &ldquo;all same or all different&rdquo; property for every feature.</p><p>The main algorithm proceeds as follows:</p><p>It processes cards one by one, from card 1 to card 12. It maintains an array, <code>sets</code>, which stores <code>cardset</code> objects. A
<code>cardset</code> is a potential set, which can contain one or two cards.</p><p>For each new card <code>newcard</code> that is read:</p><ol><li>It iterates through all <code>cardset</code> objects already created (<code>sets[j]</code>). A <code>cardset</code> can be of size 1 (a single card)
or size 2 (a pair of cards).</li><li>The function <code>fit(newcard, &amp;sets[j])</code> checks if <code>newcard</code> can be validly added to the existing <code>cardset</code>.</li><li>If <code>sets[j]</code> contains only one card, any <code>newcard</code> can &ldquo;fit&rdquo; to form a pair. A new <code>cardset</code> of size 2 is created
from this pair. Its <code>mask</code> member is now calculated and stored, representing the similarity between these two cards.</li><li>If <code>sets[j]</code> contains two cards, <code>fit</code> checks if <code>newcard</code>&rsquo;s similarity mask with both cards in <code>sets[j]</code> matches the
<code>mask</code> already stored in <code>sets[j]</code>. If it does, a valid set of three has been found. A new <code>cardset</code> of size 3 is
created, and its card IDs are added to the global <code>ans</code> vector.</li><li>After attempting to extend all existing <code>cardset</code>s, a new <code>cardset</code> containing only the <code>newcard</code> is created and
added to the list. This allows <code>newcard</code> to start new potential sets with subsequently processed cards.</li></ol><p>After all 12 cards have been processed, the <code>ans</code> vector contains all found sets. The code then checks if any sets were
found. If not, it prints &ldquo;no sets&rdquo;. Otherwise, it sorts the list of sets lexicographically as required by the problem
statement and prints each set on a new line.</p><h3 id=complexity-analysis-1>Complexity Analysis:<a hidden class=anchor aria-hidden=true href=#complexity-analysis-1>#</a></h3><p>Let N be the number of cards (N=12).</p><h4 id=time-complexity-1>Time Complexity<a hidden class=anchor aria-hidden=true href=#time-complexity-1>#</a></h4><p>The outer loop runs N times. The inner loop iterates through <code>sets_cnt</code>, which is the number of existing <code>cardset</code>s.
After processing <code>i</code> cards, the number of <code>cardset</code>s of size 1 is <code>i</code> and the number of size 2 is <code>i*(i-1)/2</code>. So,
<code>sets_cnt</code> grows quadratically, O(i^2). The total work is approximately the sum of <code>i^2</code> from <code>i=1</code> to <code>N-1</code>, which
results in a time complexity of O(N^3). For N=12, this is very efficient.</p><h4 id=space-complexity-1>Space Complexity<a hidden class=anchor aria-hidden=true href=#space-complexity-1>#</a></h4><p>The <code>sets</code> array stores all <code>cardset</code> objects. The number of these objects is O(N^2). Each <code>cardset</code> stores pointers, so
the space is dominated by the array itself, leading to O(N^2) space complexity.</p><h2 id=planting-trees>Planting Trees<a hidden class=anchor aria-hidden=true href=#planting-trees>#</a></h2><h3 id=problem-2>Problem<a hidden class=anchor aria-hidden=true href=#problem-2>#</a></h3><p>Farmer Jon has recently bought n tree seedlings that he wants to plant in his yard. It takes 1 day for Jon to plant a
seedling, and for each tree Jon knows exactly in how many days after planting it grows to full maturity. Jon would also
like to throw a party for his farmer friends, but in order to impress them he would like to organize the party only
after all the trees have grown. More precisely, the party can be organized at earliest on the next day after the last
tree has grown up.</p><p>Help Jon to find out when is the earliest day when the party can take place. Jon can choose the order of planting the
trees as he likes, so he wants to plant the trees in such a way that the party will be as soon as possible.</p><h4 id=input-2>Input<a hidden class=anchor aria-hidden=true href=#input-2>#</a></h4><p>The input consists of two lines. The first line contains a single integer N (1 ≤ N ≤ 100 000) denoting the number of
seedlings. Then a line with N integers t_i follows (1 ≤ t_i ≤ 1 000 000), where t_i denotes the number of days it takes
for the i-th tree to grow.</p><h4 id=output-2>Output<a hidden class=anchor aria-hidden=true href=#output-2>#</a></h4><p>You program should output exactly one line containing one integer, denoting the earliest day when the party can be
organized. The days are numbered 1, 2, 3, &mldr; beginning from the current moment.</p><h3 id=code-2>Code<a hidden class=anchor aria-hidden=true href=#code-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>##include &lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>##include &lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> plantingtrees {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(std<span style=color:#f92672>::</span>istream <span style=color:#f92672>&amp;</span>cin, std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> n;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec(n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> vec[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sort the tree growth times in descending order.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The rbegin() and rend() iterators are used for reverse sorting.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(vec.rbegin(), vec.rend());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Iterate through the trees in the chosen planting order.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// The tree at index &#39;i&#39; is planted on day &#39;i + 1&#39;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Day of planting: i + 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Growth time: vec[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Maturity day: (i + 1) + vec[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Party day must be after all trees mature, so we find the maximum maturity day.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// The party is on the day AFTER the last tree matures.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// The value `i + vec[i] + 2` corresponds to `(i + 1) + vec[i] + 1`, which is the earliest possible party day
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// if this tree is the last one to mature.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ans, i <span style=color:#f92672>+</span> vec[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=solution-2>Solution<a hidden class=anchor aria-hidden=true href=#solution-2>#</a></h3><p>The problem asks for the earliest possible day to hold a party, which must be the day after all planted trees have
matured. We have N seedlings, and we know the time <code>t_i</code> each seedling takes to mature after being planted. Planting one
seedling takes one day. We can decide the order of planting. The goal is to find a planting order that minimizes the
final party day.</p><p>Let&rsquo;s analyze the timeline. If we decide on a planting order, the first tree is planted on day 1, the second on day 2,
and so on, with the <code>i</code>-th tree in the sequence being planted on day <code>i</code>. If this <code>i</code>-th tree has a maturity time of
<code>t_i</code>, it will be fully grown on day <code>i + t_i</code>. The party can only happen after <em>all</em> trees are mature. This means we
need to find the latest maturity day among all trees. The party can be held on the day immediately following this latest
maturity day.
So, for a given planting sequence <code>p_1, p_2, ..., p_N</code> with corresponding growth times <code>t_{p_1}, t_{p_2}, ..., t_{p_N}</code>,
the party day will be <code>1 + max(1 + t_{p_1}, 2 + t_{p_2}, ..., N + t_{p_N})</code>. Our task is to find an ordering (a
permutation <code>p</code>) of the trees that minimizes this value.</p><p>This problem can be solved using a greedy approach. The intuition is that trees requiring a longer time to grow should
be planted as early as possible. This gives them a &ldquo;head start&rdquo; on their long maturation period. Conversely, trees that
grow quickly can be planted later without significantly pushing back the final completion date.</p><p>Let&rsquo;s prove this greedy strategy is optimal. The strategy is: sort the trees in descending order of their growth times (
<code>t_i</code>) and plant them in that order.
Consider any optimal planting schedule. If this schedule is not sorted by growth time in descending order, there must be
at least one pair of adjacent trees in the planting sequence, say at day <code>i</code> and <code>i+1</code>, where the tree planted on day
<code>i</code> (let&rsquo;s call it tree A with growth time <code>t_A</code>) has a shorter growth time than the tree planted on day <code>i+1</code> (tree B
with growth time <code>t_B</code>). So, <code>t_A &lt; t_B</code>.</p><p>The maturity days for these two trees in this schedule are:</p><p>Maturity of A: <code>i + t_A</code></p><p>Maturity of B: <code>(i + 1) + t_B</code></p><p>All other trees in the sequence are unaffected by what we do with A and B. The latest maturity day for the schedule is
<code>max(..., i + t_A, (i + 1) + t_B, ...)</code>.</p><p>Now, let&rsquo;s swap the planting order of A and B. We plant B on day <code>i</code> and A on day <code>i+1</code>. The new maturity days are:</p><p>New Maturity of B: <code>i + t_B</code></p><p>New Maturity of A: <code>(i + 1) + t_A</code></p><p>Let&rsquo;s compare the latest maturity day of just this pair before and after the swap.
Before swap, the latest is <code>max(i + t_A, i + 1 + t_B)</code>. Since <code>t_A &lt; t_B</code>, it implies <code>t_A &lt;= t_B - 1</code>.
So, <code>i + t_A &lt; i + t_B - 1 &lt; i + 1 + t_B</code>. The maximum is <code>i + 1 + t_B</code>.
After swap, the latest is <code>max(i + t_B, i + 1 + t_A)</code>.
Since <code>t_A &lt; t_B</code>, it implies <code>i + 1 + t_A &lt; i + 1 + t_B</code>. And also <code>i + t_B</code> is greater than <code>i + 1 + t_A</code> if
<code>t_B - t_A > 1</code>. Regardless, the maximum is <code>i + t_B</code>.</p><p>Comparing the maximums: <code>(i + t_B)</code> (after swap) vs. <code>(i + 1 + t_B)</code> (before swap).
Clearly, <code>i + t_B &lt; i + 1 + t_B</code>. The swap has reduced the latest maturity day for this pair. Since all other trees'
maturity days remain unchanged, the overall latest maturity day for the entire schedule can only decrease or stay the
same. It cannot increase.
This &ldquo;exchange argument&rdquo; shows that we can always improve or maintain an unsorted schedule by moving longer-growth-time
trees earlier. By repeatedly applying this logic, we can transform any optimal schedule into one that is sorted by
growth time descending, without making the result worse. Therefore, the greedy strategy of planting trees with longer
growth times first is indeed optimal.</p><p>The implementation is straightforward:</p><ol><li>Read N and all the growth times <code>t_i</code> into a vector.</li><li>Sort the vector in descending order.</li><li>Initialize a variable <code>max_party_day</code> to 0.</li><li>Iterate through the sorted vector from <code>i = 0</code> to <code>N-1</code>. The tree <code>t_i</code> is planted on day <code>i+1</code>. Its maturity day is
<code>(i+1) + t_i</code>. The earliest party day considering this tree would be <code>(i+1) + t_i + 1</code>. We update our <code>max_party_day</code>
with the maximum of its current value and this new calculated day.</li><li>After the loop, <code>max_party_day</code> will hold the final answer.</li></ol><h3 id=complexity-analysis-2>Complexity Analysis<a hidden class=anchor aria-hidden=true href=#complexity-analysis-2>#</a></h3><p>Let N be the number of seedlings.</p><h4 id=time-complexity-2>Time Complexity<a hidden class=anchor aria-hidden=true href=#time-complexity-2>#</a></h4><p>The dominant operation is sorting the growth times. Standard sorting algorithms take O(N log N) time. Reading the input
takes O(N), and the final loop to calculate the maximum party day also takes O(N). Therefore, the total time complexity
is O(N log N).</p><h4 id=space-complexity-2>Space Complexity<a hidden class=anchor aria-hidden=true href=#space-complexity-2>#</a></h4><p>We need to store the N growth times in a vector, which requires O(N) space.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/en/tags/recount-problem-solution/>Recount-Problem-Solution</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/set-card-game-solver/>Set-Card-Game-Solver</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/planting-trees-problem-solution/>Planting-Trees-Problem-Solution</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/competitive-programming/>Competitive-Programming</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/c-plus-plus/>C-Plus-Plus</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/algorithm-tutorial/>Algorithm-Tutorial</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/bilingual-guide/>Bilingual-Guide</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/greedy-algorithm/>Greedy-Algorithm</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/brute-force-search/>Brute-Force-Search</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/hash-map-example/>Hash-Map-Example</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/vote-counting-algorithm/>Vote-Counting-Algorithm</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/combinatorial-game-programming/>Combinatorial-Game-Programming</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/scheduling-optimization/>Scheduling-Optimization</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/time-complexity-analysis/>Time-Complexity-Analysis</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/space-complexity/>Space-Complexity</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/exchange-argument-proof/>Exchange-Argument-Proof</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/coding-challenges/>Coding-Challenges</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/problem-solving-guide/>Problem-Solving-Guide</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/chinese-english-programming-tutorial/>Chinese-English-Programming-Tutorial</a></li><li><a href=https://tategotoazarasi.github.io/en/tags/c-plus-plus-code-explanation/>C-Plus-Plus-Code-Explanation</a></li></ul><nav class=paginav><a class=prev href=https://tategotoazarasi.github.io/en/posts/uol-2025-wk3/><span class=title>« Prev</span><br><span>Uol 2025 Wk3 && LeetCode Biweekly Contest 168 Solutions</span>
</a><a class=next href=https://tategotoazarasi.github.io/en/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/><span class=title>Next »</span><br><span>Discovering a Delete-Your-Files-and-Run Level Bug in debtap</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/en/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>