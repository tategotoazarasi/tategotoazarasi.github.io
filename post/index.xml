<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/post/</link><description>Recent content in Posts on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 25 Dec 2021 21:22:38 +0800</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>AcWing 4201. 01数</title><link>https://tategotoazarasi.github.io/post/acwing4201/</link><pubDate>Sat, 25 Dec 2021 21:22:38 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4201/</guid><description>&lt;p>如果一个&lt;strong>正整数&lt;/strong>，其各个数位上的数字均满足要么是 0，要么是 1，则称该数字为 01 数。&lt;/p>
&lt;p>例如，1 和 10 都是 01 数。&lt;/p>
&lt;p>给定一个整数 n。&lt;/p>
&lt;p>请你计算，1∼n 中有多少个 01 数。&lt;/p></description></item><item><title>AcWing 4200. 简单问题</title><link>https://tategotoazarasi.github.io/post/acwing4200/</link><pubDate>Sat, 25 Dec 2021 21:19:15 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4200/</guid><description>&lt;p>给定 6 个整数 p1,p2,p3,p4,a,b。&lt;/p>
&lt;p>请问有多少个整数 x 满足以下全部条件：&lt;/p>
&lt;ol>
&lt;li>a≤x≤b&lt;/li>
&lt;li>x 同时小于 p1,p2,p3,p4&lt;/li>
&lt;/ol></description></item><item><title>LeetCode 171. Excel 表列序号</title><link>https://tategotoazarasi.github.io/post/excel-sheet-column-number/</link><pubDate>Sat, 25 Dec 2021 10:33:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/excel-sheet-column-number/</guid><description>&lt;p>给你一个字符串  &lt;code>columnTitle&lt;/code> ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。&lt;/p>
&lt;p>例如，&lt;/p>
&lt;pre>&lt;code>A -&amp;gt; 1
B -&amp;gt; 2
C -&amp;gt; 3
...
Z -&amp;gt; 26
AA -&amp;gt; 27
AB -&amp;gt; 28
...
&lt;/code>&lt;/pre></description></item><item><title>LeetCode 169. 多数元素</title><link>https://tategotoazarasi.github.io/post/majority-element/</link><pubDate>Sat, 25 Dec 2021 09:58:05 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/majority-element/</guid><description>&lt;p>给定一个大小为 &lt;em>n&lt;/em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 &lt;strong>大于&lt;/strong> &lt;code>⌊ n/2 ⌋&lt;/code>  的元素。&lt;/p>
&lt;p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p></description></item><item><title>LeetCode 168. Excel表列名称</title><link>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</link><pubDate>Fri, 24 Dec 2021 13:18:18 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</guid><description>&lt;p>给你一个整数  &lt;code>columnNumber&lt;/code> ，返回它在 Excel 表中相对应的列名称。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;p>A -&amp;gt; 1
B -&amp;gt; 2
C -&amp;gt; 3
&amp;hellip;
Z -&amp;gt; 26
AA -&amp;gt; 27
AB -&amp;gt; 28
&amp;hellip;&lt;/p></description></item><item><title>LeetCode 167. 两数之和 II - 输入有序数组</title><link>https://tategotoazarasi.github.io/post/two-sum-ii-input-array-is-sorted/</link><pubDate>Fri, 24 Dec 2021 09:11:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/two-sum-ii-input-array-is-sorted/</guid><description>&lt;p>给定一个已按照 &lt;strong>非递减顺序排列&lt;/strong> 的整数数组  &lt;code>numbers&lt;/code> ，请你从数组中找出两个数满足相加之和等于目标数  &lt;code>target&lt;/code> 。&lt;/p>
&lt;p>函数应该以长度为 &lt;code>2&lt;/code> 的整数数组的形式返回这两个数的下标值*。*&lt;code>numbers&lt;/code> 的下标 &lt;strong>从 1 开始计数&lt;/strong> ，所以答案数组应当满足 &lt;code>1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length&lt;/code> 。&lt;/p>
&lt;p>你可以假设每个输入 &lt;strong>只对应唯一的答案&lt;/strong> ，而且你 &lt;strong>不可以&lt;/strong> 重复使用相同的元素。&lt;/p></description></item><item><title>LeetCode 160. 相交链表</title><link>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</link><pubDate>Fri, 24 Dec 2021 08:29:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</guid><description>&lt;p>给你两个单链表的头节点  &lt;code>headA&lt;/code> 和 &lt;code>headB&lt;/code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code>null&lt;/code> 。&lt;/p>
&lt;p>图示两个链表在节点 &lt;code>c1&lt;/code> 开始相交 &lt;strong>：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tategotoazarasi.github.io/images/160_statement.png" alt="">&lt;/p>
&lt;p>题目数据 &lt;strong>保证&lt;/strong> 整个链式结构中不存在环。&lt;/p></description></item><item><title>LeetCode 155. 最小栈</title><link>https://tategotoazarasi.github.io/post/min-stack/</link><pubDate>Thu, 23 Dec 2021 15:25:43 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/min-stack/</guid><description>&lt;p>设计一个支持 &lt;code>push&lt;/code> ，&lt;code>pop&lt;/code> ，&lt;code>top&lt;/code> 操作，并能在常数时间内检索到最小元素的栈。&lt;/p>
&lt;ul>
&lt;li>&lt;code>push(x)&lt;/code> —— 将元素 x 推入栈中。&lt;/li>
&lt;li>&lt;code>pop()&lt;/code> —— 删除栈顶的元素。&lt;/li>
&lt;li>&lt;code>top()&lt;/code> —— 获取栈顶元素。&lt;/li>
&lt;li>&lt;code>getMin()&lt;/code> —— 检索栈中的最小元素。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 145. 二叉树的后序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-postorder-traversal/</link><pubDate>Thu, 23 Dec 2021 14:40:42 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-postorder-traversal/</guid><description>&lt;p>给定一个二叉树，返回它的 &lt;em>后序&lt;/em> 遍历。&lt;/p></description></item><item><title>LeetCode 144. 二叉树的前序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-preorder-traversal/</link><pubDate>Wed, 22 Dec 2021 10:33:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-preorder-traversal/</guid><description>&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回它节点值的  &lt;strong>前序&lt;/strong> 遍历。&lt;/p></description></item><item><title>LeetCode 141. 环形链表</title><link>https://tategotoazarasi.github.io/post/linked-list-cycle/</link><pubDate>Wed, 22 Dec 2021 10:17:23 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/linked-list-cycle/</guid><description>&lt;p>给你一个链表的头节点 &lt;code>head&lt;/code> ，判断链表中是否有环。&lt;/p>
&lt;p>如果链表中有某个节点，可以通过连续跟踪 &lt;code>next&lt;/code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 &lt;code>pos&lt;/code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 &lt;code>pos&lt;/code> 是 &lt;code>-1&lt;/code>，则在该链表中没有环。&lt;strong>注意：&lt;code>pos&lt;/code> 不作为参数进行传递&lt;/strong>，仅仅是为了标识链表的实际情况。&lt;/p>
&lt;p>如果链表中存在环，则返回 &lt;code>true&lt;/code> 。 否则，返回 &lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 136. 只出现一次的数字</title><link>https://tategotoazarasi.github.io/post/single-number/</link><pubDate>Tue, 21 Dec 2021 09:22:19 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/single-number/</guid><description>&lt;p>给定一个&lt;strong>非空&lt;/strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p></description></item><item><title>LeetCode 125. 验证回文串</title><link>https://tategotoazarasi.github.io/post/valid-palindrome/</link><pubDate>Tue, 21 Dec 2021 09:07:06 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/valid-palindrome/</guid><description>&lt;p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p></description></item><item><title>LeetCode 121. 买卖股票的最佳时机</title><link>https://tategotoazarasi.github.io/post/best-time-to-buy-and-sell-stock/</link><pubDate>Mon, 20 Dec 2021 11:17:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/best-time-to-buy-and-sell-stock/</guid><description>&lt;p>给定一个数组 &lt;code>prices&lt;/code> ，它的第  &lt;code>i&lt;/code> 个元素  &lt;code>prices[i]&lt;/code> 表示一支给定股票第 &lt;code>i&lt;/code> 天的价格。&lt;/p>
&lt;p>你只能选择 &lt;strong>某一天&lt;/strong> 买入这只股票，并选择在 &lt;strong>未来的某一个不同的日子&lt;/strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p>
&lt;p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 &lt;code>0&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 119. 杨辉三角 II</title><link>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</link><pubDate>Mon, 20 Dec 2021 11:13:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</guid><description>&lt;p>给定一个非负索引 &lt;code>rowIndex&lt;/code>，返回「杨辉三角」的第 &lt;code>rowIndex&lt;/code> 行。&lt;/p>
&lt;p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p></description></item><item><title>LeetCode 118. 杨辉三角</title><link>https://tategotoazarasi.github.io/post/pascals-triangle/</link><pubDate>Sun, 19 Dec 2021 13:19:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/pascals-triangle/</guid><description>&lt;p>给定一个非负整数  &lt;em>&lt;code>numRows&lt;/code>，&lt;/em> 生成「杨辉三角」的前  &lt;em>&lt;code>numRows&lt;/code>&lt;/em> 行。&lt;/p>
&lt;p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p></description></item><item><title>LeetCode 112. 路径总和</title><link>https://tategotoazarasi.github.io/post/path-sum/</link><pubDate>Sun, 19 Dec 2021 12:33:22 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/path-sum/</guid><description>&lt;p>给你二叉树的根节点  &lt;code>root&lt;/code> 和一个表示目标和的整数  &lt;code>targetSum&lt;/code> 。判断该树中是否存在 &lt;strong>根节点到叶子节点&lt;/strong> 的路径，这条路径上所有节点值相加等于目标和  &lt;code>targetSum&lt;/code> 。如果存在，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>叶子节点&lt;/strong> 是指没有子节点的节点。&lt;/p></description></item><item><title>LeetCode 111. 二叉树的最小深度</title><link>https://tategotoazarasi.github.io/post/minimum-depth-of-binary-tree/</link><pubDate>Thu, 16 Dec 2021 10:23:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-depth-of-binary-tree/</guid><description>&lt;p>给定一个二叉树，找出其最小深度。&lt;/p>
&lt;p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p></description></item><item><title>LeetCode 110. 平衡二叉树</title><link>https://tategotoazarasi.github.io/post/balanced-binary-tree/</link><pubDate>Thu, 16 Dec 2021 10:02:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/balanced-binary-tree/</guid><description>&lt;p>给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p>
&lt;p>本题中，一棵高度平衡二叉树定义为：&lt;/p>
&lt;blockquote>
&lt;p>一个二叉树&lt;em>每个节点&lt;/em> 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p>
&lt;/blockquote></description></item><item><title>LeetCode 108. 将有序数组转换为二叉搜索树</title><link>https://tategotoazarasi.github.io/post/convert-sorted-array-to-binary-search-tree/</link><pubDate>Wed, 15 Dec 2021 10:22:18 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/convert-sorted-array-to-binary-search-tree/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，其中元素已经按 &lt;strong>升序&lt;/strong> 排列，请你将其转换为一棵 &lt;strong>高度平衡&lt;/strong> 二叉搜索树。&lt;/p>
&lt;p>&lt;strong>高度平衡&lt;/strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。&lt;/p></description></item><item><title>LeetCode 104. 二叉树的最大深度</title><link>https://tategotoazarasi.github.io/post/maximum-depth-of-binary-tree/</link><pubDate>Wed, 15 Dec 2021 09:52:08 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-depth-of-binary-tree/</guid><description>&lt;p>给定一个二叉树，找出其最大深度。&lt;/p>
&lt;p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p></description></item><item><title>LeetCode 101. 对称二叉树</title><link>https://tategotoazarasi.github.io/post/symmetric-tree/</link><pubDate>Tue, 14 Dec 2021 10:23:43 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/symmetric-tree/</guid><description>&lt;p>给定一个二叉树，检查它是否是镜像对称的。&lt;/p></description></item><item><title>LeetCode 100. 相同的树</title><link>https://tategotoazarasi.github.io/post/same-tree/</link><pubDate>Tue, 14 Dec 2021 10:03:50 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/same-tree/</guid><description>&lt;p>给你两棵二叉树的根节点 &lt;code>p&lt;/code> 和 &lt;code>q&lt;/code> ，编写一个函数来检验这两棵树是否相同。&lt;/p>
&lt;p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p></description></item><item><title>LeetCode 94. 二叉树的中序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-inorder-traversal/</link><pubDate>Mon, 13 Dec 2021 10:43:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-inorder-traversal/</guid><description>&lt;p>给定一个二叉树的根节点 &lt;code>root&lt;/code> ，返回它的 &lt;strong>中序&lt;/strong>  遍历。&lt;/p></description></item><item><title>LeetCode 88. 合并两个有序数组</title><link>https://tategotoazarasi.github.io/post/merge-sorted-array/</link><pubDate>Mon, 13 Dec 2021 10:08:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/merge-sorted-array/</guid><description>&lt;p>给你两个按 &lt;strong>非递减顺序&lt;/strong> 排列的整数数组  &lt;code>nums1&lt;/code> 和 &lt;code>nums2&lt;/code>，另有两个整数 &lt;code>m&lt;/code> 和 &lt;code>n&lt;/code> ，分别表示 &lt;code>nums1&lt;/code> 和 &lt;code>nums2&lt;/code> 中的元素数目。&lt;/p>
&lt;p>请你 &lt;strong>合并&lt;/strong> &lt;code>nums2&lt;/code> 到 &lt;code>nums1&lt;/code> 中，使合并后的数组同样按 &lt;strong>非递减顺序&lt;/strong> 排列。&lt;/p></description></item><item><title>LeetCode 83. 删除排序链表中的重复元素</title><link>https://tategotoazarasi.github.io/post/remove-duplicates-from-sorted-list/</link><pubDate>Sun, 12 Dec 2021 17:09:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-duplicates-from-sorted-list/</guid><description>&lt;p>存在一个按升序排列的链表，给你这个链表的头节点 &lt;code>head&lt;/code> ，请你删除所有重复的元素，使每个元素 &lt;strong>只出现一次&lt;/strong> 。&lt;/p>
&lt;p>返回同样按升序排列的结果链表。&lt;/p></description></item><item><title>LeetCode 70. 爬楼梯</title><link>https://tategotoazarasi.github.io/post/climbing-stairs/</link><pubDate>Sun, 12 Dec 2021 16:51:18 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/climbing-stairs/</guid><description>&lt;p>假设你正在爬楼梯。需要 &lt;em>n&lt;/em>  阶你才能到达楼顶。&lt;/p>
&lt;p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p></description></item><item><title>LeetCode 69. Sqrt(x)</title><link>https://tategotoazarasi.github.io/post/sqrtx/</link><pubDate>Fri, 10 Dec 2021 11:13:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sqrtx/</guid><description>&lt;p>给你一个非负整数 &lt;code>x&lt;/code> ，计算并返回  &lt;code>x&lt;/code>  的 &lt;strong>算术平方根&lt;/strong> 。&lt;/p>
&lt;p>由于返回类型是整数，结果只保留 &lt;strong>整数部分&lt;/strong> ，小数部分将被 &lt;strong>舍去 。&lt;/strong>&lt;/p></description></item><item><title>LeetCode 67. 二进制求和</title><link>https://tategotoazarasi.github.io/post/add-binary/</link><pubDate>Fri, 10 Dec 2021 10:13:22 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/add-binary/</guid><description>&lt;p>给你两个二进制字符串，返回它们的和（用二进制表示）。&lt;/p>
&lt;p>输入为 &lt;strong>非空&lt;/strong> 字符串且只包含数字  &lt;code>1&lt;/code>  和  &lt;code>0&lt;/code>。&lt;/p></description></item><item><title>LeetCode 66. 加一</title><link>https://tategotoazarasi.github.io/post/plus-one/</link><pubDate>Thu, 09 Dec 2021 10:44:24 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/plus-one/</guid><description>&lt;p>给定一个由 &lt;strong>整数&lt;/strong> 组成的 &lt;strong>非空&lt;/strong> 数组所表示的非负整数，在该数的基础上加一。&lt;/p>
&lt;p>最高位数字存放在数组的首位， 数组中每个元素只存储&lt;strong>单个&lt;/strong>数字。&lt;/p>
&lt;p>你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p></description></item><item><title>LeetCode 58. 最后一个单词的长度</title><link>https://tategotoazarasi.github.io/post/length-of-last-word/</link><pubDate>Thu, 09 Dec 2021 10:27:22 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/length-of-last-word/</guid><description>&lt;p>给你一个字符串 &lt;code>s&lt;/code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。&lt;/p>
&lt;p>&lt;strong>单词&lt;/strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。&lt;/p></description></item><item><title>LeetCode 53. 最大子数组和</title><link>https://tategotoazarasi.github.io/post/maximum-subarray/</link><pubDate>Wed, 08 Dec 2021 10:12:55 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-subarray/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p></description></item><item><title>LeetCode 35. 搜索插入位置</title><link>https://tategotoazarasi.github.io/post/search-insert-position/</link><pubDate>Wed, 08 Dec 2021 09:29:58 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/search-insert-position/</guid><description>&lt;p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p>
&lt;p>请必须使用时间复杂度为 &lt;code>O(log n)&lt;/code> 的算法。&lt;/p></description></item><item><title>LeetCode 28. 实现 strStr()</title><link>https://tategotoazarasi.github.io/post/implement-strstr/</link><pubDate>Tue, 07 Dec 2021 10:17:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/implement-strstr/</guid><description>&lt;p>实现  &lt;a href="https://baike.baidu.com/item/strstr/811469">strStr()&lt;/a>  函数。&lt;/p>
&lt;p>给你两个字符串  &lt;code>haystack&lt;/code> 和 &lt;code>needle&lt;/code> ，请你在 &lt;code>haystack&lt;/code> 字符串中找出 &lt;code>needle&lt;/code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回   &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 27. 移除元素</title><link>https://tategotoazarasi.github.io/post/remove-element/</link><pubDate>Tue, 07 Dec 2021 09:33:30 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-element/</guid><description>&lt;p>给你一个数组 &lt;code>nums&lt;/code> 和一个值 &lt;code>val&lt;/code>，你需要 &lt;strong>&lt;a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地&lt;/a>&lt;/strong> 移除所有数值等于  &lt;code>val&lt;/code> 的元素，并返回移除后数组的新长度。&lt;/p>
&lt;p>不要使用额外的数组空间，你必须仅使用 &lt;code>O(1)&lt;/code> 额外空间并 &lt;strong>&lt;a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地&lt;/a> 修改输入数组&lt;/strong>。&lt;/p>
&lt;p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p></description></item><item><title>LeetCode 26. 删除有序数组中的重复项</title><link>https://tategotoazarasi.github.io/post/remove-duplicates-from-sorted-array/</link><pubDate>Mon, 06 Dec 2021 10:37:06 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-duplicates-from-sorted-array/</guid><description>&lt;p>给你一个有序数组 &lt;code>nums&lt;/code> ，请你 &lt;strong>&lt;a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地&lt;/a>&lt;/strong> 删除重复出现的元素，使每个元素 &lt;strong>只出现一次&lt;/strong> ，返回删除后数组的新长度。&lt;/p>
&lt;p>不要使用额外的数组空间，你必须在 &lt;strong>&lt;a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地&lt;/a>&lt;/strong> &lt;strong>修改输入数组&lt;/strong> 并在使用 O(1) 额外空间的条件下完成。&lt;/p></description></item><item><title>LeetCode 21. 合并两个有序链表</title><link>https://tategotoazarasi.github.io/post/merge-two-sorted-lists/</link><pubDate>Mon, 06 Dec 2021 08:53:47 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/merge-two-sorted-lists/</guid><description>&lt;p>将两个升序链表合并为一个新的 &lt;strong>升序&lt;/strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p></description></item><item><title>LeetCode 20. 有效的括号</title><link>https://tategotoazarasi.github.io/post/valid-parentheses/</link><pubDate>Sun, 05 Dec 2021 18:00:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/valid-parentheses/</guid><description>&lt;p>给定一个只包括 &lt;code>'('&lt;/code>，&lt;code>')'&lt;/code>，&lt;code>'{'&lt;/code>，&lt;code>'}'&lt;/code>，&lt;code>'['&lt;/code>，&lt;code>']'&lt;/code>  的字符串 &lt;code>s&lt;/code> ，判断字符串是否有效。&lt;/p>
&lt;p>有效字符串需满足：&lt;/p>
&lt;ol>
&lt;li>左括号必须用相同类型的右括号闭合。&lt;/li>
&lt;li>左括号必须以正确的顺序闭合。&lt;/li>
&lt;/ol></description></item><item><title>LeetCode 14. 最长公共前缀</title><link>https://tategotoazarasi.github.io/post/longest-common-prefix/</link><pubDate>Sun, 05 Dec 2021 17:39:18 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-common-prefix/</guid><description>&lt;p>编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p>
&lt;p>如果不存在公共前缀，返回空字符串  &lt;code>&amp;quot;&amp;quot;&lt;/code>。&lt;/p></description></item><item><title>LeetCode 13. 罗马数字转整数</title><link>https://tategotoazarasi.github.io/post/roman-to-integer/</link><pubDate>Sat, 04 Dec 2021 10:35:38 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/roman-to-integer/</guid><description>&lt;p>罗马数字包含以下七种字符: &lt;code>I&lt;/code>， &lt;code>V&lt;/code>， &lt;code>X&lt;/code>， &lt;code>L&lt;/code>，&lt;code>C&lt;/code>，&lt;code>D&lt;/code>  和  &lt;code>M&lt;/code>。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>字符&lt;/strong>&lt;/th>
&lt;th>&lt;strong>数值&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>I&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>V&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>L&lt;/td>
&lt;td>50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D&lt;/td>
&lt;td>500&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M&lt;/td>
&lt;td>1000&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例如， 罗马数字 &lt;code>2&lt;/code> 写做  &lt;code>II&lt;/code> ，即为两个并列的 1 。&lt;code>12&lt;/code> 写做  &lt;code>XII&lt;/code> ，即为  &lt;code>X&lt;/code> + &lt;code>II&lt;/code> 。 &lt;code>27&lt;/code> 写做   &lt;code>XXVII&lt;/code>, 即为  &lt;code>XX&lt;/code> + &lt;code>V&lt;/code> + &lt;code>II&lt;/code> 。&lt;/p>
&lt;p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做  &lt;code>IIII&lt;/code>，而是  &lt;code>IV&lt;/code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为  &lt;code>IX&lt;/code>。这个特殊的规则只适用于以下六种情况：&lt;/p>
&lt;ul>
&lt;li>&lt;code>I&lt;/code>  可以放在  &lt;code>V&lt;/code> (5) 和  &lt;code>X&lt;/code> (10) 的左边，来表示 4 和 9。&lt;/li>
&lt;li>&lt;code>X&lt;/code>  可以放在  &lt;code>L&lt;/code> (50) 和  &lt;code>C&lt;/code> (100) 的左边，来表示 40 和  90。&lt;/li>
&lt;li>&lt;code>C&lt;/code>  可以放在  &lt;code>D&lt;/code> (500) 和  &lt;code>M&lt;/code> (1000) 的左边，来表示  400 和  900。&lt;/li>
&lt;/ul>
&lt;p>给定一个罗马数字，将其转换成整数。&lt;/p></description></item><item><title>LeetCode 9. 回文数</title><link>https://tategotoazarasi.github.io/post/palindrome-number/</link><pubDate>Sat, 04 Dec 2021 10:03:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/palindrome-number/</guid><description>&lt;p>给你一个整数 &lt;code>x&lt;/code> ，如果 &lt;code>x&lt;/code> 是一个回文整数，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，&lt;code>121&lt;/code> 是回文，而 &lt;code>123&lt;/code> 不是。&lt;/p></description></item><item><title>LeetCode 7. 整数反转</title><link>https://tategotoazarasi.github.io/post/reverse-integer/</link><pubDate>Fri, 03 Dec 2021 08:29:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/reverse-integer/</guid><description>&lt;p>给你一个 32 位的有符号整数 &lt;code>x&lt;/code> ，返回将 &lt;code>x&lt;/code> 中的数字部分反转后的结果。&lt;/p>
&lt;p>如果反转后整数超过 32 位的有符号整数的范围  [\(-2^{31}\), \(2^{31}-1\)] ，就返回 0。&lt;/p></description></item><item><title>LeetCode 1. 两数之和</title><link>https://tategotoazarasi.github.io/post/two-sum/</link><pubDate>Thu, 02 Dec 2021 16:47:05 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/two-sum/</guid><description>&lt;p>给定一个整数数组 &lt;code>nums&lt;/code>  和一个整数目标值 &lt;code>target&lt;/code>，请你在该数组中找出 &lt;strong>和为目标值&lt;/strong> &lt;em>&lt;code>target&lt;/code>&lt;/em>  的那  &lt;strong>两个&lt;/strong>  整数，并返回它们的数组下标。&lt;/p>
&lt;p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p>
&lt;p>你可以按任意顺序返回答案。&lt;/p></description></item></channel></rss>