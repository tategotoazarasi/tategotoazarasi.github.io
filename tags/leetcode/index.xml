<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>leetcode on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/leetcode/</link><description>Recent content in leetcode on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 01 Feb 2022 19:52:49 +0800</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 1763. 最长的美好子字符串</title><link>https://tategotoazarasi.github.io/post/longest-nice-substring/</link><pubDate>Tue, 01 Feb 2022 19:52:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-nice-substring/</guid><description>&lt;p>当一个字符串 &lt;code>s&lt;/code>  包含的每一种字母的大写和小写形式 &lt;strong>同时&lt;/strong>  出现在 &lt;code>s&lt;/code>  中，就称这个字符串  &lt;code>s&lt;/code>  是 &lt;strong>美好&lt;/strong> 字符串。比方说，&lt;code>&amp;quot;abABB&amp;quot;&lt;/code>  是美好字符串，因为  &lt;code>'A'&lt;/code> 和  &lt;code>'a'&lt;/code>  同时出现了，且  &lt;code>'B'&lt;/code> 和  &lt;code>'b'&lt;/code>  也同时出现了。然而，&lt;code>&amp;quot;abA&amp;quot;&lt;/code>  不是美好字符串因为  &lt;code>'b'&lt;/code>  出现了，而  &lt;code>'B'&lt;/code>  没有出现。&lt;/p>
&lt;p>给你一个字符串  &lt;code>s&lt;/code> ，请你返回  &lt;code>s&lt;/code>  最长的  &lt;strong>美好子字符串&lt;/strong> 。如果有多个答案，请你返回  &lt;strong>最早&lt;/strong>  出现的一个。如果不存在美好子字符串，请你返回一个空字符串。&lt;/p></description></item><item><title>LeetCode 5995. 字符串分组</title><link>https://tategotoazarasi.github.io/post/groups-of-strings/</link><pubDate>Sun, 30 Jan 2022 16:22:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/groups-of-strings/</guid><description>&lt;p>给你一个下标从  &lt;strong>0&lt;/strong> 开始的字符串数组  &lt;code>words&lt;/code> 。每个字符串都只包含 &lt;strong>小写英文字母&lt;/strong> 。&lt;code>words&lt;/code>  中任意一个子串中，每个字母都至多只出现一次。&lt;/p>
&lt;p>如果通过以下操作之一，我们可以从 &lt;code>s1&lt;/code>  的字母集合得到 &lt;code>s2&lt;/code>  的字母集合，那么我们称这两个字符串为 &lt;strong>关联的&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>往  &lt;code>s1&lt;/code>  的字母集合中添加一个字母。&lt;/li>
&lt;li>从  &lt;code>s1&lt;/code>  的字母集合中删去一个字母。&lt;/li>
&lt;li>将 &lt;code>s1&lt;/code>  中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。&lt;/li>
&lt;/ul>
&lt;p>数组  &lt;code>words&lt;/code>  可以分为一个或者多个无交集的 &lt;strong>组&lt;/strong> 。一个字符串与一个组如果满足以下 &lt;strong>任一&lt;/strong>  条件，它就属于这个组：&lt;/p>
&lt;ul>
&lt;li>它与组内 &lt;strong>至少&lt;/strong>  一个其他字符串关联。&lt;/li>
&lt;li>它是这个组中 &lt;strong>唯一&lt;/strong>  的字符串。&lt;/li>
&lt;/ul>
&lt;p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。&lt;/p>
&lt;p>请你返回一个长度为 &lt;code>2&lt;/code>  的数组  &lt;code>ans&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ans[0]&lt;/code>  是  &lt;code>words&lt;/code>  分组后的  &lt;strong>总组数&lt;/strong> 。&lt;/li>
&lt;li>&lt;code>ans[1]&lt;/code>  是字符串数目最多的组所包含的字符串数目。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 176. 第二高的薪水</title><link>https://tategotoazarasi.github.io/post/second-highest-salary/</link><pubDate>Sat, 29 Jan 2022 10:28:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/second-highest-salary/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="k">Create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">If&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Exists&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">Truncate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;100&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;200&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;3&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;300&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Employee&lt;/code> 表：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>salary&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>id 是这个表的主键。
表的每一行包含员工的工资信息。&lt;/p>
&lt;p>编写一个 SQL 查询，获取并返回 &lt;code>Employee&lt;/code>  表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 &lt;code>null&lt;/code> 。&lt;/p>
&lt;p>查询结果如下例所示。&lt;/p></description></item><item><title>LeetCode 1996. 游戏中弱角色的数量</title><link>https://tategotoazarasi.github.io/post/the-number-of-weak-characters-in-the-game/</link><pubDate>Fri, 28 Jan 2022 10:27:51 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-weak-characters-in-the-game/</guid><description>&lt;p>你正在参加一个多角色游戏，每个角色都有两个主要属性：&lt;strong>攻击&lt;/strong> 和 &lt;strong>防御&lt;/strong> 。给你一个二维整数数组 &lt;code>properties&lt;/code> ，其中 \(properties[i] = [attack_i, defense_i]\) 表示游戏中第 &lt;code>i&lt;/code> 个角色的属性。&lt;/p>
&lt;p>如果存在一个其他角色的攻击和防御等级 &lt;strong>都严格高于&lt;/strong> 该角色的攻击和防御等级，则认为该角色为 &lt;strong>弱角色&lt;/strong> 。更正式地，如果认为角色 &lt;code>i&lt;/code> &lt;strong>弱于&lt;/strong> 存在的另一个角色 &lt;code>j&lt;/code> ，那么 \(attack_j &amp;gt; attack_i\) 且 \(defense_j &amp;gt; defense_i\) 。&lt;/p>
&lt;p>返回 &lt;strong>弱角色&lt;/strong> 的数量。&lt;/p></description></item><item><title>LeetCode 5983. 同时运行 N 台电脑的最长时间</title><link>https://tategotoazarasi.github.io/post/maximum-running-time-of-n-computers/</link><pubDate>Sun, 16 Jan 2022 12:20:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-running-time-of-n-computers/</guid><description>&lt;p>你有  &lt;code>n&lt;/code>  台电脑。给你整数  &lt;code>n&lt;/code>  和一个下标从 &lt;strong>0&lt;/strong>  开始的整数数组  &lt;code>batteries&lt;/code> ，其中第  &lt;code>i&lt;/code>  个电池可以让一台电脑 &lt;strong>运行&lt;/strong> &lt;code>batteries[i]&lt;/code>  分钟。你想使用这些电池让  &lt;strong>全部&lt;/strong> &lt;code>n&lt;/code>  台电脑 &lt;strong>同时&lt;/strong>  运行。&lt;/p>
&lt;p>一开始，你可以给每台电脑连接 &lt;strong>至多一个电池&lt;/strong> 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 &lt;strong>任意次&lt;/strong> 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。&lt;/p>
&lt;p>注意，你不能给电池充电。&lt;/p>
&lt;p>请你返回你可以让 &lt;code>n&lt;/code>  台电脑同时运行的 &lt;strong>最长&lt;/strong>  分钟数。&lt;/p></description></item><item><title>LeetCode 5982. 解决智力问题</title><link>https://tategotoazarasi.github.io/post/solving-questions-with-brainpower/</link><pubDate>Sun, 16 Jan 2022 12:19:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/solving-questions-with-brainpower/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong>  开始的二维整数数组  &lt;code>questions&lt;/code> ，其中 \(questions[i] = [points_i, brainpower_i]\)。&lt;/p>
&lt;p>这个数组表示一场考试里的一系列题目，你需要 &lt;strong>按顺序&lt;/strong> （也就是从问题 &lt;code>0&lt;/code> 开始依次解决），针对每个问题选择 &lt;strong>解决&lt;/strong>  或者 &lt;strong>跳过&lt;/strong>  操作。解决问题 &lt;code>i&lt;/code>  将让你 &lt;strong>获得&lt;/strong> \(points_i\) 的分数，但是你将 &lt;strong>无法&lt;/strong>  解决接下来的 \(brainpower_i\) 个问题（即只能跳过接下来的 \(brainpower_i\) 个问题）。如果你跳过问题  &lt;code>i&lt;/code> ，你可以对下一个问题决定使用哪种操作。&lt;/p>
&lt;ul>
&lt;li>比方说，给你  &lt;code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]&lt;/code> ：
&lt;ul>
&lt;li>如果问题  &lt;code>0&lt;/code>  被解决了， 那么你可以获得  &lt;code>3&lt;/code>  分，但你不能解决问题  &lt;code>1&lt;/code> 和  &lt;code>2&lt;/code> 。&lt;/li>
&lt;li>如果你跳过问题  &lt;code>0&lt;/code> ，且解决问题  &lt;code>1&lt;/code> ，你将获得 &lt;code>4&lt;/code> 分但是不能解决问题  &lt;code>2&lt;/code> 和  &lt;code>3&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>请你返回这场考试里你能获得的 &lt;strong>最高&lt;/strong>  分数。&lt;/p></description></item><item><title>LeetCode 382. 链表随机节点</title><link>https://tategotoazarasi.github.io/post/linked-list-random-node/</link><pubDate>Sun, 16 Jan 2022 10:00:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/linked-list-random-node/</guid><description>&lt;p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 &lt;strong>被选中的概率一样&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 1036. 逃离大迷宫</title><link>https://tategotoazarasi.github.io/post/escape-a-large-maze/</link><pubDate>Tue, 11 Jan 2022 16:08:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/escape-a-large-maze/</guid><description>&lt;p>在一个 \(10^6 \times 10^6\) 的网格中，每个网格上方格的坐标为 &lt;code>(x, y)&lt;/code> 。&lt;/p>
&lt;p>现在从源方格 \(source = [s_x, s_y]\) 开始出发，意图赶往目标方格 \(target = [t_x, t_y]\) 。数组 &lt;code>blocked&lt;/code> 是封锁的方格列表，其中每个 \(blocked[i] = [x_i, y_i]\) 表示坐标为 \((x_i, y_i)\) 的方格是禁止通行的。&lt;/p>
&lt;p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 &lt;strong>不&lt;/strong> 在给出的封锁列表 &lt;code>blocked&lt;/code> 上。同时，不允许走出网格。&lt;/p>
&lt;p>只有在可以通过一系列的移动从源方格 &lt;code>source&lt;/code> 到达目标方格 &lt;code>target&lt;/code> 时才返回 &lt;code>true&lt;/code>。否则，返回 &lt;code>false&lt;/code>。&lt;/p></description></item><item><title>LeetCode 5978. 统计追加字母可以获得的单词数</title><link>https://tategotoazarasi.github.io/post/count-words-obtained-after-adding-a-letter/</link><pubDate>Sun, 09 Jan 2022 18:43:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-words-obtained-after-adding-a-letter/</guid><description>&lt;p>给你两个下标从 &lt;strong>0&lt;/strong> 开始的字符串数组 &lt;code>startWords&lt;/code> 和 &lt;code>targetWords&lt;/code> 。每个字符串都仅由 &lt;strong>小写英文字母&lt;/strong> 组成。&lt;/p>
&lt;p>对于 &lt;code>targetWords&lt;/code> 中的每个字符串，检查是否能够从 &lt;code>startWords&lt;/code> 中选出一个字符串，执行一次 &lt;strong>转换操作&lt;/strong> ，得到的结果与当前  &lt;code>targetWords&lt;/code> 字符串相等。&lt;/p>
&lt;p>&lt;strong>转换操作&lt;/strong> 如下面两步所述：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>追加&lt;/strong> 任何 &lt;strong>不存在&lt;/strong> 于当前字符串的任一小写字母到当前字符串的末尾。
&lt;ul>
&lt;li>例如，如果字符串为 &lt;code>&amp;quot;abc&amp;quot;&lt;/code> ，那么字母 &lt;code>'d'&lt;/code>、&lt;code>'e'&lt;/code> 或 &lt;code>'y'&lt;/code> 都可以加到该字符串末尾，但 &lt;code>'a'&lt;/code> 就不行。如果追加的是 &lt;code>'d'&lt;/code> ，那么结果字符串为 &lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>重排&lt;/strong> 新字符串中的字母，可以按 &lt;strong>任意&lt;/strong> 顺序重新排布字母。
&lt;ul>
&lt;li>例如，&lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 可以重排为 &lt;code>&amp;quot;acbd&amp;quot;&lt;/code>、&lt;code>&amp;quot;bacd&amp;quot;&lt;/code>、&lt;code>&amp;quot;cbda&amp;quot;&lt;/code>，以此类推。注意，它也可以重排为 &lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 自身。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>找出 &lt;code>targetWords&lt;/code> 中有多少字符串能够由  &lt;code>startWords&lt;/code> 中的 &lt;strong>任一&lt;/strong> 字符串执行上述转换操作获得。返回 &lt;code>targetWords&lt;/code> 中这类 &lt;strong>字符串的数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 89. 格雷编码</title><link>https://tategotoazarasi.github.io/post/gray-code/</link><pubDate>Sat, 08 Jan 2022 16:57:11 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/gray-code/</guid><description>&lt;p>&lt;strong>n 位格雷码序列&lt;/strong> 是一个由 &lt;code>2n&lt;/code> 个整数组成的序列，其中：&lt;/p>
&lt;ul>
&lt;li>每个整数都在范围 &lt;code>[0, 2n - 1]&lt;/code> 内（含 &lt;code>0&lt;/code> 和 &lt;code>2n - 1&lt;/code>）&lt;/li>
&lt;li>第一个整数是 &lt;code>0&lt;/code>&lt;/li>
&lt;li>一个整数在序列中出现 &lt;strong>不超过一次&lt;/strong>&lt;/li>
&lt;li>每对 &lt;strong>相邻&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong> ，且&lt;/li>
&lt;li>&lt;strong>第一个&lt;/strong> 和 &lt;strong>最后一个&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，返回任一有效的 &lt;strong>n 位格雷码序列&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 913. 猫和老鼠</title><link>https://tategotoazarasi.github.io/post/cat-and-mouse/</link><pubDate>Tue, 04 Jan 2022 22:08:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/cat-and-mouse/</guid><description>&lt;p>两位玩家分别扮演猫和老鼠，在一张 &lt;strong>无向&lt;/strong> 图上进行游戏，两人轮流行动。&lt;/p>
&lt;p>图的形式是：&lt;code>graph[a]&lt;/code> 是一个列表，由满足 &lt;code>ab&lt;/code> 是图中的一条边的所有节点 &lt;code>b&lt;/code> 组成。&lt;/p>
&lt;p>老鼠从节点 &lt;code>1&lt;/code> 开始，第一个出发；猫从节点 &lt;code>2&lt;/code> 开始，第二个出发。在节点 &lt;code>0&lt;/code> 处有一个洞。&lt;/p>
&lt;p>在每个玩家的行动中，他们 &lt;strong>必须&lt;/strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 &lt;code>1&lt;/code> ，那么它必须移动到 &lt;code>graph[1]&lt;/code> 中的任一节点。&lt;/p>
&lt;p>此外，猫无法移动到洞中（节点 &lt;code>0&lt;/code>）。&lt;/p>
&lt;p>然后，游戏在出现以下三种情形之一时结束：&lt;/p>
&lt;ul>
&lt;li>如果猫和老鼠出现在同一个节点，猫获胜。&lt;/li>
&lt;li>如果老鼠到达洞中，老鼠获胜。&lt;/li>
&lt;li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。&lt;/li>
&lt;/ul>
&lt;p>给你一张图 &lt;code>graph&lt;/code> ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p>
&lt;ul>
&lt;li>如果老鼠获胜，则返回 &lt;code>1&lt;/code>；&lt;/li>
&lt;li>如果猫获胜，则返回 &lt;code>2&lt;/code>；&lt;/li>
&lt;li>如果平局，则返回 &lt;code>0&lt;/code> 。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5970. 参加会议的最多员工数</title><link>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</link><pubDate>Sun, 02 Jan 2022 17:24:01 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</guid><description>&lt;p>一个公司准备组织一场会议，邀请名单上有  &lt;code>n&lt;/code>  位员工。公司准备了一张 &lt;strong>圆形&lt;/strong>  的桌子，可以坐下 &lt;strong>任意数目&lt;/strong>  的员工。&lt;/p>
&lt;p>员工编号为 &lt;code>0&lt;/code>  到 &lt;code>n - 1&lt;/code> 。每位员工都有一位 &lt;strong>喜欢&lt;/strong>  的员工，每位员工  &lt;strong>当且仅当&lt;/strong>  他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 &lt;strong>不会&lt;/strong>  是他自己。&lt;/p>
&lt;p>给你一个下标从 &lt;strong>0&lt;/strong>  开始的整数数组  &lt;code>favorite&lt;/code> ，其中  &lt;code>favorite[i]&lt;/code>  表示第  &lt;code>i&lt;/code>  位员工喜欢的员工。请你返回参加会议的  &lt;strong>最多员工数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 390. 消除游戏</title><link>https://tategotoazarasi.github.io/post/elimination-game/</link><pubDate>Sun, 02 Jan 2022 17:04:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/elimination-game/</guid><description>&lt;p>给定一个从 1 到 n 排序的整数列表。&lt;br>
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。&lt;br>
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。&lt;br>
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。&lt;br>
返回长度为 n 的列表中，最后剩下的数字。&lt;/p></description></item><item><title>LeetCode 538. 把二叉搜索树转换为累加树</title><link>https://tategotoazarasi.github.io/post/convert-bst-to-greater-tree/</link><pubDate>Fri, 31 Dec 2021 11:55:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/convert-bst-to-greater-tree/</guid><description>&lt;p>给出二叉 &lt;strong>搜索&lt;/strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 &lt;code>node&lt;/code>  的新值等于原树中大于或等于  &lt;code>node.val&lt;/code>  的值之和。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item><item><title>LeetCode 5965. 相同元素的间隔之和</title><link>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</link><pubDate>Sun, 26 Dec 2021 15:11:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、由 &lt;code>n&lt;/code> 个整数组成的数组 &lt;code>arr&lt;/code> 。&lt;/p>
&lt;p>&lt;code>arr&lt;/code> 中两个元素的 &lt;strong>间隔&lt;/strong> 定义为它们下标之间的 &lt;strong>绝对差&lt;/strong> 。更正式地，&lt;code>arr[i]&lt;/code> 和 &lt;code>arr[j]&lt;/code> 之间的间隔是 &lt;code>|i - j|&lt;/code> 。&lt;/p>
&lt;p>返回一个长度为 &lt;code>n&lt;/code> 的数组  &lt;code>intervals&lt;/code> ，其中 &lt;code>intervals[i]&lt;/code> 是 &lt;code>arr[i]&lt;/code> 和 &lt;code>arr&lt;/code> 中每个相同元素（与 &lt;code>arr[i]&lt;/code> 的值相同）的 &lt;strong>间隔之和&lt;/strong> &lt;em>。&lt;/em>&lt;/p></description></item><item><title>LeetCode 5948. 判断一个括号字符串是否有效</title><link>https://tategotoazarasi.github.io/post/check-if-a-parentheses-string-can-be-valid/</link><pubDate>Sun, 26 Dec 2021 09:22:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/check-if-a-parentheses-string-can-be-valid/</guid><description>&lt;p>一个括号字符串是只由  &lt;code>'('&lt;/code> 和  &lt;code>')'&lt;/code>  组成的  &lt;strong>非空&lt;/strong>  字符串。如果一个字符串满足下面 &lt;strong>任意&lt;/strong>  一个条件，那么它就是有效的：&lt;/p>
&lt;ul>
&lt;li>字符串为  &lt;code>()&lt;/code>.&lt;/li>
&lt;li>它可以表示为 &lt;code>AB&lt;/code>（&lt;code>A&lt;/code>  与  &lt;code>B&lt;/code>  连接），其中&lt;code>A&lt;/code> 和  &lt;code>B&lt;/code>  都是有效括号字符串。&lt;/li>
&lt;li>它可以表示为  &lt;code>(A)&lt;/code> ，其中  &lt;code>A&lt;/code>  是一个有效括号字符串。&lt;/li>
&lt;/ul>
&lt;p>给你一个括号字符串  &lt;code>s&lt;/code>  和一个字符串  &lt;code>locked&lt;/code> ，两者长度都为  &lt;code>n&lt;/code> 。&lt;code>locked&lt;/code>  是一个二进制字符串，只包含  &lt;code>'0'&lt;/code>  和  &lt;code>'1'&lt;/code> 。对于  &lt;code>locked&lt;/code>  中  &lt;strong>每一个&lt;/strong>  下标  &lt;code>i&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>如果  &lt;code>locked[i]&lt;/code>  是  &lt;code>'1'&lt;/code> ，你 &lt;strong>不能&lt;/strong>  改变  &lt;code>s[i]&lt;/code> 。&lt;/li>
&lt;li>如果  &lt;code>locked[i]&lt;/code>  是  &lt;code>'0'&lt;/code> ，你  &lt;strong>可以&lt;/strong>  将  &lt;code>s[i]&lt;/code>  变为  &lt;code>'('&lt;/code>  或者  &lt;code>')'&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>如果你可以将 &lt;code>s&lt;/code>  变为有效括号字符串，请你返回  &lt;code>true&lt;/code> ，否则返回  &lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 168. Excel表列名称</title><link>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</link><pubDate>Sat, 25 Dec 2021 10:33:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</guid><description>&lt;p>给你一个整数 &lt;code>columnNumber&lt;/code> ，返回它在 Excel 表中相对应的列名称。&lt;/p></description></item><item><title>LeetCode 160. 相交链表</title><link>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</link><pubDate>Fri, 24 Dec 2021 08:29:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</guid><description>&lt;p>给你两个单链表的头节点  &lt;code>headA&lt;/code> 和 &lt;code>headB&lt;/code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code>null&lt;/code> 。&lt;/p>
&lt;p>图示两个链表在节点 &lt;code>c1&lt;/code> 开始相交 &lt;strong>：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tategotoazarasi.github.io/images/160_statement.png" alt="">&lt;/p>
&lt;p>题目数据 &lt;strong>保证&lt;/strong> 整个链式结构中不存在环。&lt;/p></description></item><item><title>LeetCode 119. 杨辉三角 II</title><link>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</link><pubDate>Mon, 20 Dec 2021 11:13:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</guid><description>&lt;p>给定一个非负索引 &lt;code>rowIndex&lt;/code>，返回「杨辉三角」的第 &lt;code>rowIndex&lt;/code> 行。&lt;/p>
&lt;p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p></description></item><item><title>LeetCode 28. 实现 strStr()</title><link>https://tategotoazarasi.github.io/post/implement-strstr/</link><pubDate>Tue, 07 Dec 2021 10:17:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/implement-strstr/</guid><description>&lt;p>实现 &lt;a href="https://baike.baidu.com/item/strstr/811469">strStr()&lt;/a> 函数。&lt;/p>
&lt;p>给你两个字符串 &lt;code>haystack&lt;/code> 和 &lt;code>needle&lt;/code> ，请你在 &lt;code>haystack&lt;/code> 字符串中找出 &lt;code>needle&lt;/code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item></channel></rss>