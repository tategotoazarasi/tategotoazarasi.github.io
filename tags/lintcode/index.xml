<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lintcode on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/lintcode/</link><description>Recent content in lintcode on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 08 Jan 2022 16:57:28 +0800</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/lintcode/index.xml" rel="self" type="application/rss+xml"/><item><title>LintCode 295. 交集</title><link>https://tategotoazarasi.github.io/post/intersection/</link><pubDate>Sat, 08 Jan 2022 16:57:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intersection/</guid><description>描述 给定两个排序后的区间序列，序列内每个区间两两互不相交，返回两个序列相交的区间的下标
1&amp;lt;=len(a),len(b)&amp;lt;=1e5 abs(max(a))&amp;lt;=1e9 样例 输入: a = [[0,3], [7,10]] , b = [[-1,1],[2,8]] 输出: ans = [[0,0],[0,1],[1,1]] bool is_intersected(const vector&amp;lt;int&amp;gt; &amp;amp;l, const vector&amp;lt;int&amp;gt; &amp;amp;r) { if(l[0] == r[0]) return true; else if(l[0] &amp;lt; r[0]) return r[0] &amp;lt;= l[1]; else return l[0] &amp;lt;= r[1]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; Intersection(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;a, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;b) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if(a.empty() || b.empty()) return res; for(int i = 0, j = 0; i &amp;lt; a.size() &amp;amp;&amp;amp; j &amp;lt; b.</description></item></channel></rss>