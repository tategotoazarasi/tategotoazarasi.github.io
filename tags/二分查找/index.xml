<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>二分查找 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><description>Recent content in 二分查找 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 09 Sep 2024 08:25:13 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 862. 和至少为 K 的最短子数组</title><link>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 21 Dec 2022 21:15:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，找出 &lt;code>nums&lt;/code> 中和至少为 &lt;code>k&lt;/code> 的
&lt;strong>最短非空子数组&lt;/strong> ，并返回该子数组的长度。如果不存在这样的 &lt;strong>子数组&lt;/strong>
，返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 456. 132 模式</title><link>https://tategotoazarasi.github.io/post/132-pattern/</link><pubDate>Wed, 21 Dec 2022 18:14:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/132-pattern/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，数组中共有 &lt;code>n&lt;/code> 个整数。&lt;strong>132 模式的子序列&lt;/strong>由三个整数 &lt;code>nums[i]&lt;/code>、&lt;code>nums[j]&lt;/code> 和 &lt;code>nums[k]&lt;/code>组成，并同时满足：&lt;code>i &amp;lt; j &amp;lt; k&lt;/code> 和 &lt;code>nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code> 。&lt;/p>
&lt;p>如果 &lt;code>nums&lt;/code> 中存在 &lt;strong>132 模式的子序列&lt;/strong> ，返回 &lt;code>true&lt;/code> ；否则，返回&lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 315. 计算右侧小于当前元素的个数</title><link>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</link><pubDate>Wed, 07 Sep 2022 13:47:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，按要求返回一个新数组  &lt;code>counts&lt;/code> 。数组 &lt;code>counts&lt;/code> 有该性质： &lt;code>counts[i]&lt;/code> 的值是   &lt;code>nums[i]&lt;/code> 右侧小于  &lt;code>nums[i]&lt;/code> 的元素的数量。&lt;/p></description></item><item><title>LeetCode 4. 寻找两个正序数组的中位数</title><link>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</link><pubDate>Wed, 07 Sep 2022 13:12:36 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</guid><description>&lt;p>给定两个大小分别为 &lt;code>m&lt;/code> 和 &lt;code>n&lt;/code> 的正序（从小到大）数组  &lt;code>nums1&lt;/code> 和  &lt;code>nums2&lt;/code>。请你找出并返回这两个正序数组的 &lt;strong>中位数&lt;/strong> 。&lt;/p>
&lt;p>算法的时间复杂度应该为 &lt;code>O(log (m+n))&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 1231. 分享巧克力</title><link>https://tategotoazarasi.github.io/post/divide-chocolate/</link><pubDate>Thu, 25 Aug 2022 16:59:33 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/divide-chocolate/</guid><description>&lt;p>你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组  &lt;code>sweetness&lt;/code>  来表示每一小块的甜度。&lt;/p>
&lt;p>你打算和  &lt;code>K&lt;/code>  名朋友一起分享这块巧克力，所以你需要将切割  &lt;code>K&lt;/code>  次才能得到&lt;code>K+1&lt;/code>  块，每一块都由一些 &lt;strong>连续&lt;/strong>的小块组成。&lt;/p>
&lt;p>为了表现出你的慷慨，你将会吃掉  &lt;strong>总甜度最小&lt;/strong>的一块，并将其余几块分给你的朋友们。&lt;/p>
&lt;p>请找出一个最佳的切割策略，使得你所分得的巧克力  &lt;strong>总甜度最大&lt;/strong>，并返回这个&lt;strong>最大总甜度&lt;/strong>。&lt;/p></description></item><item><title>LeetCode 162. Find Peak Element</title><link>https://tategotoazarasi.github.io/post/find-peak-element/</link><pubDate>Fri, 27 May 2022 12:47:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/find-peak-element/</guid><description>&lt;p>A peak element is an element that is strictly greater than its neighbors.&lt;/p>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to &lt;strong>any of the peaks&lt;/strong>.&lt;/p>
&lt;p>You may imagine that &lt;code>nums[-1] = nums[n] = -∞&lt;/code>.&lt;/p>
&lt;p>You must write an algorithm that runs in &lt;code>O(log n)&lt;/code> time.&lt;/p></description></item></channel></rss>