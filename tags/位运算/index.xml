<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>位运算 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/</link><description>Recent content in 位运算 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 07 Jun 2024 09:41:10 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 995. K 连续位的最小翻转次数</title><link>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</link><pubDate>Mon, 19 Sep 2022 18:54:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</guid><description>&lt;p>给定一个二进制数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>k 位翻转&lt;/strong> 就是从 &lt;code>nums&lt;/code> 中选择一个长度为 &lt;code>k&lt;/code> 的 &lt;strong>子数组&lt;/strong>，同时把子数组中的每一个 &lt;code>0&lt;/code> 都改成 &lt;code>1&lt;/code> ，把子数组中的每一个 &lt;code>1&lt;/code> 都改成&lt;code>0&lt;/code> 。&lt;/p>
&lt;p>返回数组中不存在 &lt;code>0&lt;/code> 所需的最小 &lt;strong>k 位翻转&lt;/strong>次数。如果不可能，则返回  &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 260. 只出现一次的数字 III</title><link>https://tategotoazarasi.github.io/post/single-number-iii/</link><pubDate>Mon, 19 Sep 2022 16:22:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/single-number-iii/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p></description></item><item><title>LeetCode 29. Divide Two Integers</title><link>https://tategotoazarasi.github.io/post/divide-two-integers/</link><pubDate>Tue, 21 Jun 2022 15:53:24 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/divide-two-integers/</guid><description>&lt;p>Given two integers &lt;code>dividend&lt;/code> and &lt;code>divisor&lt;/code>, divide two integers &lt;strong>without&lt;/strong> using multiplication, division, and mod operator.&lt;/p>
&lt;p>The integer division should truncate toward zero, which means losing its fractional part. For example, &lt;code>8.345&lt;/code> would be truncated to &lt;code>8&lt;/code>, and &lt;code>-2.7335&lt;/code> would be truncated to &lt;code>-2&lt;/code>.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>quotient&lt;/strong> after dividing&lt;/em> &lt;code>dividend&lt;/code> &lt;em>by&lt;/em> &lt;code>divisor&lt;/code>.&lt;/p></description></item><item><title>LeetCode 1994. 好子集的数目</title><link>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</link><pubDate>Tue, 22 Feb 2022 09:23:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code> 。如果  &lt;code>nums&lt;/code>  的一个子集中，所有元素的乘积可以表示为一个或多个 &lt;strong>互不相同的质数&lt;/strong> 的乘积，那么我们称它为  &lt;strong>好子集&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>比方说，如果  &lt;code>nums = [1, 2, 3, 4]&lt;/code> ：
&lt;ul>
&lt;li>&lt;code>[2, 3]&lt;/code> ，&lt;code>[1, 2, 3]&lt;/code>  和  &lt;code>[1, 3]&lt;/code>  是 &lt;strong>好&lt;/strong>  子集，乘积分别为  &lt;code>6 = 2*3&lt;/code> ，&lt;code>6 = 2*3&lt;/code>  和  &lt;code>3 = 3&lt;/code> 。&lt;/li>
&lt;li>&lt;code>[1, 4]&lt;/code> 和  &lt;code>[4]&lt;/code>  不是 &lt;strong>好&lt;/strong>  子集，因为乘积分别为  &lt;code>4 = 2*2&lt;/code> 和  &lt;code>4 = 2*2&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>请你返回 &lt;code>nums&lt;/code>  中不同的  &lt;strong>好&lt;/strong>  子集的数目对 &lt;code>109 + 7&lt;/code> &lt;strong>取余&lt;/strong>  的结果。&lt;/p>
&lt;p>&lt;code>nums&lt;/code>  中的 &lt;strong>子集&lt;/strong>  是通过删除 &lt;code>nums&lt;/code>  中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。&lt;/p></description></item><item><title>LeetCode 1763. 最长的美好子字符串</title><link>https://tategotoazarasi.github.io/post/longest-nice-substring/</link><pubDate>Tue, 01 Feb 2022 19:52:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-nice-substring/</guid><description>&lt;p>当一个字符串 &lt;code>s&lt;/code>  包含的每一种字母的大写和小写形式 &lt;strong>同时&lt;/strong>  出现在 &lt;code>s&lt;/code>  中，就称这个字符串  &lt;code>s&lt;/code>  是 &lt;strong>美好&lt;/strong> 字符串。比方说，&lt;code>&amp;quot;abABB&amp;quot;&lt;/code>  是美好字符串，因为  &lt;code>'A'&lt;/code> 和  &lt;code>'a'&lt;/code>  同时出现了，且  &lt;code>'B'&lt;/code> 和  &lt;code>'b'&lt;/code>  也同时出现了。然而，&lt;code>&amp;quot;abA&amp;quot;&lt;/code>  不是美好字符串因为  &lt;code>'b'&lt;/code>  出现了，而  &lt;code>'B'&lt;/code>  没有出现。&lt;/p>
&lt;p>给你一个字符串  &lt;code>s&lt;/code> ，请你返回  &lt;code>s&lt;/code>  最长的  &lt;strong>美好子字符串&lt;/strong> 。如果有多个答案，请你返回  &lt;strong>最早&lt;/strong>  出现的一个。如果不存在美好子字符串，请你返回一个空字符串。&lt;/p></description></item><item><title>LeetCode 5995. 字符串分组</title><link>https://tategotoazarasi.github.io/post/groups-of-strings/</link><pubDate>Sun, 30 Jan 2022 16:22:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/groups-of-strings/</guid><description>&lt;p>给你一个下标从  &lt;strong>0&lt;/strong> 开始的字符串数组  &lt;code>words&lt;/code> 。每个字符串都只包含 &lt;strong>小写英文字母&lt;/strong> 。&lt;code>words&lt;/code>  中任意一个子串中，每个字母都至多只出现一次。&lt;/p>
&lt;p>如果通过以下操作之一，我们可以从 &lt;code>s1&lt;/code>  的字母集合得到 &lt;code>s2&lt;/code>  的字母集合，那么我们称这两个字符串为 &lt;strong>关联的&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>往  &lt;code>s1&lt;/code>  的字母集合中添加一个字母。&lt;/li>
&lt;li>从  &lt;code>s1&lt;/code>  的字母集合中删去一个字母。&lt;/li>
&lt;li>将 &lt;code>s1&lt;/code>  中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。&lt;/li>
&lt;/ul>
&lt;p>数组  &lt;code>words&lt;/code>  可以分为一个或者多个无交集的 &lt;strong>组&lt;/strong> 。一个字符串与一个组如果满足以下 &lt;strong>任一&lt;/strong>  条件，它就属于这个组：&lt;/p>
&lt;ul>
&lt;li>它与组内 &lt;strong>至少&lt;/strong>  一个其他字符串关联。&lt;/li>
&lt;li>它是这个组中 &lt;strong>唯一&lt;/strong>  的字符串。&lt;/li>
&lt;/ul>
&lt;p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。&lt;/p>
&lt;p>请你返回一个长度为 &lt;code>2&lt;/code>  的数组  &lt;code>ans&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ans[0]&lt;/code>  是  &lt;code>words&lt;/code>  分组后的  &lt;strong>总组数&lt;/strong> 。&lt;/li>
&lt;li>&lt;code>ans[1]&lt;/code>  是字符串数目最多的组所包含的字符串数目。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5978. 统计追加字母可以获得的单词数</title><link>https://tategotoazarasi.github.io/post/count-words-obtained-after-adding-a-letter/</link><pubDate>Sun, 09 Jan 2022 18:43:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-words-obtained-after-adding-a-letter/</guid><description>&lt;p>给你两个下标从 &lt;strong>0&lt;/strong> 开始的字符串数组 &lt;code>startWords&lt;/code> 和 &lt;code>targetWords&lt;/code> 。每个字符串都仅由 &lt;strong>小写英文字母&lt;/strong> 组成。&lt;/p>
&lt;p>对于 &lt;code>targetWords&lt;/code> 中的每个字符串，检查是否能够从 &lt;code>startWords&lt;/code> 中选出一个字符串，执行一次 &lt;strong>转换操作&lt;/strong> ，得到的结果与当前  &lt;code>targetWords&lt;/code> 字符串相等。&lt;/p>
&lt;p>&lt;strong>转换操作&lt;/strong> 如下面两步所述：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>追加&lt;/strong> 任何 &lt;strong>不存在&lt;/strong> 于当前字符串的任一小写字母到当前字符串的末尾。
&lt;ul>
&lt;li>例如，如果字符串为 &lt;code>&amp;quot;abc&amp;quot;&lt;/code> ，那么字母 &lt;code>'d'&lt;/code>、&lt;code>'e'&lt;/code> 或 &lt;code>'y'&lt;/code> 都可以加到该字符串末尾，但 &lt;code>'a'&lt;/code> 就不行。如果追加的是 &lt;code>'d'&lt;/code> ，那么结果字符串为 &lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>重排&lt;/strong> 新字符串中的字母，可以按 &lt;strong>任意&lt;/strong> 顺序重新排布字母。
&lt;ul>
&lt;li>例如，&lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 可以重排为 &lt;code>&amp;quot;acbd&amp;quot;&lt;/code>、&lt;code>&amp;quot;bacd&amp;quot;&lt;/code>、&lt;code>&amp;quot;cbda&amp;quot;&lt;/code>，以此类推。注意，它也可以重排为 &lt;code>&amp;quot;abcd&amp;quot;&lt;/code> 自身。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>找出 &lt;code>targetWords&lt;/code> 中有多少字符串能够由  &lt;code>startWords&lt;/code> 中的 &lt;strong>任一&lt;/strong> 字符串执行上述转换操作获得。返回 &lt;code>targetWords&lt;/code> 中这类 &lt;strong>字符串的数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 89. 格雷编码</title><link>https://tategotoazarasi.github.io/post/gray-code/</link><pubDate>Sat, 08 Jan 2022 16:57:11 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/gray-code/</guid><description>&lt;p>&lt;strong>n 位格雷码序列&lt;/strong> 是一个由 &lt;code>2n&lt;/code> 个整数组成的序列，其中：&lt;/p>
&lt;ul>
&lt;li>每个整数都在范围 &lt;code>[0, 2n - 1]&lt;/code> 内（含 &lt;code>0&lt;/code> 和 &lt;code>2n - 1&lt;/code>）&lt;/li>
&lt;li>第一个整数是 &lt;code>0&lt;/code>&lt;/li>
&lt;li>一个整数在序列中出现 &lt;strong>不超过一次&lt;/strong>&lt;/li>
&lt;li>每对 &lt;strong>相邻&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong> ，且&lt;/li>
&lt;li>&lt;strong>第一个&lt;/strong> 和 &lt;strong>最后一个&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，返回任一有效的 &lt;strong>n 位格雷码序列&lt;/strong> 。&lt;/p></description></item></channel></rss>