<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前缀和 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/</link><description>Recent content in 前缀和 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 08 Feb 2024 05:33:48 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 862. 和至少为 K 的最短子数组</title><link>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 21 Dec 2022 21:15:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，找出 &lt;code>nums&lt;/code> 中和至少为 &lt;code>k&lt;/code> 的
&lt;strong>最短非空子数组&lt;/strong> ，并返回该子数组的长度。如果不存在这样的 &lt;strong>子数组&lt;/strong>
，返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 1588. 所有奇数长度子数组的和</title><link>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</link><pubDate>Fri, 02 Dec 2022 14:13:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</guid><description>&lt;p>给你一个正整数数组 &lt;code>arr&lt;/code> ，请你计算所有可能的奇数长度子数组的和。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 定义为原数组中的一个连续子序列。&lt;/p>
&lt;p>请你返回 &lt;code>arr&lt;/code> 中 &lt;strong>所有奇数长度子数组的和&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 995. K 连续位的最小翻转次数</title><link>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</link><pubDate>Mon, 19 Sep 2022 18:54:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</guid><description>&lt;p>给定一个二进制数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>k 位翻转&lt;/strong> 就是从 &lt;code>nums&lt;/code> 中选择一个长度为 &lt;code>k&lt;/code> 的 &lt;strong>子数组&lt;/strong>，同时把子数组中的每一个 &lt;code>0&lt;/code> 都改成 &lt;code>1&lt;/code> ，把子数组中的每一个 &lt;code>1&lt;/code> 都改成&lt;code>0&lt;/code> 。&lt;/p>
&lt;p>返回数组中不存在 &lt;code>0&lt;/code> 所需的最小 &lt;strong>k 位翻转&lt;/strong>次数。如果不可能，则返回  &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 560. Subarray Sum Equals K</title><link>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</link><pubDate>Mon, 27 Jun 2022 14:37:09 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</guid><description>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the total number of subarrays whose sum equals to&lt;/em> &lt;code>k&lt;/code>.&lt;/p>
&lt;p>A subarray is a contiguous &lt;strong>non-empty&lt;/strong> sequence of elements within an array.&lt;/p></description></item><item><title>LeetCode 6040. Maximum Total Beauty of the Gardens</title><link>https://tategotoazarasi.github.io/post/maximum-total-beauty-of-the-gardens/</link><pubDate>Sun, 10 Apr 2022 12:20:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-total-beauty-of-the-gardens/</guid><description>&lt;p>Alice is a caretaker of &lt;code>n&lt;/code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.&lt;/p>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> integer array &lt;code>flowers&lt;/code> of size &lt;code>n&lt;/code>, where &lt;code>flowers[i]&lt;/code> is the number of flowers already planted in the &lt;code>ith&lt;/code> garden. Flowers that are already planted &lt;strong>cannot&lt;/strong> be removed. You are then given another integer &lt;code>newFlowers&lt;/code>, which is the &lt;strong>maximum&lt;/strong> number of flowers that Alice can additionally plant. You are also given the integers &lt;code>target&lt;/code>, &lt;code>full&lt;/code>, and &lt;code>partial&lt;/code>.&lt;/p>
&lt;p>A garden is considered &lt;strong>complete&lt;/strong> if it has &lt;strong>at least&lt;/strong> &lt;code>target&lt;/code> flowers. The &lt;strong>total beauty&lt;/strong> of the gardens is then determined as the &lt;strong>sum&lt;/strong> of the following:&lt;/p>
&lt;ul>
&lt;li>The number of &lt;strong>complete&lt;/strong> gardens multiplied by &lt;code>full&lt;/code>.&lt;/li>
&lt;li>The &lt;strong>minimum&lt;/strong> number of flowers in any of the &lt;strong>incomplete&lt;/strong> gardens multiplied by &lt;code>partial&lt;/code>. If there are no incomplete gardens, then this value will be &lt;code>0&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the &lt;strong>maximum&lt;/strong> total beauty that Alice can obtain after planting at most&lt;/em> &lt;code>newFlowers&lt;/code> &lt;em>flowers.&lt;/em>&lt;/p></description></item><item><title>AcWing 3745. 牛的学术圈 I</title><link>https://tategotoazarasi.github.io/post/acwing3745/</link><pubDate>Thu, 17 Mar 2022 16:37:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing3745/</guid><description>&lt;p>由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。&lt;/p>
&lt;p>经过一段时间的学术研究，她已经发表了 N 篇论文，并且她的第 i 篇论文得到了来自其他研究文献的 ci 次引用。&lt;/p>
&lt;p>Bessie 听说学术成就可以用 h 指数来衡量。&lt;/p>
&lt;p>h 指数等于使得研究员有至少 h 篇引用次数不少于 h 的论文的最大整数 h。&lt;/p>
&lt;p>例如，如果一名研究员有 4 篇论文，引用次数分别为 (1,100,2,3)，则 h 指数为 2，然而若引用次数为 (1,100,3,3) 则 h 指数将会是 3。&lt;/p>
&lt;p>为了提升她的 h 指数，Bessie 计划写一篇综述，并引用一些她曾经写过的论文。&lt;/p>
&lt;p>由于页数限制，她至多可以在这篇综述中引用 L 篇论文，并且她只能引用每篇她的论文至多一次。&lt;/p>
&lt;p>请帮助 Bessie 求出在写完这篇综述后她可以达到的最大 h 指数。&lt;/p>
&lt;p>注意 Bessie 的导师可能会告知她纯粹为了提升 h 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。&lt;/p></description></item><item><title>LeetCode 798. Smallest Rotation with Highest Score</title><link>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</link><pubDate>Wed, 09 Mar 2022 14:47:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</guid><description>&lt;p>You are given an array &lt;code>nums&lt;/code>. You can rotate it by a non-negative integer &lt;code>k&lt;/code> so that the array becomes &lt;code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]&lt;/code>. Afterward, any entries that are less than or equal to their index are worth one point.&lt;/p>
&lt;ul>
&lt;li>For example, if we have &lt;code>nums = [2,4,1,3,0]&lt;/code>, and we rotate by &lt;code>k = 2&lt;/code>, it becomes &lt;code>[1,3,0,2,4]&lt;/code>. This is worth &lt;code>3&lt;/code> points because &lt;code>1 &amp;gt; 0&lt;/code> [no points], &lt;code>3 &amp;gt; 1&lt;/code> [no points], &lt;code>0 &amp;lt;= 2&lt;/code> [one point], &lt;code>2 &amp;lt;= 3&lt;/code> [one point], &lt;code>4 &amp;lt;= 4&lt;/code> [one point].&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the rotation index&lt;/em> &lt;code>k&lt;/code> &lt;em>that corresponds to the highest score we can achieve if we rotated&lt;/em> &lt;code>nums&lt;/code> &lt;em>by it&lt;/em>. If there are multiple answers, return the smallest such index &lt;code>k&lt;/code>.&lt;/p></description></item><item><title>AcWing 1913. 公平摄影</title><link>https://tategotoazarasi.github.io/post/acwing1913/</link><pubDate>Thu, 20 Jan 2022 12:57:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing1913/</guid><description>&lt;p>农夫约翰的 N 头奶牛站在一维长围栏的不同位置。&lt;/p>
&lt;p>第 i 头牛位于位置 xi，其所属品种为 bi（根西岛牛或荷斯坦牛）。&lt;/p>
&lt;p>所有奶牛的位置各不相同。&lt;/p>
&lt;p>约翰想给一段连续区间内的奶牛拍摄一张照片，用来在乡村集市上展览。&lt;/p>
&lt;p>但是我们希望他所有品种的奶牛都能在照片中得到公平的展示。&lt;/p>
&lt;p>因此，他希望确保无论照片中出些哪些品种的奶牛，每种品种的奶牛在照片中的数量都必须相等。&lt;/p>
&lt;p>例如，一张照片中只包含荷斯坦牛是可以的，包含荷斯坦牛和根西岛牛各 27 头也没问题，但是包含 10 头荷斯坦牛和 9 头根西岛牛则不可以。&lt;/p>
&lt;p>请确定，约翰可以拍下的满足以上条件的照片的最大尺寸。&lt;/p>
&lt;p>照片的尺寸是指照片中奶牛最大和最小位置之间的差。&lt;/p>
&lt;p>约翰最终可能只拍下一头奶牛，这种情况下，照片尺寸为 0。&lt;/p></description></item><item><title>LeetCode 5965. 相同元素的间隔之和</title><link>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</link><pubDate>Sun, 26 Dec 2021 15:11:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、由 &lt;code>n&lt;/code> 个整数组成的数组 &lt;code>arr&lt;/code> 。&lt;/p>
&lt;p>&lt;code>arr&lt;/code> 中两个元素的 &lt;strong>间隔&lt;/strong> 定义为它们下标之间的 &lt;strong>绝对差&lt;/strong> 。更正式地，&lt;code>arr[i]&lt;/code> 和 &lt;code>arr[j]&lt;/code> 之间的间隔是 &lt;code>|i - j|&lt;/code> 。&lt;/p>
&lt;p>返回一个长度为 &lt;code>n&lt;/code> 的数组  &lt;code>intervals&lt;/code> ，其中 &lt;code>intervals[i]&lt;/code> 是 &lt;code>arr[i]&lt;/code> 和 &lt;code>arr&lt;/code> 中每个相同元素（与 &lt;code>arr[i]&lt;/code> 的值相同）的 &lt;strong>间隔之和&lt;/strong> &lt;em>。&lt;/em>&lt;/p></description></item></channel></rss>