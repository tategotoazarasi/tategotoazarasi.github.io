<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>哈希表 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/</link><description>Recent content in 哈希表 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Jul 2024 07:34:48 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 127. 单词接龙</title><link>https://tategotoazarasi.github.io/post/word-ladder/</link><pubDate>Tue, 03 Jan 2023 14:52:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-ladder/</guid><description>&lt;p>字典  &lt;code>wordList&lt;/code> 中从单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 的&lt;strong>转换序列&lt;/strong>是一个按下述规格形成的序列&lt;/p>
&lt;p>\(beginWord \to s_1 \to s_2 \to \dots \to s_k\)：&lt;/p>
&lt;ul>
&lt;li>每一对相邻的单词只差一个字母。&lt;/li>
&lt;li>对于  &lt;code>1 &amp;lt;= i &amp;lt;= k&lt;/code>  时，每个 \(s_i\)  都在&lt;code>wordList&lt;/code>  中。注意， &lt;code>beginWord&lt;/code> 不需要在&lt;code>wordList&lt;/code>  中。&lt;/li>
&lt;li>\(s_k == endWord\)&lt;/li>
&lt;/ul>
&lt;p>给你两个单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 和一个字典 &lt;code>wordList&lt;/code> ，返回从  &lt;code>beginWord&lt;/code> 到  &lt;code>endWord&lt;/code> 的&lt;strong>最短转换序列&lt;/strong>中的&lt;strong>单词数目&lt;/strong>。如果不存在这样的转换序列，返回 &lt;code>0&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 41. 缺失的第一个正数</title><link>https://tategotoazarasi.github.io/post/first-missing-positive/</link><pubDate>Fri, 23 Sep 2022 12:33:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/first-missing-positive/</guid><description>&lt;p>给你一个未排序的整数数组 &lt;code>nums&lt;/code> ，请你找出其中没有出现的最小的正整数。&lt;/p></description></item><item><title>LeetCode 76. 最小覆盖子串</title><link>https://tategotoazarasi.github.io/post/minimum-window-substring/</link><pubDate>Mon, 29 Aug 2022 17:02:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-window-substring/</guid><description>&lt;p>给你一个字符串 &lt;code>s&lt;/code> 、一个字符串 &lt;code>t&lt;/code> 。返回 &lt;code>s&lt;/code> 中涵盖 &lt;code>t&lt;/code> 所有字符的最小子串。如果 &lt;code>s&lt;/code> 中不存在涵盖 &lt;code>t&lt;/code> 所有字符的子串，则返回空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 560. Subarray Sum Equals K</title><link>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</link><pubDate>Mon, 27 Jun 2022 14:37:09 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</guid><description>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the total number of subarrays whose sum equals to&lt;/em> &lt;code>k&lt;/code>.&lt;/p>
&lt;p>A subarray is a contiguous &lt;strong>non-empty&lt;/strong> sequence of elements within an array.&lt;/p></description></item><item><title>LeetCode 166. Fraction to Recurring Decimal</title><link>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</link><pubDate>Tue, 21 Jun 2022 15:53:27 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</guid><description>&lt;p>Given two integers representing the &lt;code>numerator&lt;/code> and &lt;code>denominator&lt;/code> of a fraction, return &lt;em>the fraction in string format&lt;/em>.&lt;/p>
&lt;p>If the fractional part is repeating, enclose the repeating part in parentheses.&lt;/p>
&lt;p>If multiple answers are possible, return &lt;strong>any of them&lt;/strong>.&lt;/p>
&lt;p>It is &lt;strong>guaranteed&lt;/strong> that the length of the answer string is less than &lt;code>104&lt;/code> for all the given inputs.&lt;/p></description></item><item><title>LeetCode 380. Insert Delete GetRandom O(1)</title><link>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</link><pubDate>Wed, 13 Apr 2022 15:22:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</guid><description>&lt;p>实现&lt;code>RandomizedSet&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RandomizedSet()&lt;/code> 初始化 &lt;code>RandomizedSet&lt;/code> 对象&lt;/li>
&lt;li>&lt;code>bool insert(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 不存在时，向集合中插入该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>bool remove(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 存在时，从集合中移除该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>int getRandom()&lt;/code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 &lt;strong>相同的概率&lt;/strong> 被返回。&lt;/li>
&lt;/ul>
&lt;p>你必须实现类的所有函数，并满足每个函数的 &lt;strong>平均&lt;/strong> 时间复杂度为 &lt;code>O(1)&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 5302. Encrypt and Decrypt Strings</title><link>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</link><pubDate>Sun, 03 Apr 2022 17:10:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</guid><description>&lt;p>You are given a character array &lt;code>keys&lt;/code> containing &lt;strong>unique&lt;/strong> characters and a string array &lt;code>values&lt;/code> containing strings of length 2. You are also given another string array &lt;code>dictionary&lt;/code> that contains all permitted original strings after decryption. You
should implement a data structure that can encrypt or decrypt a &lt;strong>0-indexed&lt;/strong> string.&lt;/p>
&lt;p>A string is &lt;strong>encrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each character &lt;code>c&lt;/code> in the string, we find the index &lt;code>i&lt;/code> satisfying &lt;code>keys[i] == c&lt;/code> in &lt;code>keys&lt;/code>.&lt;/li>
&lt;li>Replace &lt;code>c&lt;/code> with &lt;code>values[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>A string is &lt;strong>decrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each substring &lt;code>s&lt;/code> of length 2 occurring at an even index in the string, we find an &lt;code>i&lt;/code> such that &lt;code>values[i] == s&lt;/code>. If there are multiple valid &lt;code>i&lt;/code>, we choose &lt;strong>any&lt;/strong> one of them. This means a string could have multiple possible strings it can decrypt to.&lt;/li>
&lt;li>Replace &lt;code>s&lt;/code> with &lt;code>keys[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>Implement the &lt;code>Encrypter&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Encrypter(char[] keys, String[] values, String[] dictionary)&lt;/code> Initializes the &lt;code>Encrypter&lt;/code> class with &lt;code>keys, values&lt;/code>, and &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;li>&lt;code>String encrypt(String word1)&lt;/code> Encrypts &lt;code>word1&lt;/code> with the encryption process described above and returns the encrypted string.&lt;/li>
&lt;li>&lt;code>int decrypt(String word2)&lt;/code> Returns the number of possible strings &lt;code>word2&lt;/code> could decrypt to that also appear in &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 1763. 最长的美好子字符串</title><link>https://tategotoazarasi.github.io/post/longest-nice-substring/</link><pubDate>Tue, 01 Feb 2022 19:52:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-nice-substring/</guid><description>&lt;p>当一个字符串 &lt;code>s&lt;/code>  包含的每一种字母的大写和小写形式 &lt;strong>同时&lt;/strong>  出现在 &lt;code>s&lt;/code>  中，就称这个字符串  &lt;code>s&lt;/code>  是 &lt;strong>美好&lt;/strong> 字符串。比方说，&lt;code>&amp;quot;abABB&amp;quot;&lt;/code>  是美好字符串，因为  &lt;code>'A'&lt;/code> 和  &lt;code>'a'&lt;/code>  同时出现了，且  &lt;code>'B'&lt;/code> 和  &lt;code>'b'&lt;/code>  也同时出现了。然而，&lt;code>&amp;quot;abA&amp;quot;&lt;/code>  不是美好字符串因为  &lt;code>'b'&lt;/code>  出现了，而  &lt;code>'B'&lt;/code>  没有出现。&lt;/p>
&lt;p>给你一个字符串  &lt;code>s&lt;/code> ，请你返回  &lt;code>s&lt;/code>  最长的  &lt;strong>美好子字符串&lt;/strong> 。如果有多个答案，请你返回  &lt;strong>最早&lt;/strong>  出现的一个。如果不存在美好子字符串，请你返回一个空字符串。&lt;/p></description></item><item><title>AcWing 1913. 公平摄影</title><link>https://tategotoazarasi.github.io/post/acwing1913/</link><pubDate>Thu, 20 Jan 2022 12:57:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing1913/</guid><description>&lt;p>农夫约翰的 N 头奶牛站在一维长围栏的不同位置。&lt;/p>
&lt;p>第 i 头牛位于位置 xi，其所属品种为 bi（根西岛牛或荷斯坦牛）。&lt;/p>
&lt;p>所有奶牛的位置各不相同。&lt;/p>
&lt;p>约翰想给一段连续区间内的奶牛拍摄一张照片，用来在乡村集市上展览。&lt;/p>
&lt;p>但是我们希望他所有品种的奶牛都能在照片中得到公平的展示。&lt;/p>
&lt;p>因此，他希望确保无论照片中出些哪些品种的奶牛，每种品种的奶牛在照片中的数量都必须相等。&lt;/p>
&lt;p>例如，一张照片中只包含荷斯坦牛是可以的，包含荷斯坦牛和根西岛牛各 27 头也没问题，但是包含 10 头荷斯坦牛和 9 头根西岛牛则不可以。&lt;/p>
&lt;p>请确定，约翰可以拍下的满足以上条件的照片的最大尺寸。&lt;/p>
&lt;p>照片的尺寸是指照片中奶牛最大和最小位置之间的差。&lt;/p>
&lt;p>约翰最终可能只拍下一头奶牛，这种情况下，照片尺寸为 0。&lt;/p></description></item><item><title>LeetCode 1036. 逃离大迷宫</title><link>https://tategotoazarasi.github.io/post/escape-a-large-maze/</link><pubDate>Tue, 11 Jan 2022 16:08:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/escape-a-large-maze/</guid><description>&lt;p>在一个 \(10^6 \times 10^6\) 的网格中，每个网格上方格的坐标为 &lt;code>(x, y)&lt;/code> 。&lt;/p>
&lt;p>现在从源方格 \(source = [s_x, s_y]\) 开始出发，意图赶往目标方格 \(target = [t_x, t_y]\) 。数组 &lt;code>blocked&lt;/code> 是封锁的方格列表，其中每个 \(blocked[i] = [x_i, y_i]\) 表示坐标为 \((x_i, y_i)\) 的方格是禁止通行的。&lt;/p>
&lt;p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 &lt;strong>不&lt;/strong> 在给出的封锁列表 &lt;code>blocked&lt;/code> 上。同时，不允许走出网格。&lt;/p>
&lt;p>只有在可以通过一系列的移动从源方格 &lt;code>source&lt;/code> 到达目标方格 &lt;code>target&lt;/code> 时才返回 &lt;code>true&lt;/code>。否则，返回 &lt;code>false&lt;/code>。&lt;/p></description></item><item><title>LeetCode 5965. 相同元素的间隔之和</title><link>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</link><pubDate>Sun, 26 Dec 2021 15:11:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、由 &lt;code>n&lt;/code> 个整数组成的数组 &lt;code>arr&lt;/code> 。&lt;/p>
&lt;p>&lt;code>arr&lt;/code> 中两个元素的 &lt;strong>间隔&lt;/strong> 定义为它们下标之间的 &lt;strong>绝对差&lt;/strong> 。更正式地，&lt;code>arr[i]&lt;/code> 和 &lt;code>arr[j]&lt;/code> 之间的间隔是 &lt;code>|i - j|&lt;/code> 。&lt;/p>
&lt;p>返回一个长度为 &lt;code>n&lt;/code> 的数组  &lt;code>intervals&lt;/code> ，其中 &lt;code>intervals[i]&lt;/code> 是 &lt;code>arr[i]&lt;/code> 和 &lt;code>arr&lt;/code> 中每个相同元素（与 &lt;code>arr[i]&lt;/code> 的值相同）的 &lt;strong>间隔之和&lt;/strong> &lt;em>。&lt;/em>&lt;/p></description></item><item><title>LeetCode 160. 相交链表</title><link>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</link><pubDate>Fri, 24 Dec 2021 08:29:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intersection-of-two-linked-lists/</guid><description>&lt;p>给你两个单链表的头节点  &lt;code>headA&lt;/code> 和 &lt;code>headB&lt;/code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code>null&lt;/code> 。&lt;/p>
&lt;p>图示两个链表在节点 &lt;code>c1&lt;/code> 开始相交 &lt;strong>：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tategotoazarasi.github.io/images/160_statement.png" alt="">&lt;/p>
&lt;p>题目数据 &lt;strong>保证&lt;/strong> 整个链式结构中不存在环。&lt;/p></description></item></channel></rss>