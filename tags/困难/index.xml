<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>困难 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%9B%B0%E9%9A%BE/</link><description>Recent content in 困难 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 14 Mar 2024 06:07:42 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%9B%B0%E9%9A%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 127. 单词接龙</title><link>https://tategotoazarasi.github.io/post/word-ladder/</link><pubDate>Tue, 03 Jan 2023 14:52:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-ladder/</guid><description>&lt;p>字典  &lt;code>wordList&lt;/code> 中从单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 的&lt;strong>转换序列&lt;/strong>是一个按下述规格形成的序列&lt;/p>
&lt;p>\(beginWord \to s_1 \to s_2 \to \dots \to s_k\)：&lt;/p>
&lt;ul>
&lt;li>每一对相邻的单词只差一个字母。&lt;/li>
&lt;li>对于  &lt;code>1 &amp;lt;= i &amp;lt;= k&lt;/code>  时，每个 \(s_i\)  都在&lt;code>wordList&lt;/code>  中。注意， &lt;code>beginWord&lt;/code> 不需要在&lt;code>wordList&lt;/code>  中。&lt;/li>
&lt;li>\(s_k == endWord\)&lt;/li>
&lt;/ul>
&lt;p>给你两个单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 和一个字典 &lt;code>wordList&lt;/code> ，返回从  &lt;code>beginWord&lt;/code> 到  &lt;code>endWord&lt;/code> 的&lt;strong>最短转换序列&lt;/strong>中的&lt;strong>单词数目&lt;/strong>。如果不存在这样的转换序列，返回 &lt;code>0&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 212. 单词搜索 II</title><link>https://tategotoazarasi.github.io/post/word-search-ii/</link><pubDate>Tue, 27 Dec 2022 15:20:42 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-search-ii/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 二维字符网格  &lt;code>board&lt;/code> 和一个单词（字符串）列表&lt;code>words&lt;/code>，&lt;em>返回所有二维网格上的单词&lt;/em> 。&lt;/p>
&lt;p>单词必须按照字母顺序，通过 &lt;strong>相邻的单元格&lt;/strong>内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。&lt;/p></description></item><item><title>LeetCode 218. 天际线问题</title><link>https://tategotoazarasi.github.io/post/the-skyline-problem/</link><pubDate>Sun, 25 Dec 2022 20:56:06 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-skyline-problem/</guid><description>&lt;p>城市的 &lt;strong>天际线&lt;/strong>是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 *由这些建筑物形成的 &lt;strong>天际线*&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 1579. 保证图可完全遍历</title><link>https://tategotoazarasi.github.io/post/remove-max-number-of-edges-to-keep-graph-fully-traversable/</link><pubDate>Sat, 24 Dec 2022 20:10:04 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-max-number-of-edges-to-keep-graph-fully-traversable/</guid><description>&lt;p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：&lt;/p>
&lt;ul>
&lt;li>类型 1：只能由 Alice 遍历。&lt;/li>
&lt;li>类型 2：只能由 Bob 遍历。&lt;/li>
&lt;li>类型 3：Alice 和 Bob 都可以遍历。&lt;/li>
&lt;/ul>
&lt;p>给你一个数组 &lt;code>edges&lt;/code> ，其中\(edges[i] = [type_i, u_i, v_i]\)  表示节点\(u_i\)和 \( v_i\) 之间存在类型为 \(type_i\) 的双向边。请你在保证图仍能够被 Alice 和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。&lt;/p>
&lt;p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。&lt;/p></description></item><item><title>LeetCode 862. 和至少为 K 的最短子数组</title><link>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 21 Dec 2022 21:15:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，找出 &lt;code>nums&lt;/code> 中和至少为 &lt;code>k&lt;/code> 的
&lt;strong>最短非空子数组&lt;/strong> ，并返回该子数组的长度。如果不存在这样的 &lt;strong>子数组&lt;/strong>
，返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 84. 柱状图中最大的矩形</title><link>https://tategotoazarasi.github.io/post/largest-rectangle-in-histogram/</link><pubDate>Wed, 21 Dec 2022 19:22:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/largest-rectangle-in-histogram/</guid><description>&lt;p>给定 &lt;em>n&lt;/em>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。&lt;/p>
&lt;p>求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p></description></item><item><title>LeetCode 214. 最短回文串</title><link>https://tategotoazarasi.github.io/post/shortest-palindrome/</link><pubDate>Tue, 06 Dec 2022 17:19:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-palindrome/</guid><description>&lt;p>给定一个字符串&lt;strong>s&lt;/strong>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p></description></item><item><title>LeetCode 44. 通配符匹配</title><link>https://tategotoazarasi.github.io/post/wildcard-matching/</link><pubDate>Tue, 06 Dec 2022 14:03:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/wildcard-matching/</guid><description>&lt;p>给定一个字符串  (&lt;code>s&lt;/code>) 和一个字符模式  (&lt;code>p&lt;/code>)，实现一个支持  &lt;code>'?'&lt;/code>  和  &lt;code>'*'&lt;/code>  的通配符匹配。&lt;/p></description></item><item><title>LeetCode 41. 缺失的第一个正数</title><link>https://tategotoazarasi.github.io/post/first-missing-positive/</link><pubDate>Fri, 23 Sep 2022 12:33:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/first-missing-positive/</guid><description>&lt;p>给你一个未排序的整数数组 &lt;code>nums&lt;/code> ，请你找出其中没有出现的最小的正整数。&lt;/p></description></item><item><title>LeetCode 715. Range 模块</title><link>https://tategotoazarasi.github.io/post/range-module/</link><pubDate>Mon, 19 Sep 2022 21:11:46 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/range-module/</guid><description>&lt;p>Range 模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 &lt;strong>半开区间&lt;/strong>的范围并查询它们。&lt;/p>
&lt;p>&lt;strong>半开区间&lt;/strong> &lt;code>[left, right)&lt;/code>  表示所有  &lt;code>left &amp;lt;= x &amp;lt; right&lt;/code>  的实数 &lt;code>x&lt;/code> 。&lt;/p>
&lt;p>实现 &lt;code>RangeModule&lt;/code> 类:&lt;/p>
&lt;ul>
&lt;li>&lt;code>RangeModule()&lt;/code>  初始化数据结构的对象。&lt;/li>
&lt;li>&lt;code>void addRange(int left, int right)&lt;/code> 添加 &lt;strong>半开区间&lt;/strong> &lt;code>[left, right)&lt;/code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间  &lt;code>[left, right)&lt;/code>  中尚未跟踪的任何数字到该区间中。&lt;/li>
&lt;li>&lt;code>boolean queryRange(int left, int right)&lt;/code>  只有在当前正在跟踪区间  &lt;code>[left, right)&lt;/code>  中的每一个实数时，才返回&lt;code>true&lt;/code> ，否则返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>void removeRange(int left, int right)&lt;/code>  停止跟踪
&lt;strong>半开区间&lt;/strong> &lt;code>[left, right)&lt;/code>  中当前正在跟踪的每个实数。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 995. K 连续位的最小翻转次数</title><link>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</link><pubDate>Mon, 19 Sep 2022 18:54:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</guid><description>&lt;p>给定一个二进制数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>k 位翻转&lt;/strong> 就是从 &lt;code>nums&lt;/code> 中选择一个长度为 &lt;code>k&lt;/code> 的 &lt;strong>子数组&lt;/strong>，同时把子数组中的每一个 &lt;code>0&lt;/code> 都改成 &lt;code>1&lt;/code> ，把子数组中的每一个 &lt;code>1&lt;/code> 都改成&lt;code>0&lt;/code> 。&lt;/p>
&lt;p>返回数组中不存在 &lt;code>0&lt;/code> 所需的最小 &lt;strong>k 位翻转&lt;/strong>次数。如果不可能，则返回  &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 329. 矩阵中的最长递增路径</title><link>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</link><pubDate>Mon, 19 Sep 2022 13:41:55 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 整数矩阵  &lt;code>matrix&lt;/code> ，找出其中 &lt;strong>最长递增路径&lt;/strong> 的长度。&lt;/p>
&lt;p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 &lt;strong>不能&lt;/strong> 在 &lt;strong>对角线&lt;/strong> 方向上移动或移动到 &lt;strong>边界外&lt;/strong>（即不允许环绕）。&lt;/p></description></item><item><title>LeetCode 174. Dungeon Game</title><link>https://tategotoazarasi.github.io/post/dungeon-game/</link><pubDate>Tue, 13 Sep 2022 17:00:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/dungeon-game/</guid><description>&lt;p>The demons had captured the princess and imprisoned her in &lt;strong>the bottom-right corner&lt;/strong> of a &lt;code>dungeon&lt;/code>. The &lt;code>dungeon&lt;/code> consists of &lt;code>m x n&lt;/code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in &lt;strong>the top-left room&lt;/strong> and must fight his way through &lt;code>dungeon&lt;/code> to rescue the princess.&lt;/p>
&lt;p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to &lt;code>0&lt;/code> or below, he dies immediately.&lt;/p>
&lt;p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&amp;rsquo;s health (represented by positive integers).&lt;/p>
&lt;p>To reach the princess as quickly as possible, the knight decides to move only &lt;strong>rightward&lt;/strong> or &lt;strong>downward&lt;/strong> in each step.&lt;/p>
&lt;p>Return &lt;em>the knight&amp;rsquo;s minimum initial health so that he can rescue the princess&lt;/em>.&lt;/p></description></item><item><title>LeetCode 85. 最大矩形</title><link>https://tategotoazarasi.github.io/post/maximal-rectangle/</link><pubDate>Tue, 13 Sep 2022 12:53:39 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximal-rectangle/</guid><description>&lt;p>给定一个仅包含  &lt;code>0&lt;/code> 和 &lt;code>1&lt;/code> 、大小为 &lt;code>rows x cols&lt;/code> 的二维二进制矩阵，找出只包含 &lt;code>1&lt;/code> 的最大矩形，并返回其面积。&lt;/p></description></item><item><title>LeetCode 315. 计算右侧小于当前元素的个数</title><link>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</link><pubDate>Wed, 07 Sep 2022 13:47:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，按要求返回一个新数组  &lt;code>counts&lt;/code> 。数组 &lt;code>counts&lt;/code> 有该性质： &lt;code>counts[i]&lt;/code> 的值是   &lt;code>nums[i]&lt;/code> 右侧小于  &lt;code>nums[i]&lt;/code> 的元素的数量。&lt;/p></description></item><item><title>LeetCode 4. 寻找两个正序数组的中位数</title><link>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</link><pubDate>Wed, 07 Sep 2022 13:12:36 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</guid><description>&lt;p>给定两个大小分别为 &lt;code>m&lt;/code> 和 &lt;code>n&lt;/code> 的正序（从小到大）数组  &lt;code>nums1&lt;/code> 和  &lt;code>nums2&lt;/code>。请你找出并返回这两个正序数组的 &lt;strong>中位数&lt;/strong> 。&lt;/p>
&lt;p>算法的时间复杂度应该为 &lt;code>O(log (m+n))&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 489. 扫地机器人</title><link>https://tategotoazarasi.github.io/post/robot-room-cleaner/</link><pubDate>Tue, 06 Sep 2022 14:03:06 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/robot-room-cleaner/</guid><description>&lt;p>房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。&lt;/p>
&lt;p>扫地机器人提供 4 个 API，可以向前进，向左转或者向右转。每次转弯 90 度。&lt;/p>
&lt;p>当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。&lt;/p>
&lt;p>请利用提供的 4 个 API 编写让机器人清理整个房间的算法。&lt;/p></description></item><item><title>LeetCode 301. 删除无效的括号</title><link>https://tategotoazarasi.github.io/post/remove-invalid-parentheses/</link><pubDate>Tue, 06 Sep 2022 13:11:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-invalid-parentheses/</guid><description>&lt;p>给你一个由若干括号和字母组成的字符串 &lt;code>s&lt;/code>，删除最小数量的无效括号，使得输入的字符串有效。&lt;/p>
&lt;p>返回所有可能的结果。答案可以按 &lt;strong>任意顺序&lt;/strong> 返回。&lt;/p></description></item><item><title>LeetCode 1192. 查找集群内的「关键连接」</title><link>https://tategotoazarasi.github.io/post/critical-connections-in-a-network/</link><pubDate>Fri, 02 Sep 2022 15:40:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/critical-connections-in-a-network/</guid><description>&lt;p>力扣数据中心有  &lt;code>n&lt;/code>  台服务器，分别按从  &lt;code>0&lt;/code>  到  &lt;code>n-1&lt;/code>  的方式进行了编号。它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接  &lt;code>connections&lt;/code> 是无向的。从形式上讲，&lt;code>connections[i] = [a, b]&lt;/code>  表示服务器 &lt;code>a&lt;/code>  和 &lt;code>b&lt;/code>  之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。&lt;/p>
&lt;p>&lt;em>「关键连接」&lt;/em>  是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。&lt;/p>
&lt;p>请你以任意顺序返回该集群内的所有 「关键连接」。&lt;/p></description></item><item><title>LeetCode 76. 最小覆盖子串</title><link>https://tategotoazarasi.github.io/post/minimum-window-substring/</link><pubDate>Mon, 29 Aug 2022 17:02:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-window-substring/</guid><description>&lt;p>给你一个字符串 &lt;code>s&lt;/code> 、一个字符串 &lt;code>t&lt;/code> 。返回 &lt;code>s&lt;/code> 中涵盖 &lt;code>t&lt;/code> 所有字符的最小子串。如果 &lt;code>s&lt;/code> 中不存在涵盖 &lt;code>t&lt;/code> 所有字符的子串，则返回空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 1231. 分享巧克力</title><link>https://tategotoazarasi.github.io/post/divide-chocolate/</link><pubDate>Thu, 25 Aug 2022 16:59:33 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/divide-chocolate/</guid><description>&lt;p>你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组  &lt;code>sweetness&lt;/code>  来表示每一小块的甜度。&lt;/p>
&lt;p>你打算和  &lt;code>K&lt;/code>  名朋友一起分享这块巧克力，所以你需要将切割  &lt;code>K&lt;/code>  次才能得到&lt;code>K+1&lt;/code>  块，每一块都由一些 &lt;strong>连续&lt;/strong>的小块组成。&lt;/p>
&lt;p>为了表现出你的慷慨，你将会吃掉  &lt;strong>总甜度最小&lt;/strong>的一块，并将其余几块分给你的朋友们。&lt;/p>
&lt;p>请找出一个最佳的切割策略，使得你所分得的巧克力  &lt;strong>总甜度最大&lt;/strong>，并返回这个&lt;strong>最大总甜度&lt;/strong>。&lt;/p></description></item><item><title>LeetCode 6040. Maximum Total Beauty of the Gardens</title><link>https://tategotoazarasi.github.io/post/maximum-total-beauty-of-the-gardens/</link><pubDate>Sun, 10 Apr 2022 12:20:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-total-beauty-of-the-gardens/</guid><description>&lt;p>Alice is a caretaker of &lt;code>n&lt;/code> gardens and she wants to plant flowers to maximize the total beauty of all her gardens.&lt;/p>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> integer array &lt;code>flowers&lt;/code> of size &lt;code>n&lt;/code>, where &lt;code>flowers[i]&lt;/code> is the number of flowers already planted in the &lt;code>ith&lt;/code> garden. Flowers that are already planted &lt;strong>cannot&lt;/strong> be removed. You are then given another integer &lt;code>newFlowers&lt;/code>, which is the &lt;strong>maximum&lt;/strong> number of flowers that Alice can additionally plant. You are also given the integers &lt;code>target&lt;/code>, &lt;code>full&lt;/code>, and &lt;code>partial&lt;/code>.&lt;/p>
&lt;p>A garden is considered &lt;strong>complete&lt;/strong> if it has &lt;strong>at least&lt;/strong> &lt;code>target&lt;/code> flowers. The &lt;strong>total beauty&lt;/strong> of the gardens is then determined as the &lt;strong>sum&lt;/strong> of the following:&lt;/p>
&lt;ul>
&lt;li>The number of &lt;strong>complete&lt;/strong> gardens multiplied by &lt;code>full&lt;/code>.&lt;/li>
&lt;li>The &lt;strong>minimum&lt;/strong> number of flowers in any of the &lt;strong>incomplete&lt;/strong> gardens multiplied by &lt;code>partial&lt;/code>. If there are no incomplete gardens, then this value will be &lt;code>0&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the &lt;strong>maximum&lt;/strong> total beauty that Alice can obtain after planting at most&lt;/em> &lt;code>newFlowers&lt;/code> &lt;em>flowers.&lt;/em>&lt;/p></description></item><item><title>LeetCode 780. Reaching Points</title><link>https://tategotoazarasi.github.io/post/reaching-points/</link><pubDate>Sat, 09 Apr 2022 14:26:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/reaching-points/</guid><description>&lt;p>Given four integers &lt;code>sx&lt;/code>, &lt;code>sy&lt;/code>, &lt;code>tx&lt;/code>, and &lt;code>ty&lt;/code>, return &lt;code>true&lt;/code> &lt;em>if it is possible to convert the point&lt;/em> &lt;code>(sx, sy)&lt;/code> &lt;em>to the point&lt;/em> &lt;code>(tx, ty)&lt;/code> &lt;em>through some operations**, or&lt;/em> &lt;code>false&lt;/code> &lt;em>otherwise&lt;/em>.&lt;/p>
&lt;p>The allowed operation on some point &lt;code>(x, y)&lt;/code> is to convert it to either &lt;code>(x, x + y)&lt;/code> or &lt;code>(x + y, y)&lt;/code>.&lt;/p></description></item><item><title>LeetCode 6036. Sum of Scores of Built Strings</title><link>https://tategotoazarasi.github.io/post/sum-of-scores-of-built-strings/</link><pubDate>Sun, 03 Apr 2022 17:48:50 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-scores-of-built-strings/</guid><description>&lt;p>You are &lt;strong>building&lt;/strong> a string &lt;code>s&lt;/code> of length &lt;code>n&lt;/code> &lt;strong>one&lt;/strong> character at a time, &lt;strong>prepending&lt;/strong> each new character to the &lt;strong>front&lt;/strong> of the string. The strings are labeled from &lt;code>1&lt;/code> to &lt;code>n&lt;/code>, where the string with length &lt;code>i&lt;/code> is labeled \(s_i\).&lt;/p>
&lt;ul>
&lt;li>For example, for \(s = &amp;ldquo;abaca&amp;rdquo;, s_1 == &amp;ldquo;a&amp;rdquo;, s_2 == &amp;ldquo;ca&amp;rdquo;, s_3 == &amp;ldquo;aca&amp;rdquo;\), etc.&lt;/li>
&lt;/ul>
&lt;p>The &lt;strong>score&lt;/strong> of \(s_i\) is the length of the &lt;strong>longest common prefix&lt;/strong> between \(s_i\) and \(s_n\) (Note that \(s == s_n\)).&lt;/p>
&lt;p>Given the final string &lt;code>s&lt;/code>, return &lt;em>the &lt;strong>sum&lt;/strong> of the &lt;strong>score&lt;/strong> of every&lt;/em> \(s_i\).&lt;/p></description></item><item><title>LeetCode 5302. Encrypt and Decrypt Strings</title><link>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</link><pubDate>Sun, 03 Apr 2022 17:10:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</guid><description>&lt;p>You are given a character array &lt;code>keys&lt;/code> containing &lt;strong>unique&lt;/strong> characters and a string array &lt;code>values&lt;/code> containing strings of length 2. You are also given another string array &lt;code>dictionary&lt;/code> that contains all permitted original strings after decryption. You
should implement a data structure that can encrypt or decrypt a &lt;strong>0-indexed&lt;/strong> string.&lt;/p>
&lt;p>A string is &lt;strong>encrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each character &lt;code>c&lt;/code> in the string, we find the index &lt;code>i&lt;/code> satisfying &lt;code>keys[i] == c&lt;/code> in &lt;code>keys&lt;/code>.&lt;/li>
&lt;li>Replace &lt;code>c&lt;/code> with &lt;code>values[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>A string is &lt;strong>decrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each substring &lt;code>s&lt;/code> of length 2 occurring at an even index in the string, we find an &lt;code>i&lt;/code> such that &lt;code>values[i] == s&lt;/code>. If there are multiple valid &lt;code>i&lt;/code>, we choose &lt;strong>any&lt;/strong> one of them. This means a string could have multiple possible strings it can decrypt to.&lt;/li>
&lt;li>Replace &lt;code>s&lt;/code> with &lt;code>keys[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>Implement the &lt;code>Encrypter&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Encrypter(char[] keys, String[] values, String[] dictionary)&lt;/code> Initializes the &lt;code>Encrypter&lt;/code> class with &lt;code>keys, values&lt;/code>, and &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;li>&lt;code>String encrypt(String word1)&lt;/code> Encrypts &lt;code>word1&lt;/code> with the encryption process described above and returns the encrypted string.&lt;/li>
&lt;li>&lt;code>int decrypt(String word2)&lt;/code> Returns the number of possible strings &lt;code>word2&lt;/code> could decrypt to that also appear in &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 420. Strong Password Checker</title><link>https://tategotoazarasi.github.io/post/strong-password-checker/</link><pubDate>Sat, 02 Apr 2022 13:21:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/strong-password-checker/</guid><description>&lt;p>A password is considered strong if the below conditions are all met:&lt;/p>
&lt;ul>
&lt;li>It has at least &lt;code>6&lt;/code> characters and at most &lt;code>20&lt;/code> characters.&lt;/li>
&lt;li>It contains at least &lt;strong>one lowercase&lt;/strong> letter, at least &lt;strong>one uppercase&lt;/strong> letter, and at least &lt;strong>one digit&lt;/strong>.&lt;/li>
&lt;li>It does not contain three repeating characters in a row (i.e., &lt;code>&amp;quot;...aaa...&amp;quot;&lt;/code> is weak, but &lt;code>&amp;quot;...aa...a...&amp;quot;&lt;/code> is strong, assuming other conditions are met).&lt;/li>
&lt;/ul>
&lt;p>Given a string &lt;code>password&lt;/code>, return &lt;em>the minimum number of steps required to make &lt;code>password&lt;/code> strong. if &lt;code>password&lt;/code> is already strong, return &lt;code>0&lt;/code>.&lt;/em>&lt;/p>
&lt;p>In one step, you can:&lt;/p>
&lt;ul>
&lt;li>Insert one character to &lt;code>password&lt;/code>,&lt;/li>
&lt;li>Delete one character from &lt;code>password&lt;/code>, or&lt;/li>
&lt;li>Replace one character of &lt;code>password&lt;/code> with another character.&lt;/li>
&lt;/ul></description></item><item><title>AcWing 4319. 合适数对</title><link>https://tategotoazarasi.github.io/post/acwing4319/</link><pubDate>Sat, 26 Mar 2022 20:44:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4319/</guid><description>&lt;p>给定一个长度为 n 的正整数数列 \(a_1,a_2,&amp;hellip;,a_n\) 和一个正整数 k。&lt;/p>
&lt;p>请你判断共有多少个数对 (l,r)&lt;/p>
&lt;p>同时满足：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>1≤l&amp;lt;r≤n&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存在一个整数 x 使得 \(a_l×a_r=x^k\)成立&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 440. K-th Smallest in Lexicographical Order</title><link>https://tategotoazarasi.github.io/post/k-th-smallest-in-lexicographical-order/</link><pubDate>Wed, 23 Mar 2022 15:27:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/k-th-smallest-in-lexicographical-order/</guid><description>&lt;p>Given two integers &lt;code>n&lt;/code> and &lt;code>k&lt;/code>, return &lt;em>the&lt;/em> &lt;code>kth&lt;/code> &lt;em>lexicographically smallest integer in the range&lt;/em> &lt;code>[1, n]&lt;/code>.&lt;/p></description></item><item><title>LeetCode 6023. Minimum White Tiles After Covering With Carpets</title><link>https://tategotoazarasi.github.io/post/minimum-white-tiles-after-covering-with-carpets/</link><pubDate>Sun, 20 Mar 2022 17:49:37 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-white-tiles-after-covering-with-carpets/</guid><description>&lt;p>You are given a &lt;strong>0-indexed binary&lt;/strong> string &lt;code>floor&lt;/code>, which represents the colors of tiles on a floor:&lt;/p>
&lt;ul>
&lt;li>&lt;code>floor[i] = '0'&lt;/code> denotes that the &lt;code>ith&lt;/code> tile of the floor is colored &lt;strong>black&lt;/strong>.&lt;/li>
&lt;li>On the other hand, &lt;code>floor[i] = '1'&lt;/code> denotes that the &lt;code>ith&lt;/code> tile of the floor is colored &lt;strong>white&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>You are also given &lt;code>numCarpets&lt;/code> and &lt;code>carpetLen&lt;/code>. You have &lt;code>numCarpets&lt;/code> &lt;strong>black&lt;/strong> carpets, each of length &lt;code>carpetLen&lt;/code> tiles. Cover the tiles with the given carpets such that the number of &lt;strong>white&lt;/strong> tiles still visible is &lt;strong>minimum&lt;/strong>. Carpets may overlap one another.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>minimum&lt;/strong> number of white tiles still visible.&lt;/em>&lt;/p></description></item><item><title>LeetCode 6032. Minimum Weighted Subgraph With the Required Paths</title><link>https://tategotoazarasi.github.io/post/minimum-weighted-subgraph-with-the-required-paths/</link><pubDate>Sun, 13 Mar 2022 20:28:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-weighted-subgraph-with-the-required-paths/</guid><description>&lt;p>You are given an integer &lt;code>n&lt;/code> denoting the number of nodes of a &lt;strong>weighted directed&lt;/strong> graph. The nodes are numbered from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code>.&lt;/p>
&lt;p>You are also given a 2D integer array &lt;code>edges&lt;/code> where \(edges[i] = [from_i, to_i, weight_i]\) denotes that there exists a &lt;strong>directed&lt;/strong> edge from \(from_i\) to \(to_i\) with weight \(weight_i\).&lt;/p>
&lt;p>Lastly, you are given three &lt;strong>distinct&lt;/strong> integers &lt;code>src1&lt;/code>, &lt;code>src2&lt;/code>, and &lt;code>dest&lt;/code> denoting three distinct nodes of the graph.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>minimum weight&lt;/strong> of a subgraph of the graph such that it is &lt;strong>possible&lt;/strong> to reach&lt;/em> &lt;code>dest&lt;/code> &lt;em>from both&lt;/em> &lt;code>src1&lt;/code> &lt;em>and&lt;/em> &lt;code>src2&lt;/code> &lt;em>via a set of edges of this subgraph&lt;/em>. In case such a subgraph does not exist, return &lt;code>-1&lt;/code>.&lt;/p>
&lt;p>A &lt;strong>subgraph&lt;/strong> is a graph whose vertices and edges are subsets of the original graph. The &lt;strong>weight&lt;/strong> of a subgraph is the sum of weights of its constituent edges.&lt;/p></description></item><item><title>LeetCode 798. Smallest Rotation with Highest Score</title><link>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</link><pubDate>Wed, 09 Mar 2022 14:47:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</guid><description>&lt;p>You are given an array &lt;code>nums&lt;/code>. You can rotate it by a non-negative integer &lt;code>k&lt;/code> so that the array becomes &lt;code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]&lt;/code>. Afterward, any entries that are less than or equal to their index are worth one point.&lt;/p>
&lt;ul>
&lt;li>For example, if we have &lt;code>nums = [2,4,1,3,0]&lt;/code>, and we rotate by &lt;code>k = 2&lt;/code>, it becomes &lt;code>[1,3,0,2,4]&lt;/code>. This is worth &lt;code>3&lt;/code> points because &lt;code>1 &amp;gt; 0&lt;/code> [no points], &lt;code>3 &amp;gt; 1&lt;/code> [no points], &lt;code>0 &amp;lt;= 2&lt;/code> [one point], &lt;code>2 &amp;lt;= 3&lt;/code> [one point], &lt;code>4 &amp;lt;= 4&lt;/code> [one point].&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the rotation index&lt;/em> &lt;code>k&lt;/code> &lt;em>that corresponds to the highest score we can achieve if we rotated&lt;/em> &lt;code>nums&lt;/code> &lt;em>by it&lt;/em>. If there are multiple answers, return the smallest such index &lt;code>k&lt;/code>.&lt;/p></description></item><item><title>LeetCode 571. Find Median Given Frequency of Numbers</title><link>https://tategotoazarasi.github.io/post/find-median-given-frequency-of-numbers/</link><pubDate>Wed, 02 Mar 2022 11:09:05 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/find-median-given-frequency-of-numbers/</guid><description>&lt;p>Table: &lt;code>Numbers&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>num&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>frequency&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>num is the primary key for this table.
Each row of this table shows the frequency of a number in the database.&lt;/p>
&lt;p>The &lt;a href="https://en.wikipedia.org/wiki/Median">&lt;strong>median&lt;/strong>&lt;/a> is the value separating the higher half from the lower half of a data sample.&lt;/p>
&lt;p>Write an SQL query to report the &lt;strong>median&lt;/strong> of all the numbers in the database after decompressing the &lt;code>Numbers&lt;/code> table. Round the median to &lt;strong>one decimal point&lt;/strong>.&lt;/p></description></item><item><title>LeetCode 6011. 完成比赛的最少时间</title><link>https://tategotoazarasi.github.io/post/minimum-time-to-finish-the-race/</link><pubDate>Sun, 27 Feb 2022 16:35:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-time-to-finish-the-race/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong>  开始的二维整数数组  &lt;code>tires&lt;/code> ，其中  \(tires[i] = [f_i, r_i]\)  表示第  &lt;code>i&lt;/code>  种轮胎如果连续使用，第  &lt;code>x&lt;/code>  圈需要耗时  \(f_i * r_i^{(x-1)}\)  秒。&lt;/p>
&lt;ul>
&lt;li>比方说，如果  \(f_i = 3\)  且  \(r_i = 2\) ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第  &lt;code>1&lt;/code>  圈赛道耗时 &lt;code>3&lt;/code>  秒，完成第 &lt;code>2&lt;/code>  圈耗时  &lt;code>3 * 2 = 6&lt;/code>  秒，完成第 &lt;code>3&lt;/code>  圈耗时  \(3 * 2^2 = 12\)  秒，依次类推。&lt;/li>
&lt;/ul>
&lt;p>同时给你一个整数  &lt;code>changeTime&lt;/code>  和一个整数  &lt;code>numLaps&lt;/code> 。&lt;/p>
&lt;p>比赛总共包含  &lt;code>numLaps&lt;/code>  圈，你可以选择 &lt;strong>任意&lt;/strong>  一种轮胎开始比赛。每一种轮胎都有 &lt;strong>无数条&lt;/strong> 。每一圈后，你可以选择耗费 &lt;code>changeTime&lt;/code>  秒 &lt;strong>换成&lt;/strong>  任意一种轮胎（也可以换成当前种类的新轮胎）。&lt;/p>
&lt;p>请你返回完成比赛需要耗费的 &lt;strong>最少&lt;/strong>  时间。&lt;/p></description></item><item><title>LeetCode 1994. 好子集的数目</title><link>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</link><pubDate>Tue, 22 Feb 2022 09:23:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code> 。如果  &lt;code>nums&lt;/code>  的一个子集中，所有元素的乘积可以表示为一个或多个 &lt;strong>互不相同的质数&lt;/strong> 的乘积，那么我们称它为  &lt;strong>好子集&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>比方说，如果  &lt;code>nums = [1, 2, 3, 4]&lt;/code> ：
&lt;ul>
&lt;li>&lt;code>[2, 3]&lt;/code> ，&lt;code>[1, 2, 3]&lt;/code>  和  &lt;code>[1, 3]&lt;/code>  是 &lt;strong>好&lt;/strong>  子集，乘积分别为  &lt;code>6 = 2*3&lt;/code> ，&lt;code>6 = 2*3&lt;/code>  和  &lt;code>3 = 3&lt;/code> 。&lt;/li>
&lt;li>&lt;code>[1, 4]&lt;/code> 和  &lt;code>[4]&lt;/code>  不是 &lt;strong>好&lt;/strong>  子集，因为乘积分别为  &lt;code>4 = 2*2&lt;/code> 和  &lt;code>4 = 2*2&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>请你返回 &lt;code>nums&lt;/code>  中不同的  &lt;strong>好&lt;/strong>  子集的数目对 &lt;code>109 + 7&lt;/code> &lt;strong>取余&lt;/strong>  的结果。&lt;/p>
&lt;p>&lt;code>nums&lt;/code>  中的 &lt;strong>子集&lt;/strong>  是通过删除 &lt;code>nums&lt;/code>  中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。&lt;/p></description></item><item><title>LeetCode 6015. 统计可以被 K 整除的下标对数目</title><link>https://tategotoazarasi.github.io/post/count-array-pairs-divisible-by-k/</link><pubDate>Sun, 20 Feb 2022 12:30:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-array-pairs-divisible-by-k/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、长度为 &lt;code>n&lt;/code> 的整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，返回满足下述条件的下标对 &lt;code>(i, j)&lt;/code> 的数目：&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= i &amp;lt; j &amp;lt;= n - 1&lt;/code> 且&lt;/li>
&lt;li>&lt;code>nums[i] * nums[j]&lt;/code> 能被 &lt;code>k&lt;/code> 整除。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5999. 统计数组中好三元组数目</title><link>https://tategotoazarasi.github.io/post/count-good-triplets-in-an-array/</link><pubDate>Sun, 20 Feb 2022 09:30:44 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-good-triplets-in-an-array/</guid><description>&lt;p>给你两个下标从 &lt;strong>0&lt;/strong>  开始且长度为 &lt;code>n&lt;/code>  的整数数组  &lt;code>nums1&lt;/code>  和  &lt;code>nums2&lt;/code> ，两者都是  &lt;code>[0, 1, ..., n - 1]&lt;/code>  的  &lt;strong>排列&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>好三元组&lt;/strong> 指的是  &lt;code>3&lt;/code>  个  &lt;strong>互不相同&lt;/strong>  的值，且它们在数组  &lt;code>nums1&lt;/code> 和  &lt;code>nums2&lt;/code>  中出现顺序保持一致。换句话说，如果我们将  \(pos1_v\) 记为值  &lt;code>v&lt;/code>  在  &lt;code>nums1&lt;/code>  中出现的位置，\(pos2_v\  为值  &lt;code>v&lt;/code>  在  &lt;code>nums2&lt;/code>  中的位置，那么一个好三元组定义为  &lt;code>0 &amp;lt;= x, y, z &amp;lt;= n - 1&lt;/code> ，且  \(pos1_x &amp;lt; pos1_y &amp;lt; pos1_z\) 和  \(pos2_x &amp;lt; pos2_y &amp;lt; pos2_z\)  都成立的  &lt;code>(x, y, z)&lt;/code> 。&lt;/p>
&lt;p>请你返回好三元组的 &lt;strong>总数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 1719. Number Of Ways To Reconstruct A Tree</title><link>https://tategotoazarasi.github.io/post/number-of-ways-to-reconstruct-a-tree/</link><pubDate>Wed, 16 Feb 2022 12:23:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/number-of-ways-to-reconstruct-a-tree/</guid><description>&lt;p>You are given an array &lt;code>pairs&lt;/code>, where \(pairs[i] = [x_i, y_i]\), and:&lt;/p>
&lt;ul>
&lt;li>There are no duplicates.&lt;/li>
&lt;li>\(x_i &amp;lt; y_i\)&lt;/li>
&lt;/ul>
&lt;p>Let &lt;code>ways&lt;/code> be the number of rooted trees that satisfy the following conditions:&lt;/p>
&lt;ul>
&lt;li>The tree consists of nodes whose values appeared in &lt;code>pairs&lt;/code>.&lt;/li>
&lt;li>A pair \([x_i, y_i]\) exists in &lt;code>pairs&lt;/code> &lt;strong>if and only if&lt;/strong> \(x_i\) is an ancestor of \(y_i\) or \(y_i\) is an ancestor of \(x_i\).&lt;/li>
&lt;li>&lt;strong>Note:&lt;/strong> the tree does not have to be a binary tree.&lt;/li>
&lt;/ul>
&lt;p>Two ways are considered to be different if there is at least one node that has different parents in both ways.&lt;/p>
&lt;p>Return:&lt;/p>
&lt;ul>
&lt;li>&lt;code>0&lt;/code> if &lt;code>ways == 0&lt;/code>&lt;/li>
&lt;li>&lt;code>1&lt;/code> if &lt;code>ways == 1&lt;/code>&lt;/li>
&lt;li>&lt;code>2&lt;/code> if &lt;code>ways &amp;gt; 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>A &lt;strong>rooted tree&lt;/strong> is a tree that has a single root node, and all edges are oriented to be outgoing from the root.&lt;/p>
&lt;p>An &lt;strong>ancestor&lt;/strong> of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.&lt;/p></description></item><item><title>LeetCode 6007. 数组的最大与和</title><link>https://tategotoazarasi.github.io/post/maximum-and-sum-of-array/</link><pubDate>Sun, 13 Feb 2022 15:34:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-and-sum-of-array/</guid><description>&lt;p>给你一个长度为  &lt;code>n&lt;/code>  的整数数组  &lt;code>nums&lt;/code>  和一个整数  &lt;code>numSlots&lt;/code> ，满足&lt;code>2 * numSlots &amp;gt;= n&lt;/code> 。总共有  &lt;code>numSlots&lt;/code>  个篮子，编号为  &lt;code>1&lt;/code>  到  &lt;code>numSlots&lt;/code> 。&lt;/p>
&lt;p>你需要把所有  &lt;code>n&lt;/code>  个整数分到这些篮子中，且每个篮子 &lt;strong>至多&lt;/strong>  有 2 个整数。一种分配方案的 &lt;strong>与和&lt;/strong>  定义为每个数与它所在篮子编号的 &lt;strong>按位与运算&lt;/strong>  结果之和。&lt;/p>
&lt;ul>
&lt;li>比方说，将数字  &lt;code>[1, 3]&lt;/code>  放入篮子  &lt;strong>&lt;em>&lt;code>1&lt;/code>&lt;/em>&lt;/strong>  中，&lt;code>[4, 6]&lt;/code> 放入篮子  &lt;strong>&lt;em>&lt;code>2&lt;/code>&lt;/em>&lt;/strong>  中，这个方案的与和为  &lt;code>(1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>请你返回将 &lt;code>nums&lt;/code>  中所有数放入 &lt;code>numSlots&lt;/code>  个篮子中的最大与和。&lt;/p></description></item><item><title>LeetCode 262. Trips and Users</title><link>https://tategotoazarasi.github.io/post/trips-and-users/</link><pubDate>Fri, 11 Feb 2022 11:04:37 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/trips-and-users/</guid><description>&lt;p>Table: &lt;code>Trips&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>client_id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>driver_id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>city_id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>status&lt;/td>
&lt;td>enum&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>request_at&lt;/td>
&lt;td>date&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>id is the primary key for this table.
The table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.
Status is an ENUM type of (&amp;lsquo;completed&amp;rsquo;, &amp;lsquo;cancelled_by_driver&amp;rsquo;, &amp;lsquo;cancelled_by_client&amp;rsquo;).&lt;/p>
&lt;p>Table: &lt;code>Users&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>users_id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>banned&lt;/td>
&lt;td>enum&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>role&lt;/td>
&lt;td>enum&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>users_id is the primary key for this table.
The table holds all users. Each user has a unique users_id, and role is an ENUM type of (&amp;lsquo;client&amp;rsquo;, &amp;lsquo;driver&amp;rsquo;, &amp;lsquo;partner&amp;rsquo;).
banned is an ENUM type of (&amp;lsquo;Yes&amp;rsquo;, &amp;lsquo;No&amp;rsquo;).&lt;/p>
&lt;p>The &lt;strong>cancellation rate&lt;/strong> is computed by dividing the
number of canceled (by client or driver) requests with unbanned users by
the total number of requests with unbanned users on that day.&lt;/p>
&lt;p>Write a SQL query to find the &lt;strong>cancellation rate&lt;/strong> of requests with unbanned users (&lt;strong>both client and driver must not be banned&lt;/strong>) each day between &lt;code>&amp;quot;2013-10-01&amp;quot;&lt;/code> and &lt;code>&amp;quot;2013-10-03&amp;quot;&lt;/code>. Round &lt;code>Cancellation Rate&lt;/code> to &lt;strong>two decimal&lt;/strong> points.&lt;/p>
&lt;p>Return the result table in &lt;strong>any order&lt;/strong>.&lt;/p></description></item><item><title>LeetCode 185. Department Top Three Salaries</title><link>https://tategotoazarasi.github.io/post/department-top-three-salaries/</link><pubDate>Tue, 08 Feb 2022 18:41:34 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/department-top-three-salaries/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">Create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">If&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Exists&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">255&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">If&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Exists&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Department&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">255&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Truncate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Joe&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;85000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Henry&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;80000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;3&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sam&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;60000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;2&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;4&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Max&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;90000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;5&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Janet&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;69000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;6&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Randy&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;85000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Employee&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">salary&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">departmentId&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;7&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Will&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;70000&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Truncate&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Department&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Department&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;IT&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Department&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Sales&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Table: &lt;code>Employee&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>varchar&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>salary&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>departmentId&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>id is the primary key column for this table.
departmentId is a foreign key of the ID from the &lt;code>Department&lt;/code> table.
Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.&lt;/p>
&lt;p>Table: &lt;code>Department&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Column Name&lt;/th>
&lt;th>Type&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>int&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>varchar&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>id is the primary key column for this table.
Each row of this table indicates the ID of a department and its name.&lt;/p>
&lt;p>A company&amp;rsquo;s executives are interested in seeing who earns the most money in each of the company&amp;rsquo;s departments. A &lt;strong>high earner&lt;/strong> in a department is an employee who has a salary in the &lt;strong>top three unique&lt;/strong> salaries for that department.&lt;/p>
&lt;p>Write an SQL query to find the employees who are &lt;strong>high earners&lt;/strong> in each of the departments.&lt;/p>
&lt;p>Return the result table &lt;strong>in any order&lt;/strong>.&lt;/p>
&lt;p>The query result format is in the following example.&lt;/p></description></item><item><title>AcWing 4298. 搭档</title><link>https://tategotoazarasi.github.io/post/acwing4298/</link><pubDate>Sat, 05 Feb 2022 21:34:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4298/</guid><description>&lt;p>有 n 个男孩，每个人的魅力值依次为 a1,a2,…,an.&lt;/p>
&lt;p>有 m 个女孩，每个人的魅力值依次为 b1,b2,…,bm。&lt;/p>
&lt;p>学校举办舞会，希望选出尽可能多的男女搭档参加。&lt;/p>
&lt;p>已知，当一对男女的魅力值相差不超过 1 时，他们才会愿意组成搭档。&lt;/p>
&lt;p>请问，最多可以&lt;strong>同时&lt;/strong>凑出多少对搭档参加舞会。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>不能男男配对或女女配对。&lt;/li>
&lt;li>每个男生最多只能和一个女生配对，反之亦然。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5995. 字符串分组</title><link>https://tategotoazarasi.github.io/post/groups-of-strings/</link><pubDate>Sun, 30 Jan 2022 16:22:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/groups-of-strings/</guid><description>&lt;p>给你一个下标从  &lt;strong>0&lt;/strong> 开始的字符串数组  &lt;code>words&lt;/code> 。每个字符串都只包含 &lt;strong>小写英文字母&lt;/strong> 。&lt;code>words&lt;/code>  中任意一个子串中，每个字母都至多只出现一次。&lt;/p>
&lt;p>如果通过以下操作之一，我们可以从 &lt;code>s1&lt;/code>  的字母集合得到 &lt;code>s2&lt;/code>  的字母集合，那么我们称这两个字符串为 &lt;strong>关联的&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>往  &lt;code>s1&lt;/code>  的字母集合中添加一个字母。&lt;/li>
&lt;li>从  &lt;code>s1&lt;/code>  的字母集合中删去一个字母。&lt;/li>
&lt;li>将 &lt;code>s1&lt;/code>  中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。&lt;/li>
&lt;/ul>
&lt;p>数组  &lt;code>words&lt;/code>  可以分为一个或者多个无交集的 &lt;strong>组&lt;/strong> 。一个字符串与一个组如果满足以下 &lt;strong>任一&lt;/strong>  条件，它就属于这个组：&lt;/p>
&lt;ul>
&lt;li>它与组内 &lt;strong>至少&lt;/strong>  一个其他字符串关联。&lt;/li>
&lt;li>它是这个组中 &lt;strong>唯一&lt;/strong>  的字符串。&lt;/li>
&lt;/ul>
&lt;p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。&lt;/p>
&lt;p>请你返回一个长度为 &lt;code>2&lt;/code>  的数组  &lt;code>ans&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ans[0]&lt;/code>  是  &lt;code>words&lt;/code>  分组后的  &lt;strong>总组数&lt;/strong> 。&lt;/li>
&lt;li>&lt;code>ans[1]&lt;/code>  是字符串数目最多的组所包含的字符串数目。&lt;/li>
&lt;/ul></description></item><item><title>AcWing 4217. 机器人移动</title><link>https://tategotoazarasi.github.io/post/acwing4217/</link><pubDate>Sat, 29 Jan 2022 20:41:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4217/</guid><description>&lt;p>在一个无限大的二维平面上有一个机器人。&lt;/p>
&lt;p>初始时，机器人位于点 (0,0)。&lt;/p>
&lt;p>机器人可以执行四种行动指令：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>U&lt;/code> — 从 (x,y)移动到 (x,y+1)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>D&lt;/code> — 从 (x,y)移动到 (x,y−1)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>L&lt;/code> — 从 (x,y)移动到 (x−1,y)；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>R&lt;/code> — 从 (x,y)移动到 (x+1,y)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>给定一个长度为 n 的指令序列，指令编号 1∼n，机器人将按顺序依次执行序列中的每个行动指令。&lt;/p>
&lt;p>我们希望机器人最终抵达目标地点 (a,b)。&lt;/p>
&lt;p>为了达成这一目的，我们可能需要对指令序列进行修改。&lt;/p>
&lt;p>每次修改可以选择其中一个指令，并将其&lt;strong>替换&lt;/strong>为四种指令之一。&lt;/p>
&lt;p>注意，只能对序列中的指令进行替换，不得随意删除指令或添加额外指令。&lt;/p>
&lt;p>不妨设经过修改的指令中，编号最小的指令编号为 minID，编号最大的指令编号为 maxID。&lt;/p>
&lt;p>我们定义修改成本为 maxID−minID+1。&lt;/p>
&lt;p>例如，将 &lt;code>RRRRRRR&lt;/code> 修改为 &lt;code>RLRRLRL&lt;/code>，则编号为 2,5,7 的指令经过了修改，修改成本为 7−2+1=6。&lt;/p>
&lt;p>请你计算，为了使得机器人能够最终抵达目标点 (a,b)，所需花费的最小修改成本。&lt;/p>
&lt;p>如果不需要对序列进行修改，则成本为 0。&lt;/p></description></item><item><title>AcWing 4214. 三元组</title><link>https://tategotoazarasi.github.io/post/acwing4214/</link><pubDate>Sat, 22 Jan 2022 21:32:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4214/</guid><description>&lt;p>给定两个长度为 n 的整数序列 \(s_1,s_2,…,s_n\) 和 \(c_1,c_2,…,c_n\)。&lt;/p>
&lt;p>请你找到一个三元组 (i,j,k)，满足以下所有条件：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>i&amp;lt;j&amp;lt;k&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\(s_i&amp;lt;s_j&amp;lt;s_k\)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\(c_i+c_j+c_k\)尽可能小&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>输出 \(c_i+c_j+c_k\) 的最小可能值。&lt;/p></description></item><item><title>LeetCode 5983. 同时运行 N 台电脑的最长时间</title><link>https://tategotoazarasi.github.io/post/maximum-running-time-of-n-computers/</link><pubDate>Sun, 16 Jan 2022 12:20:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-running-time-of-n-computers/</guid><description>&lt;p>你有  &lt;code>n&lt;/code>  台电脑。给你整数  &lt;code>n&lt;/code>  和一个下标从 &lt;strong>0&lt;/strong>  开始的整数数组  &lt;code>batteries&lt;/code> ，其中第  &lt;code>i&lt;/code>  个电池可以让一台电脑 &lt;strong>运行&lt;/strong> &lt;code>batteries[i]&lt;/code>  分钟。你想使用这些电池让  &lt;strong>全部&lt;/strong> &lt;code>n&lt;/code>  台电脑 &lt;strong>同时&lt;/strong>  运行。&lt;/p>
&lt;p>一开始，你可以给每台电脑连接 &lt;strong>至多一个电池&lt;/strong> 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 &lt;strong>任意次&lt;/strong> 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。&lt;/p>
&lt;p>注意，你不能给电池充电。&lt;/p>
&lt;p>请你返回你可以让 &lt;code>n&lt;/code>  台电脑同时运行的 &lt;strong>最长&lt;/strong>  分钟数。&lt;/p></description></item><item><title>AcWing 4211. 序列重排</title><link>https://tategotoazarasi.github.io/post/acwing4211/</link><pubDate>Sat, 15 Jan 2022 20:42:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4211/</guid><description>&lt;p>给定一个长度为 n 的整数序列 \(a_1,a_2,…,a_n\)。&lt;/p>
&lt;p>请你对序列进行重新排序（也可以保持原序列），要求新序列满足每个元素（第 1 个除外）都恰好是前一个元素的两倍或前一个元素的三分之一。&lt;/p>
&lt;p>保证输入一定有解。&lt;/p></description></item><item><title>LeetCode 1036. 逃离大迷宫</title><link>https://tategotoazarasi.github.io/post/escape-a-large-maze/</link><pubDate>Tue, 11 Jan 2022 16:08:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/escape-a-large-maze/</guid><description>&lt;p>在一个 \(10^6 \times 10^6\) 的网格中，每个网格上方格的坐标为 &lt;code>(x, y)&lt;/code> 。&lt;/p>
&lt;p>现在从源方格 \(source = [s_x, s_y]\) 开始出发，意图赶往目标方格 \(target = [t_x, t_y]\) 。数组 &lt;code>blocked&lt;/code> 是封锁的方格列表，其中每个 \(blocked[i] = [x_i, y_i]\) 表示坐标为 \((x_i, y_i)\) 的方格是禁止通行的。&lt;/p>
&lt;p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 &lt;strong>不&lt;/strong> 在给出的封锁列表 &lt;code>blocked&lt;/code> 上。同时，不允许走出网格。&lt;/p>
&lt;p>只有在可以通过一系列的移动从源方格 &lt;code>source&lt;/code> 到达目标方格 &lt;code>target&lt;/code> 时才返回 &lt;code>true&lt;/code>。否则，返回 &lt;code>false&lt;/code>。&lt;/p></description></item><item><title>LeetCode 913. 猫和老鼠</title><link>https://tategotoazarasi.github.io/post/cat-and-mouse/</link><pubDate>Tue, 04 Jan 2022 22:08:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/cat-and-mouse/</guid><description>&lt;p>两位玩家分别扮演猫和老鼠，在一张 &lt;strong>无向&lt;/strong> 图上进行游戏，两人轮流行动。&lt;/p>
&lt;p>图的形式是：&lt;code>graph[a]&lt;/code> 是一个列表，由满足 &lt;code>ab&lt;/code> 是图中的一条边的所有节点 &lt;code>b&lt;/code> 组成。&lt;/p>
&lt;p>老鼠从节点 &lt;code>1&lt;/code> 开始，第一个出发；猫从节点 &lt;code>2&lt;/code> 开始，第二个出发。在节点 &lt;code>0&lt;/code> 处有一个洞。&lt;/p>
&lt;p>在每个玩家的行动中，他们 &lt;strong>必须&lt;/strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 &lt;code>1&lt;/code> ，那么它必须移动到 &lt;code>graph[1]&lt;/code> 中的任一节点。&lt;/p>
&lt;p>此外，猫无法移动到洞中（节点 &lt;code>0&lt;/code>）。&lt;/p>
&lt;p>然后，游戏在出现以下三种情形之一时结束：&lt;/p>
&lt;ul>
&lt;li>如果猫和老鼠出现在同一个节点，猫获胜。&lt;/li>
&lt;li>如果老鼠到达洞中，老鼠获胜。&lt;/li>
&lt;li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。&lt;/li>
&lt;/ul>
&lt;p>给你一张图 &lt;code>graph&lt;/code> ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p>
&lt;ul>
&lt;li>如果老鼠获胜，则返回 &lt;code>1&lt;/code>；&lt;/li>
&lt;li>如果猫获胜，则返回 &lt;code>2&lt;/code>；&lt;/li>
&lt;li>如果平局，则返回 &lt;code>0&lt;/code> 。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5970. 参加会议的最多员工数</title><link>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</link><pubDate>Sun, 02 Jan 2022 17:24:01 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</guid><description>&lt;p>一个公司准备组织一场会议，邀请名单上有  &lt;code>n&lt;/code>  位员工。公司准备了一张 &lt;strong>圆形&lt;/strong>  的桌子，可以坐下 &lt;strong>任意数目&lt;/strong>  的员工。&lt;/p>
&lt;p>员工编号为 &lt;code>0&lt;/code>  到 &lt;code>n - 1&lt;/code> 。每位员工都有一位 &lt;strong>喜欢&lt;/strong>  的员工，每位员工  &lt;strong>当且仅当&lt;/strong>  他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 &lt;strong>不会&lt;/strong>  是他自己。&lt;/p>
&lt;p>给你一个下标从 &lt;strong>0&lt;/strong>  开始的整数数组  &lt;code>favorite&lt;/code> ，其中  &lt;code>favorite[i]&lt;/code>  表示第  &lt;code>i&lt;/code>  位员工喜欢的员工。请你返回参加会议的  &lt;strong>最多员工数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item></channel></rss>