<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>困难 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%9B%B0%E9%9A%BE/</link><description>Recent content in 困难 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 15 Jan 2022 20:42:10 +0800</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%9B%B0%E9%9A%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>AcWing 4211. 序列重排</title><link>https://tategotoazarasi.github.io/post/acwing4211/</link><pubDate>Sat, 15 Jan 2022 20:42:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing4211/</guid><description>给定一个长度为 n 的整数序列 \(a_1,a_2,…,a_n\)。
请你对序列进行重新排序（也可以保持原序列），要求新序列满足每个元素（第 1 个除外）都恰好是前一个元素的两倍或前一个元素的三分之一。
保证输入一定有解。
输入格式 第一行包含整数 n。
第二行包含 n 个整数 \(a_1,a_2,…,a_n\)。
输出格式 一行 n 个整数，表示排序后的序列。
数据范围 前三个测试点满足 2≤n≤10。
所有测试点满足 \(2\le n \le 100, 1 \le a_i \le 3 \times 10^{18}\)。
输入样例 1 6 4 8 6 3 12 9 输出样例 1 9 3 6 12 4 8 输入样例 2 4 42 28 84 126 输出样例 2 126 42 84 28 输入样例 3 2 1000000000000000000 3000000000000000000 输出样例 3 3000000000000000000 1000000000000000000 #include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt; using namespace std; unsigned int no2(unsigned long long a) { unsigned int count = 0; while(a % 2 == 0) { count++; a /= 2; } return count; } unsigned int no3(unsigned long long a) { unsigned int count = 0; while(a % 3 == 0) { count++; a /= 3; } return count; } bool cmp(unsigned long long a, unsigned long long b) { const unsigned a3 = no3(a); const unsigned b3 = no3(b); if(a3 == b3) { const unsigned a2 = no2(a); const unsigned b2 = no2(b); return a2 &amp;lt; b2; } return a3 &amp;gt; b3; } int main() { unsigned short n; cin &amp;gt;&amp;gt; n; auto vec = vector&amp;lt;unsigned long long&amp;gt;(); for(unsigned short i = 0; i &amp;lt; n; i++) { unsigned long long a; cin &amp;gt;&amp;gt; a; vec.</description></item><item><title>LeetCode 1036. 逃离大迷宫</title><link>https://tategotoazarasi.github.io/post/escape-a-large-maze/</link><pubDate>Tue, 11 Jan 2022 16:08:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/escape-a-large-maze/</guid><description>&lt;p>在一个 \(10^6 x 10^6\) 的网格中，每个网格上方格的坐标为 &lt;code>(x, y)&lt;/code> 。&lt;/p>
&lt;p>现在从源方格 \(source = [s_x, s_y]\) 开始出发，意图赶往目标方格 \(target = [t_x, t_y]\) 。数组 &lt;code>blocked&lt;/code> 是封锁的方格列表，其中每个 \(blocked[i] = [x_i, y_i]\) 表示坐标为 \((x_i, y_i)\) 的方格是禁止通行的。&lt;/p>
&lt;p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 &lt;strong>不&lt;/strong> 在给出的封锁列表 &lt;code>blocked&lt;/code> 上。同时，不允许走出网格。&lt;/p>
&lt;p>只有在可以通过一系列的移动从源方格 &lt;code>source&lt;/code> 到达目标方格 &lt;code>target&lt;/code> 时才返回 &lt;code>true&lt;/code>。否则，返回 &lt;code>false&lt;/code>。&lt;/p></description></item><item><title>LeetCode 913. 猫和老鼠</title><link>https://tategotoazarasi.github.io/post/cat-and-mouse/</link><pubDate>Tue, 04 Jan 2022 22:08:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/cat-and-mouse/</guid><description>&lt;p>两位玩家分别扮演猫和老鼠，在一张 &lt;strong>无向&lt;/strong> 图上进行游戏，两人轮流行动。&lt;/p>
&lt;p>图的形式是：&lt;code>graph[a]&lt;/code> 是一个列表，由满足 &lt;code>ab&lt;/code> 是图中的一条边的所有节点 &lt;code>b&lt;/code> 组成。&lt;/p>
&lt;p>老鼠从节点 &lt;code>1&lt;/code> 开始，第一个出发；猫从节点 &lt;code>2&lt;/code> 开始，第二个出发。在节点 &lt;code>0&lt;/code> 处有一个洞。&lt;/p>
&lt;p>在每个玩家的行动中，他们 &lt;strong>必须&lt;/strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 &lt;code>1&lt;/code> ，那么它必须移动到 &lt;code>graph[1]&lt;/code> 中的任一节点。&lt;/p>
&lt;p>此外，猫无法移动到洞中（节点 &lt;code>0&lt;/code>）。&lt;/p>
&lt;p>然后，游戏在出现以下三种情形之一时结束：&lt;/p>
&lt;ul>
&lt;li>如果猫和老鼠出现在同一个节点，猫获胜。&lt;/li>
&lt;li>如果老鼠到达洞中，老鼠获胜。&lt;/li>
&lt;li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。&lt;/li>
&lt;/ul>
&lt;p>给你一张图 &lt;code>graph&lt;/code> ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p>
&lt;ul>
&lt;li>如果老鼠获胜，则返回 &lt;code>1&lt;/code>；&lt;/li>
&lt;li>如果猫获胜，则返回 &lt;code>2&lt;/code>；&lt;/li>
&lt;li>如果平局，则返回 &lt;code>0&lt;/code> 。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 5970. 参加会议的最多员工数</title><link>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</link><pubDate>Sun, 02 Jan 2022 17:24:01 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-employees-to-be-invited-to-a-meeting/</guid><description>&lt;p>一个公司准备组织一场会议，邀请名单上有  &lt;code>n&lt;/code>  位员工。公司准备了一张 &lt;strong>圆形&lt;/strong>  的桌子，可以坐下 &lt;strong>任意数目&lt;/strong>  的员工。&lt;/p>
&lt;p>员工编号为 &lt;code>0&lt;/code>  到 &lt;code>n - 1&lt;/code> 。每位员工都有一位 &lt;strong>喜欢&lt;/strong>  的员工，每位员工  &lt;strong>当且仅当&lt;/strong>  他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 &lt;strong>不会&lt;/strong>  是他自己。&lt;/p>
&lt;p>给你一个下标从 &lt;strong>0&lt;/strong>  开始的整数数组  &lt;code>favorite&lt;/code> ，其中  &lt;code>favorite[i]&lt;/code>  表示第  &lt;code>i&lt;/code>  位员工喜欢的员工。请你返回参加会议的  &lt;strong>最多员工数目&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item></channel></rss>