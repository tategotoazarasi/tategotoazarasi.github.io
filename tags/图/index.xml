<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>图 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%9B%BE/</link><description>Recent content in 图 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 26 Apr 2024 08:32:32 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%9B%BE/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 1579. 保证图可完全遍历</title><link>https://tategotoazarasi.github.io/post/remove-max-number-of-edges-to-keep-graph-fully-traversable/</link><pubDate>Sat, 24 Dec 2022 20:10:04 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-max-number-of-edges-to-keep-graph-fully-traversable/</guid><description>&lt;p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：&lt;/p>
&lt;ul>
&lt;li>类型 1：只能由 Alice 遍历。&lt;/li>
&lt;li>类型 2：只能由 Bob 遍历。&lt;/li>
&lt;li>类型 3：Alice 和 Bob 都可以遍历。&lt;/li>
&lt;/ul>
&lt;p>给你一个数组 &lt;code>edges&lt;/code> ，其中\(edges[i] = [type_i, u_i, v_i]\)  表示节点\(u_i\)和 \( v_i\) 之间存在类型为 \(type_i\) 的双向边。请你在保证图仍能够被 Alice 和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。&lt;/p>
&lt;p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。&lt;/p></description></item><item><title>LeetCode 329. 矩阵中的最长递增路径</title><link>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</link><pubDate>Mon, 19 Sep 2022 13:41:55 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 整数矩阵  &lt;code>matrix&lt;/code> ，找出其中 &lt;strong>最长递增路径&lt;/strong> 的长度。&lt;/p>
&lt;p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 &lt;strong>不能&lt;/strong> 在 &lt;strong>对角线&lt;/strong> 方向上移动或移动到 &lt;strong>边界外&lt;/strong>（即不允许环绕）。&lt;/p></description></item><item><title>LeetCode 1192. 查找集群内的「关键连接」</title><link>https://tategotoazarasi.github.io/post/critical-connections-in-a-network/</link><pubDate>Fri, 02 Sep 2022 15:40:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/critical-connections-in-a-network/</guid><description>&lt;p>力扣数据中心有  &lt;code>n&lt;/code>  台服务器，分别按从  &lt;code>0&lt;/code>  到  &lt;code>n-1&lt;/code>  的方式进行了编号。它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接  &lt;code>connections&lt;/code> 是无向的。从形式上讲，&lt;code>connections[i] = [a, b]&lt;/code>  表示服务器 &lt;code>a&lt;/code>  和 &lt;code>b&lt;/code>  之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。&lt;/p>
&lt;p>&lt;em>「关键连接」&lt;/em>  是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。&lt;/p>
&lt;p>请你以任意顺序返回该集群内的所有 「关键连接」。&lt;/p></description></item><item><title>LeetCode 310. Minimum Height Trees</title><link>https://tategotoazarasi.github.io/post/minimum-height-trees/</link><pubDate>Wed, 06 Apr 2022 15:03:31 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-height-trees/</guid><description>&lt;p>A tree is an undirected graph in which any two vertices are connected by &lt;em>exactly&lt;/em> one path. In other words, any connected graph without simple cycles is a tree.&lt;/p>
&lt;p>Given a tree of &lt;code>n&lt;/code> nodes labelled from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code>, and an array of &lt;code>n - 1&lt;/code> &lt;code>edges&lt;/code> where &lt;code>edges[i] = [ai, bi]&lt;/code> indicates that there is an undirected edge between the two nodes &lt;code>ai&lt;/code> and &lt;code>bi&lt;/code> in the tree, you can choose any node of the tree as the root. When you select a node &lt;code>x&lt;/code> as the root, the result tree has height &lt;code>h&lt;/code>. Among all possible rooted trees, those with minimum height (i.e. &lt;code>min(h)&lt;/code>)  are called &lt;strong>minimum height trees&lt;/strong> (MHTs).&lt;/p>
&lt;p>Return &lt;em>a list of all &lt;strong>MHTs&amp;rsquo;&lt;/strong> root labels&lt;/em>. You can return the answer in &lt;strong>any order&lt;/strong>.&lt;/p>
&lt;p>The &lt;strong>height&lt;/strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.&lt;/p></description></item><item><title>LeetCode 6032. Minimum Weighted Subgraph With the Required Paths</title><link>https://tategotoazarasi.github.io/post/minimum-weighted-subgraph-with-the-required-paths/</link><pubDate>Sun, 13 Mar 2022 20:28:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-weighted-subgraph-with-the-required-paths/</guid><description>&lt;p>You are given an integer &lt;code>n&lt;/code> denoting the number of nodes of a &lt;strong>weighted directed&lt;/strong> graph. The nodes are numbered from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code>.&lt;/p>
&lt;p>You are also given a 2D integer array &lt;code>edges&lt;/code> where \(edges[i] = [from_i, to_i, weight_i]\) denotes that there exists a &lt;strong>directed&lt;/strong> edge from \(from_i\) to \(to_i\) with weight \(weight_i\).&lt;/p>
&lt;p>Lastly, you are given three &lt;strong>distinct&lt;/strong> integers &lt;code>src1&lt;/code>, &lt;code>src2&lt;/code>, and &lt;code>dest&lt;/code> denoting three distinct nodes of the graph.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>minimum weight&lt;/strong> of a subgraph of the graph such that it is &lt;strong>possible&lt;/strong> to reach&lt;/em> &lt;code>dest&lt;/code> &lt;em>from both&lt;/em> &lt;code>src1&lt;/code> &lt;em>and&lt;/em> &lt;code>src2&lt;/code> &lt;em>via a set of edges of this subgraph&lt;/em>. In case such a subgraph does not exist, return &lt;code>-1&lt;/code>.&lt;/p>
&lt;p>A &lt;strong>subgraph&lt;/strong> is a graph whose vertices and edges are subsets of the original graph. The &lt;strong>weight&lt;/strong> of a subgraph is the sum of weights of its constituent edges.&lt;/p></description></item><item><title>LeetCode 1719. Number Of Ways To Reconstruct A Tree</title><link>https://tategotoazarasi.github.io/post/number-of-ways-to-reconstruct-a-tree/</link><pubDate>Wed, 16 Feb 2022 12:23:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/number-of-ways-to-reconstruct-a-tree/</guid><description>&lt;p>You are given an array &lt;code>pairs&lt;/code>, where \(pairs[i] = [x_i, y_i]\), and:&lt;/p>
&lt;ul>
&lt;li>There are no duplicates.&lt;/li>
&lt;li>\(x_i &amp;lt; y_i\)&lt;/li>
&lt;/ul>
&lt;p>Let &lt;code>ways&lt;/code> be the number of rooted trees that satisfy the following conditions:&lt;/p>
&lt;ul>
&lt;li>The tree consists of nodes whose values appeared in &lt;code>pairs&lt;/code>.&lt;/li>
&lt;li>A pair \([x_i, y_i]\) exists in &lt;code>pairs&lt;/code> &lt;strong>if and only if&lt;/strong> \(x_i\) is an ancestor of \(y_i\) or \(y_i\) is an ancestor of \(x_i\).&lt;/li>
&lt;li>&lt;strong>Note:&lt;/strong> the tree does not have to be a binary tree.&lt;/li>
&lt;/ul>
&lt;p>Two ways are considered to be different if there is at least one node that has different parents in both ways.&lt;/p>
&lt;p>Return:&lt;/p>
&lt;ul>
&lt;li>&lt;code>0&lt;/code> if &lt;code>ways == 0&lt;/code>&lt;/li>
&lt;li>&lt;code>1&lt;/code> if &lt;code>ways == 1&lt;/code>&lt;/li>
&lt;li>&lt;code>2&lt;/code> if &lt;code>ways &amp;gt; 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>A &lt;strong>rooted tree&lt;/strong> is a tree that has a single root node, and all edges are oriented to be outgoing from the root.&lt;/p>
&lt;p>An &lt;strong>ancestor&lt;/strong> of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.&lt;/p></description></item><item><title>LeetCode 913. 猫和老鼠</title><link>https://tategotoazarasi.github.io/post/cat-and-mouse/</link><pubDate>Tue, 04 Jan 2022 22:08:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/cat-and-mouse/</guid><description>&lt;p>两位玩家分别扮演猫和老鼠，在一张 &lt;strong>无向&lt;/strong> 图上进行游戏，两人轮流行动。&lt;/p>
&lt;p>图的形式是：&lt;code>graph[a]&lt;/code> 是一个列表，由满足 &lt;code>ab&lt;/code> 是图中的一条边的所有节点 &lt;code>b&lt;/code> 组成。&lt;/p>
&lt;p>老鼠从节点 &lt;code>1&lt;/code> 开始，第一个出发；猫从节点 &lt;code>2&lt;/code> 开始，第二个出发。在节点 &lt;code>0&lt;/code> 处有一个洞。&lt;/p>
&lt;p>在每个玩家的行动中，他们 &lt;strong>必须&lt;/strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 &lt;code>1&lt;/code> ，那么它必须移动到 &lt;code>graph[1]&lt;/code> 中的任一节点。&lt;/p>
&lt;p>此外，猫无法移动到洞中（节点 &lt;code>0&lt;/code>）。&lt;/p>
&lt;p>然后，游戏在出现以下三种情形之一时结束：&lt;/p>
&lt;ul>
&lt;li>如果猫和老鼠出现在同一个节点，猫获胜。&lt;/li>
&lt;li>如果老鼠到达洞中，老鼠获胜。&lt;/li>
&lt;li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。&lt;/li>
&lt;/ul>
&lt;p>给你一张图 &lt;code>graph&lt;/code> ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p>
&lt;ul>
&lt;li>如果老鼠获胜，则返回 &lt;code>1&lt;/code>；&lt;/li>
&lt;li>如果猫获胜，则返回 &lt;code>2&lt;/code>；&lt;/li>
&lt;li>如果平局，则返回 &lt;code>0&lt;/code> 。&lt;/li>
&lt;/ul></description></item></channel></rss>