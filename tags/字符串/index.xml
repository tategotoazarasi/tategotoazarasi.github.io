<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字符串 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><description>Recent content in 字符串 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 04 Jun 2024 08:32:35 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 127. 单词接龙</title><link>https://tategotoazarasi.github.io/post/word-ladder/</link><pubDate>Tue, 03 Jan 2023 14:52:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-ladder/</guid><description>&lt;p>字典  &lt;code>wordList&lt;/code> 中从单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 的&lt;strong>转换序列&lt;/strong>是一个按下述规格形成的序列&lt;/p>
&lt;p>\(beginWord \to s_1 \to s_2 \to \dots \to s_k\)：&lt;/p>
&lt;ul>
&lt;li>每一对相邻的单词只差一个字母。&lt;/li>
&lt;li>对于  &lt;code>1 &amp;lt;= i &amp;lt;= k&lt;/code>  时，每个 \(s_i\)  都在&lt;code>wordList&lt;/code>  中。注意， &lt;code>beginWord&lt;/code> 不需要在&lt;code>wordList&lt;/code>  中。&lt;/li>
&lt;li>\(s_k == endWord\)&lt;/li>
&lt;/ul>
&lt;p>给你两个单词 &lt;code>beginWord&lt;/code>和 &lt;code>endWord&lt;/code> 和一个字典 &lt;code>wordList&lt;/code> ，返回从  &lt;code>beginWord&lt;/code> 到  &lt;code>endWord&lt;/code> 的&lt;strong>最短转换序列&lt;/strong>中的&lt;strong>单词数目&lt;/strong>。如果不存在这样的转换序列，返回 &lt;code>0&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 212. 单词搜索 II</title><link>https://tategotoazarasi.github.io/post/word-search-ii/</link><pubDate>Tue, 27 Dec 2022 15:20:42 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-search-ii/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 二维字符网格  &lt;code>board&lt;/code> 和一个单词（字符串）列表&lt;code>words&lt;/code>，&lt;em>返回所有二维网格上的单词&lt;/em> 。&lt;/p>
&lt;p>单词必须按照字母顺序，通过 &lt;strong>相邻的单元格&lt;/strong>内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。&lt;/p></description></item><item><title>LeetCode 214. 最短回文串</title><link>https://tategotoazarasi.github.io/post/shortest-palindrome/</link><pubDate>Tue, 06 Dec 2022 17:19:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-palindrome/</guid><description>&lt;p>给定一个字符串&lt;strong>s&lt;/strong>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p></description></item><item><title>LeetCode 44. 通配符匹配</title><link>https://tategotoazarasi.github.io/post/wildcard-matching/</link><pubDate>Tue, 06 Dec 2022 14:03:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/wildcard-matching/</guid><description>&lt;p>给定一个字符串  (&lt;code>s&lt;/code>) 和一个字符模式  (&lt;code>p&lt;/code>)，实现一个支持  &lt;code>'?'&lt;/code>  和  &lt;code>'*'&lt;/code>  的通配符匹配。&lt;/p></description></item><item><title>LeetCode 301. 删除无效的括号</title><link>https://tategotoazarasi.github.io/post/remove-invalid-parentheses/</link><pubDate>Tue, 06 Sep 2022 13:11:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/remove-invalid-parentheses/</guid><description>&lt;p>给你一个由若干括号和字母组成的字符串 &lt;code>s&lt;/code>，删除最小数量的无效括号，使得输入的字符串有效。&lt;/p>
&lt;p>返回所有可能的结果。答案可以按 &lt;strong>任意顺序&lt;/strong> 返回。&lt;/p></description></item><item><title>LeetCode 76. 最小覆盖子串</title><link>https://tategotoazarasi.github.io/post/minimum-window-substring/</link><pubDate>Mon, 29 Aug 2022 17:02:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-window-substring/</guid><description>&lt;p>给你一个字符串 &lt;code>s&lt;/code> 、一个字符串 &lt;code>t&lt;/code> 。返回 &lt;code>s&lt;/code> 中涵盖 &lt;code>t&lt;/code> 所有字符的最小子串。如果 &lt;code>s&lt;/code> 中不存在涵盖 &lt;code>t&lt;/code> 所有字符的子串，则返回空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 166. Fraction to Recurring Decimal</title><link>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</link><pubDate>Tue, 21 Jun 2022 15:53:27 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</guid><description>&lt;p>Given two integers representing the &lt;code>numerator&lt;/code> and &lt;code>denominator&lt;/code> of a fraction, return &lt;em>the fraction in string format&lt;/em>.&lt;/p>
&lt;p>If the fractional part is repeating, enclose the repeating part in parentheses.&lt;/p>
&lt;p>If multiple answers are possible, return &lt;strong>any of them&lt;/strong>.&lt;/p>
&lt;p>It is &lt;strong>guaranteed&lt;/strong> that the length of the answer string is less than &lt;code>104&lt;/code> for all the given inputs.&lt;/p></description></item><item><title>LeetCode 5. Longest Palindromic Substring</title><link>https://tategotoazarasi.github.io/post/longest-palindromic-substring/</link><pubDate>Wed, 08 Jun 2022 13:14:02 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-palindromic-substring/</guid><description>&lt;p>Given a string &lt;code>s&lt;/code>, return &lt;em>the longest palindromic substring&lt;/em> in &lt;code>s&lt;/code>.&lt;/p></description></item><item><title>AcWing 1883. 删减</title><link>https://tategotoazarasi.github.io/post/acwing1883/</link><pubDate>Fri, 15 Apr 2022 13:43:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/acwing1883/</guid><description>&lt;p>农夫约翰把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过 106 的字符串 S。&lt;/p>
&lt;p>他希望从 S 中删除子串 T。&lt;/p>
&lt;p>农夫约翰在 S 中从头开始寻找子串 T，一旦找到，就将它从 S 中删除，然后再次&lt;strong>从头开始&lt;/strong>寻找（而不是接着往下找）。&lt;/p>
&lt;p>他重复这个操作直到 S 中没有子串 T 为止。&lt;/p>
&lt;p>注意，删除一个子串 T 可能会导致一个新的子串 T 的出现。&lt;/p>
&lt;p>请帮助约翰完成这些操作并输出最后的 S。&lt;/p></description></item><item><title>LeetCode 6036. Sum of Scores of Built Strings</title><link>https://tategotoazarasi.github.io/post/sum-of-scores-of-built-strings/</link><pubDate>Sun, 03 Apr 2022 17:48:50 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-scores-of-built-strings/</guid><description>&lt;p>You are &lt;strong>building&lt;/strong> a string &lt;code>s&lt;/code> of length &lt;code>n&lt;/code> &lt;strong>one&lt;/strong> character at a time, &lt;strong>prepending&lt;/strong> each new character to the &lt;strong>front&lt;/strong> of the string. The strings are labeled from &lt;code>1&lt;/code> to &lt;code>n&lt;/code>, where the string with length &lt;code>i&lt;/code> is labeled \(s_i\).&lt;/p>
&lt;ul>
&lt;li>For example, for \(s = &amp;ldquo;abaca&amp;rdquo;, s_1 == &amp;ldquo;a&amp;rdquo;, s_2 == &amp;ldquo;ca&amp;rdquo;, s_3 == &amp;ldquo;aca&amp;rdquo;\), etc.&lt;/li>
&lt;/ul>
&lt;p>The &lt;strong>score&lt;/strong> of \(s_i\) is the length of the &lt;strong>longest common prefix&lt;/strong> between \(s_i\) and \(s_n\) (Note that \(s == s_n\)).&lt;/p>
&lt;p>Given the final string &lt;code>s&lt;/code>, return &lt;em>the &lt;strong>sum&lt;/strong> of the &lt;strong>score&lt;/strong> of every&lt;/em> \(s_i\).&lt;/p></description></item><item><title>LeetCode 5302. Encrypt and Decrypt Strings</title><link>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</link><pubDate>Sun, 03 Apr 2022 17:10:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/encrypt-and-decrypt-strings/</guid><description>&lt;p>You are given a character array &lt;code>keys&lt;/code> containing &lt;strong>unique&lt;/strong> characters and a string array &lt;code>values&lt;/code> containing strings of length 2. You are also given another string array &lt;code>dictionary&lt;/code> that contains all permitted original strings after decryption. You
should implement a data structure that can encrypt or decrypt a &lt;strong>0-indexed&lt;/strong> string.&lt;/p>
&lt;p>A string is &lt;strong>encrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each character &lt;code>c&lt;/code> in the string, we find the index &lt;code>i&lt;/code> satisfying &lt;code>keys[i] == c&lt;/code> in &lt;code>keys&lt;/code>.&lt;/li>
&lt;li>Replace &lt;code>c&lt;/code> with &lt;code>values[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>A string is &lt;strong>decrypted&lt;/strong> with the following process:&lt;/p>
&lt;ol>
&lt;li>For each substring &lt;code>s&lt;/code> of length 2 occurring at an even index in the string, we find an &lt;code>i&lt;/code> such that &lt;code>values[i] == s&lt;/code>. If there are multiple valid &lt;code>i&lt;/code>, we choose &lt;strong>any&lt;/strong> one of them. This means a string could have multiple possible strings it can decrypt to.&lt;/li>
&lt;li>Replace &lt;code>s&lt;/code> with &lt;code>keys[i]&lt;/code> in the string.&lt;/li>
&lt;/ol>
&lt;p>Implement the &lt;code>Encrypter&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Encrypter(char[] keys, String[] values, String[] dictionary)&lt;/code> Initializes the &lt;code>Encrypter&lt;/code> class with &lt;code>keys, values&lt;/code>, and &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;li>&lt;code>String encrypt(String word1)&lt;/code> Encrypts &lt;code>word1&lt;/code> with the encryption process described above and returns the encrypted string.&lt;/li>
&lt;li>&lt;code>int decrypt(String word2)&lt;/code> Returns the number of possible strings &lt;code>word2&lt;/code> could decrypt to that also appear in &lt;code>dictionary&lt;/code>.&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 420. Strong Password Checker</title><link>https://tategotoazarasi.github.io/post/strong-password-checker/</link><pubDate>Sat, 02 Apr 2022 13:21:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/strong-password-checker/</guid><description>&lt;p>A password is considered strong if the below conditions are all met:&lt;/p>
&lt;ul>
&lt;li>It has at least &lt;code>6&lt;/code> characters and at most &lt;code>20&lt;/code> characters.&lt;/li>
&lt;li>It contains at least &lt;strong>one lowercase&lt;/strong> letter, at least &lt;strong>one uppercase&lt;/strong> letter, and at least &lt;strong>one digit&lt;/strong>.&lt;/li>
&lt;li>It does not contain three repeating characters in a row (i.e., &lt;code>&amp;quot;...aaa...&amp;quot;&lt;/code> is weak, but &lt;code>&amp;quot;...aa...a...&amp;quot;&lt;/code> is strong, assuming other conditions are met).&lt;/li>
&lt;/ul>
&lt;p>Given a string &lt;code>password&lt;/code>, return &lt;em>the minimum number of steps required to make &lt;code>password&lt;/code> strong. if &lt;code>password&lt;/code> is already strong, return &lt;code>0&lt;/code>.&lt;/em>&lt;/p>
&lt;p>In one step, you can:&lt;/p>
&lt;ul>
&lt;li>Insert one character to &lt;code>password&lt;/code>,&lt;/li>
&lt;li>Delete one character from &lt;code>password&lt;/code>, or&lt;/li>
&lt;li>Replace one character of &lt;code>password&lt;/code> with another character.&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 1763. 最长的美好子字符串</title><link>https://tategotoazarasi.github.io/post/longest-nice-substring/</link><pubDate>Tue, 01 Feb 2022 19:52:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-nice-substring/</guid><description>&lt;p>当一个字符串 &lt;code>s&lt;/code>  包含的每一种字母的大写和小写形式 &lt;strong>同时&lt;/strong>  出现在 &lt;code>s&lt;/code>  中，就称这个字符串  &lt;code>s&lt;/code>  是 &lt;strong>美好&lt;/strong> 字符串。比方说，&lt;code>&amp;quot;abABB&amp;quot;&lt;/code>  是美好字符串，因为  &lt;code>'A'&lt;/code> 和  &lt;code>'a'&lt;/code>  同时出现了，且  &lt;code>'B'&lt;/code> 和  &lt;code>'b'&lt;/code>  也同时出现了。然而，&lt;code>&amp;quot;abA&amp;quot;&lt;/code>  不是美好字符串因为  &lt;code>'b'&lt;/code>  出现了，而  &lt;code>'B'&lt;/code>  没有出现。&lt;/p>
&lt;p>给你一个字符串  &lt;code>s&lt;/code> ，请你返回  &lt;code>s&lt;/code>  最长的  &lt;strong>美好子字符串&lt;/strong> 。如果有多个答案，请你返回  &lt;strong>最早&lt;/strong>  出现的一个。如果不存在美好子字符串，请你返回一个空字符串。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item><item><title>LeetCode 5948. 判断一个括号字符串是否有效</title><link>https://tategotoazarasi.github.io/post/check-if-a-parentheses-string-can-be-valid/</link><pubDate>Sun, 26 Dec 2021 09:22:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/check-if-a-parentheses-string-can-be-valid/</guid><description>&lt;p>一个括号字符串是只由  &lt;code>'('&lt;/code> 和  &lt;code>')'&lt;/code>  组成的  &lt;strong>非空&lt;/strong>  字符串。如果一个字符串满足下面 &lt;strong>任意&lt;/strong>  一个条件，那么它就是有效的：&lt;/p>
&lt;ul>
&lt;li>字符串为  &lt;code>()&lt;/code>.&lt;/li>
&lt;li>它可以表示为 &lt;code>AB&lt;/code>（&lt;code>A&lt;/code>  与  &lt;code>B&lt;/code>  连接），其中&lt;code>A&lt;/code> 和  &lt;code>B&lt;/code>  都是有效括号字符串。&lt;/li>
&lt;li>它可以表示为  &lt;code>(A)&lt;/code> ，其中  &lt;code>A&lt;/code>  是一个有效括号字符串。&lt;/li>
&lt;/ul>
&lt;p>给你一个括号字符串  &lt;code>s&lt;/code>  和一个字符串  &lt;code>locked&lt;/code> ，两者长度都为  &lt;code>n&lt;/code> 。&lt;code>locked&lt;/code>  是一个二进制字符串，只包含  &lt;code>'0'&lt;/code>  和  &lt;code>'1'&lt;/code> 。对于  &lt;code>locked&lt;/code>  中  &lt;strong>每一个&lt;/strong>  下标  &lt;code>i&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>如果  &lt;code>locked[i]&lt;/code>  是  &lt;code>'1'&lt;/code> ，你 &lt;strong>不能&lt;/strong>  改变  &lt;code>s[i]&lt;/code> 。&lt;/li>
&lt;li>如果  &lt;code>locked[i]&lt;/code>  是  &lt;code>'0'&lt;/code> ，你  &lt;strong>可以&lt;/strong>  将  &lt;code>s[i]&lt;/code>  变为  &lt;code>'('&lt;/code>  或者  &lt;code>')'&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;p>如果你可以将 &lt;code>s&lt;/code>  变为有效括号字符串，请你返回  &lt;code>true&lt;/code> ，否则返回  &lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 168. Excel表列名称</title><link>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</link><pubDate>Sat, 25 Dec 2021 10:33:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</guid><description>&lt;p>给你一个整数 &lt;code>columnNumber&lt;/code> ，返回它在 Excel 表中相对应的列名称。&lt;/p></description></item><item><title>LeetCode 28. 实现 strStr()</title><link>https://tategotoazarasi.github.io/post/implement-strstr/</link><pubDate>Tue, 07 Dec 2021 10:17:21 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/implement-strstr/</guid><description>&lt;p>实现 &lt;a href="https://baike.baidu.com/item/strstr/811469">strStr()&lt;/a> 函数。&lt;/p>
&lt;p>给你两个字符串 &lt;code>haystack&lt;/code> 和 &lt;code>needle&lt;/code> ，请你在 &lt;code>haystack&lt;/code> 字符串中找出 &lt;code>needle&lt;/code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item></channel></rss>