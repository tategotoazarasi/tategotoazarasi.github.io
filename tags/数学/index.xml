<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数学 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E6%95%B0%E5%AD%A6/</link><description>Recent content in 数学 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 30 Apr 2024 06:51:37 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 1588. 所有奇数长度子数组的和</title><link>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</link><pubDate>Fri, 02 Dec 2022 14:13:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</guid><description>&lt;p>给你一个正整数数组 &lt;code>arr&lt;/code> ，请你计算所有可能的奇数长度子数组的和。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 定义为原数组中的一个连续子序列。&lt;/p>
&lt;p>请你返回 &lt;code>arr&lt;/code> 中 &lt;strong>所有奇数长度子数组的和&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 486. 预测赢家</title><link>https://tategotoazarasi.github.io/post/predict-the-winner/</link><pubDate>Tue, 13 Sep 2022 13:43:09 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/predict-the-winner/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。&lt;/p>
&lt;p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 &lt;code>0&lt;/code>。每一回合，玩家从数组的任意一端取一个数字（即，&lt;code>nums[0]&lt;/code> 或&lt;code>nums[nums.length - 1]&lt;/code>），取到的数字将会从数组中移除（数组长度减 &lt;code>1&lt;/code>）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。&lt;/p>
&lt;p>如果玩家 1 能成为赢家，返回 &lt;code>true&lt;/code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 &lt;code>true&lt;/code>。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p></description></item><item><title>LeetCode 166. Fraction to Recurring Decimal</title><link>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</link><pubDate>Tue, 21 Jun 2022 15:53:27 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/fraction-to-recurring-decimal/</guid><description>&lt;p>Given two integers representing the &lt;code>numerator&lt;/code> and &lt;code>denominator&lt;/code> of a fraction, return &lt;em>the fraction in string format&lt;/em>.&lt;/p>
&lt;p>If the fractional part is repeating, enclose the repeating part in parentheses.&lt;/p>
&lt;p>If multiple answers are possible, return &lt;strong>any of them&lt;/strong>.&lt;/p>
&lt;p>It is &lt;strong>guaranteed&lt;/strong> that the length of the answer string is less than &lt;code>104&lt;/code> for all the given inputs.&lt;/p></description></item><item><title>LeetCode 29. Divide Two Integers</title><link>https://tategotoazarasi.github.io/post/divide-two-integers/</link><pubDate>Tue, 21 Jun 2022 15:53:24 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/divide-two-integers/</guid><description>&lt;p>Given two integers &lt;code>dividend&lt;/code> and &lt;code>divisor&lt;/code>, divide two integers &lt;strong>without&lt;/strong> using multiplication, division, and mod operator.&lt;/p>
&lt;p>The integer division should truncate toward zero, which means losing its fractional part. For example, &lt;code>8.345&lt;/code> would be truncated to &lt;code>8&lt;/code>, and &lt;code>-2.7335&lt;/code> would be truncated to &lt;code>-2&lt;/code>.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>quotient&lt;/strong> after dividing&lt;/em> &lt;code>dividend&lt;/code> &lt;em>by&lt;/em> &lt;code>divisor&lt;/code>.&lt;/p></description></item><item><title>LeetCode 50. Pow(x, n)</title><link>https://tategotoazarasi.github.io/post/powx-n/</link><pubDate>Tue, 21 Jun 2022 15:53:22 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/powx-n/</guid><description>&lt;p>Implement &lt;a href="http://www.cplusplus.com/reference/valarray/pow/">pow(x, n)&lt;/a>, which calculates &lt;code>x&lt;/code> raised to the power &lt;code>n&lt;/code> (i.e., \(x^n\)).&lt;/p></description></item><item><title>LeetCode 380. Insert Delete GetRandom O(1)</title><link>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</link><pubDate>Wed, 13 Apr 2022 15:22:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</guid><description>&lt;p>实现&lt;code>RandomizedSet&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RandomizedSet()&lt;/code> 初始化 &lt;code>RandomizedSet&lt;/code> 对象&lt;/li>
&lt;li>&lt;code>bool insert(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 不存在时，向集合中插入该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>bool remove(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 存在时，从集合中移除该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>int getRandom()&lt;/code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 &lt;strong>相同的概率&lt;/strong> 被返回。&lt;/li>
&lt;/ul>
&lt;p>你必须实现类的所有函数，并满足每个函数的 &lt;strong>平均&lt;/strong> 时间复杂度为 &lt;code>O(1)&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 780. Reaching Points</title><link>https://tategotoazarasi.github.io/post/reaching-points/</link><pubDate>Sat, 09 Apr 2022 14:26:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/reaching-points/</guid><description>&lt;p>Given four integers &lt;code>sx&lt;/code>, &lt;code>sy&lt;/code>, &lt;code>tx&lt;/code>, and &lt;code>ty&lt;/code>, return &lt;code>true&lt;/code> &lt;em>if it is possible to convert the point&lt;/em> &lt;code>(sx, sy)&lt;/code> &lt;em>to the point&lt;/em> &lt;code>(tx, ty)&lt;/code> &lt;em>through some operations**, or&lt;/em> &lt;code>false&lt;/code> &lt;em>otherwise&lt;/em>.&lt;/p>
&lt;p>The allowed operation on some point &lt;code>(x, y)&lt;/code> is to convert it to either &lt;code>(x, x + y)&lt;/code> or &lt;code>(x + y, y)&lt;/code>.&lt;/p></description></item><item><title>LeetCode 258. Add Digits</title><link>https://tategotoazarasi.github.io/post/add-digits/</link><pubDate>Thu, 03 Mar 2022 13:13:27 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/add-digits/</guid><description>&lt;p>Given an integer &lt;code>num&lt;/code>, repeatedly add all its digits until the result has only one digit, and return it.&lt;/p></description></item><item><title>LeetCode 1994. 好子集的数目</title><link>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</link><pubDate>Tue, 22 Feb 2022 09:23:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code> 。如果  &lt;code>nums&lt;/code>  的一个子集中，所有元素的乘积可以表示为一个或多个 &lt;strong>互不相同的质数&lt;/strong> 的乘积，那么我们称它为  &lt;strong>好子集&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>比方说，如果  &lt;code>nums = [1, 2, 3, 4]&lt;/code> ：
&lt;ul>
&lt;li>&lt;code>[2, 3]&lt;/code> ，&lt;code>[1, 2, 3]&lt;/code>  和  &lt;code>[1, 3]&lt;/code>  是 &lt;strong>好&lt;/strong>  子集，乘积分别为  &lt;code>6 = 2*3&lt;/code> ，&lt;code>6 = 2*3&lt;/code>  和  &lt;code>3 = 3&lt;/code> 。&lt;/li>
&lt;li>&lt;code>[1, 4]&lt;/code> 和  &lt;code>[4]&lt;/code>  不是 &lt;strong>好&lt;/strong>  子集，因为乘积分别为  &lt;code>4 = 2*2&lt;/code> 和  &lt;code>4 = 2*2&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>请你返回 &lt;code>nums&lt;/code>  中不同的  &lt;strong>好&lt;/strong>  子集的数目对 &lt;code>109 + 7&lt;/code> &lt;strong>取余&lt;/strong>  的结果。&lt;/p>
&lt;p>&lt;code>nums&lt;/code>  中的 &lt;strong>子集&lt;/strong>  是通过删除 &lt;code>nums&lt;/code>  中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。&lt;/p></description></item><item><title>LeetCode 6015. 统计可以被 K 整除的下标对数目</title><link>https://tategotoazarasi.github.io/post/count-array-pairs-divisible-by-k/</link><pubDate>Sun, 20 Feb 2022 12:30:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-array-pairs-divisible-by-k/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、长度为 &lt;code>n&lt;/code> 的整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，返回满足下述条件的下标对 &lt;code>(i, j)&lt;/code> 的数目：&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= i &amp;lt; j &amp;lt;= n - 1&lt;/code> 且&lt;/li>
&lt;li>&lt;code>nums[i] * nums[j]&lt;/code> 能被 &lt;code>k&lt;/code> 整除。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 382. 链表随机节点</title><link>https://tategotoazarasi.github.io/post/linked-list-random-node/</link><pubDate>Sun, 16 Jan 2022 10:00:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/linked-list-random-node/</guid><description>&lt;p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 &lt;strong>被选中的概率一样&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 89. 格雷编码</title><link>https://tategotoazarasi.github.io/post/gray-code/</link><pubDate>Sat, 08 Jan 2022 16:57:11 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/gray-code/</guid><description>&lt;p>&lt;strong>n 位格雷码序列&lt;/strong> 是一个由 &lt;code>2n&lt;/code> 个整数组成的序列，其中：&lt;/p>
&lt;ul>
&lt;li>每个整数都在范围 &lt;code>[0, 2n - 1]&lt;/code> 内（含 &lt;code>0&lt;/code> 和 &lt;code>2n - 1&lt;/code>）&lt;/li>
&lt;li>第一个整数是 &lt;code>0&lt;/code>&lt;/li>
&lt;li>一个整数在序列中出现 &lt;strong>不超过一次&lt;/strong>&lt;/li>
&lt;li>每对 &lt;strong>相邻&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong> ，且&lt;/li>
&lt;li>&lt;strong>第一个&lt;/strong> 和 &lt;strong>最后一个&lt;/strong> 整数的二进制表示 &lt;strong>恰好一位不同&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>给你一个整数 &lt;code>n&lt;/code> ，返回任一有效的 &lt;strong>n 位格雷码序列&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 913. 猫和老鼠</title><link>https://tategotoazarasi.github.io/post/cat-and-mouse/</link><pubDate>Tue, 04 Jan 2022 22:08:53 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/cat-and-mouse/</guid><description>&lt;p>两位玩家分别扮演猫和老鼠，在一张 &lt;strong>无向&lt;/strong> 图上进行游戏，两人轮流行动。&lt;/p>
&lt;p>图的形式是：&lt;code>graph[a]&lt;/code> 是一个列表，由满足 &lt;code>ab&lt;/code> 是图中的一条边的所有节点 &lt;code>b&lt;/code> 组成。&lt;/p>
&lt;p>老鼠从节点 &lt;code>1&lt;/code> 开始，第一个出发；猫从节点 &lt;code>2&lt;/code> 开始，第二个出发。在节点 &lt;code>0&lt;/code> 处有一个洞。&lt;/p>
&lt;p>在每个玩家的行动中，他们 &lt;strong>必须&lt;/strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 &lt;code>1&lt;/code> ，那么它必须移动到 &lt;code>graph[1]&lt;/code> 中的任一节点。&lt;/p>
&lt;p>此外，猫无法移动到洞中（节点 &lt;code>0&lt;/code>）。&lt;/p>
&lt;p>然后，游戏在出现以下三种情形之一时结束：&lt;/p>
&lt;ul>
&lt;li>如果猫和老鼠出现在同一个节点，猫获胜。&lt;/li>
&lt;li>如果老鼠到达洞中，老鼠获胜。&lt;/li>
&lt;li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。&lt;/li>
&lt;/ul>
&lt;p>给你一张图 &lt;code>graph&lt;/code> ，并假设两位玩家都都以最佳状态参与游戏：&lt;/p>
&lt;ul>
&lt;li>如果老鼠获胜，则返回 &lt;code>1&lt;/code>；&lt;/li>
&lt;li>如果猫获胜，则返回 &lt;code>2&lt;/code>；&lt;/li>
&lt;li>如果平局，则返回 &lt;code>0&lt;/code> 。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 390. 消除游戏</title><link>https://tategotoazarasi.github.io/post/elimination-game/</link><pubDate>Sun, 02 Jan 2022 17:04:49 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/elimination-game/</guid><description>&lt;p>给定一个从 1 到 n 排序的整数列表。&lt;br>
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。&lt;br>
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。&lt;br>
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。&lt;br>
返回长度为 n 的列表中，最后剩下的数字。&lt;/p></description></item><item><title>LeetCode 168. Excel表列名称</title><link>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</link><pubDate>Sat, 25 Dec 2021 10:33:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/excel-sheet-column-title/</guid><description>&lt;p>给你一个整数 &lt;code>columnNumber&lt;/code> ，返回它在 Excel 表中相对应的列名称。&lt;/p></description></item></channel></rss>