<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数组 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E6%95%B0%E7%BB%84/</link><description>Recent content in 数组 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 18 Feb 2024 12:43:06 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 324. 摆动排序 II</title><link>https://tategotoazarasi.github.io/post/wiggle-sort-ii/</link><pubDate>Sun, 01 Jan 2023 17:10:05 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/wiggle-sort-ii/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code>，将它重新排列成  &lt;code>nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]...&lt;/code>  的顺序。&lt;/p>
&lt;p>你可以假设所有输入数组都可以得到满足题目要求的结果。&lt;/p></description></item><item><title>LeetCode 212. 单词搜索 II</title><link>https://tategotoazarasi.github.io/post/word-search-ii/</link><pubDate>Tue, 27 Dec 2022 15:20:42 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/word-search-ii/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 二维字符网格  &lt;code>board&lt;/code> 和一个单词（字符串）列表&lt;code>words&lt;/code>，&lt;em>返回所有二维网格上的单词&lt;/em> 。&lt;/p>
&lt;p>单词必须按照字母顺序，通过 &lt;strong>相邻的单元格&lt;/strong>内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。&lt;/p></description></item><item><title>LeetCode 218. 天际线问题</title><link>https://tategotoazarasi.github.io/post/the-skyline-problem/</link><pubDate>Sun, 25 Dec 2022 20:56:06 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-skyline-problem/</guid><description>&lt;p>城市的 &lt;strong>天际线&lt;/strong>是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 *由这些建筑物形成的 &lt;strong>天际线*&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 862. 和至少为 K 的最短子数组</title><link>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</link><pubDate>Wed, 21 Dec 2022 21:15:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/shortest-subarray-with-sum-at-least-k/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，找出 &lt;code>nums&lt;/code> 中和至少为 &lt;code>k&lt;/code> 的
&lt;strong>最短非空子数组&lt;/strong> ，并返回该子数组的长度。如果不存在这样的 &lt;strong>子数组&lt;/strong>
，返回 &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 84. 柱状图中最大的矩形</title><link>https://tategotoazarasi.github.io/post/largest-rectangle-in-histogram/</link><pubDate>Wed, 21 Dec 2022 19:22:16 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/largest-rectangle-in-histogram/</guid><description>&lt;p>给定 &lt;em>n&lt;/em>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。&lt;/p>
&lt;p>求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p></description></item><item><title>LeetCode 456. 132 模式</title><link>https://tategotoazarasi.github.io/post/132-pattern/</link><pubDate>Wed, 21 Dec 2022 18:14:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/132-pattern/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，数组中共有 &lt;code>n&lt;/code> 个整数。&lt;strong>132 模式的子序列&lt;/strong>由三个整数 &lt;code>nums[i]&lt;/code>、&lt;code>nums[j]&lt;/code> 和 &lt;code>nums[k]&lt;/code>组成，并同时满足：&lt;code>i &amp;lt; j &amp;lt; k&lt;/code> 和 &lt;code>nums[i] &amp;lt; nums[k] &amp;lt; nums[j]&lt;/code> 。&lt;/p>
&lt;p>如果 &lt;code>nums&lt;/code> 中存在 &lt;strong>132 模式的子序列&lt;/strong> ，返回 &lt;code>true&lt;/code> ；否则，返回&lt;code>false&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 452. 用最少数量的箭引爆气球</title><link>https://tategotoazarasi.github.io/post/minimum-number-of-arrows-to-burst-balloons/</link><pubDate>Fri, 02 Dec 2022 15:26:34 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-number-of-arrows-to-burst-balloons/</guid><description>&lt;p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组  &lt;code>points&lt;/code> ，其中 \(points[i] = [x_{start}, x_{end}]\)  表示水平直径在  \(x*{start}\)  和 \(x*{end}\)之间的气球。你不知道气球的确切 y 坐标。&lt;/p>
&lt;p>一支弓箭可以沿着 x 轴从不同点 &lt;strong>完全垂直&lt;/strong> 地射出。在坐标 &lt;code>x&lt;/code>处射出一支箭，若有一个气球的直径的开始和结束坐标为 \(x*{start}\)，\(x*{end}\)， 且满足  \(x*{start} ≤ x ≤ x*{end}\)，则该气球会被&lt;strong>引爆&lt;/strong>。可以射出的弓箭的数量 &lt;strong>没有限制&lt;/strong> 。弓箭一旦被射出之后，可以无限地前进。&lt;/p>
&lt;p>给你一个数组 &lt;code>points&lt;/code> ，返回引爆所有气球所必须射出的 &lt;strong>最小&lt;/strong>弓箭数。&lt;/p></description></item><item><title>LeetCode 1588. 所有奇数长度子数组的和</title><link>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</link><pubDate>Fri, 02 Dec 2022 14:13:41 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-all-odd-length-subarrays/</guid><description>&lt;p>给你一个正整数数组 &lt;code>arr&lt;/code> ，请你计算所有可能的奇数长度子数组的和。&lt;/p>
&lt;p>&lt;strong>子数组&lt;/strong> 定义为原数组中的一个连续子序列。&lt;/p>
&lt;p>请你返回 &lt;code>arr&lt;/code> 中 &lt;strong>所有奇数长度子数组的和&lt;/strong> 。&lt;/p></description></item><item><title>LeetCode 41. 缺失的第一个正数</title><link>https://tategotoazarasi.github.io/post/first-missing-positive/</link><pubDate>Fri, 23 Sep 2022 12:33:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/first-missing-positive/</guid><description>&lt;p>给你一个未排序的整数数组 &lt;code>nums&lt;/code> ，请你找出其中没有出现的最小的正整数。&lt;/p></description></item><item><title>LeetCode 995. K 连续位的最小翻转次数</title><link>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</link><pubDate>Mon, 19 Sep 2022 18:54:07 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-number-of-k-consecutive-bit-flips/</guid><description>&lt;p>给定一个二进制数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>k 位翻转&lt;/strong> 就是从 &lt;code>nums&lt;/code> 中选择一个长度为 &lt;code>k&lt;/code> 的 &lt;strong>子数组&lt;/strong>，同时把子数组中的每一个 &lt;code>0&lt;/code> 都改成 &lt;code>1&lt;/code> ，把子数组中的每一个 &lt;code>1&lt;/code> 都改成&lt;code>0&lt;/code> 。&lt;/p>
&lt;p>返回数组中不存在 &lt;code>0&lt;/code> 所需的最小 &lt;strong>k 位翻转&lt;/strong>次数。如果不可能，则返回  &lt;code>-1&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 260. 只出现一次的数字 III</title><link>https://tategotoazarasi.github.io/post/single-number-iii/</link><pubDate>Mon, 19 Sep 2022 16:22:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/single-number-iii/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p></description></item><item><title>LeetCode 329. 矩阵中的最长递增路径</title><link>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</link><pubDate>Mon, 19 Sep 2022 13:41:55 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/longest-increasing-path-in-a-matrix/</guid><description>&lt;p>给定一个  &lt;code>m x n&lt;/code> 整数矩阵  &lt;code>matrix&lt;/code> ，找出其中 &lt;strong>最长递增路径&lt;/strong> 的长度。&lt;/p>
&lt;p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 &lt;strong>不能&lt;/strong> 在 &lt;strong>对角线&lt;/strong> 方向上移动或移动到 &lt;strong>边界外&lt;/strong>（即不允许环绕）。&lt;/p></description></item><item><title>LeetCode 174. Dungeon Game</title><link>https://tategotoazarasi.github.io/post/dungeon-game/</link><pubDate>Tue, 13 Sep 2022 17:00:13 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/dungeon-game/</guid><description>&lt;p>The demons had captured the princess and imprisoned her in &lt;strong>the bottom-right corner&lt;/strong> of a &lt;code>dungeon&lt;/code>. The &lt;code>dungeon&lt;/code> consists of &lt;code>m x n&lt;/code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in &lt;strong>the top-left room&lt;/strong> and must fight his way through &lt;code>dungeon&lt;/code> to rescue the princess.&lt;/p>
&lt;p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to &lt;code>0&lt;/code> or below, he dies immediately.&lt;/p>
&lt;p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&amp;rsquo;s health (represented by positive integers).&lt;/p>
&lt;p>To reach the princess as quickly as possible, the knight decides to move only &lt;strong>rightward&lt;/strong> or &lt;strong>downward&lt;/strong> in each step.&lt;/p>
&lt;p>Return &lt;em>the knight&amp;rsquo;s minimum initial health so that he can rescue the princess&lt;/em>.&lt;/p></description></item><item><title>LeetCode 416. 分割等和子集</title><link>https://tategotoazarasi.github.io/post/partition-equal-subset-sum/</link><pubDate>Tue, 13 Sep 2022 15:17:46 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/partition-equal-subset-sum/</guid><description>&lt;p>给你一个 &lt;strong>只包含正整数&lt;/strong> 的 &lt;strong>非空&lt;/strong> 数组  &lt;code>nums&lt;/code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p></description></item><item><title>LeetCode 486. 预测赢家</title><link>https://tategotoazarasi.github.io/post/predict-the-winner/</link><pubDate>Tue, 13 Sep 2022 13:43:09 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/predict-the-winner/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。&lt;/p>
&lt;p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 &lt;code>0&lt;/code>。每一回合，玩家从数组的任意一端取一个数字（即，&lt;code>nums[0]&lt;/code> 或&lt;code>nums[nums.length - 1]&lt;/code>），取到的数字将会从数组中移除（数组长度减 &lt;code>1&lt;/code>）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。&lt;/p>
&lt;p>如果玩家 1 能成为赢家，返回 &lt;code>true&lt;/code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 &lt;code>true&lt;/code>。你可以假设每个玩家的玩法都会使他的分数最大化。&lt;/p></description></item><item><title>LeetCode 85. 最大矩形</title><link>https://tategotoazarasi.github.io/post/maximal-rectangle/</link><pubDate>Tue, 13 Sep 2022 12:53:39 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximal-rectangle/</guid><description>&lt;p>给定一个仅包含  &lt;code>0&lt;/code> 和 &lt;code>1&lt;/code> 、大小为 &lt;code>rows x cols&lt;/code> 的二维二进制矩阵，找出只包含 &lt;code>1&lt;/code> 的最大矩形，并返回其面积。&lt;/p></description></item><item><title>LeetCode 309. 最佳买卖股票时机含冷冻期</title><link>https://tategotoazarasi.github.io/post/best-time-to-buy-and-sell-stock-with-cooldown/</link><pubDate>Thu, 08 Sep 2022 14:15:02 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/best-time-to-buy-and-sell-stock-with-cooldown/</guid><description>&lt;p>给定一个整数数组&lt;code>prices&lt;/code>，其中第  &lt;code>prices[i]&lt;/code>  表示第  &lt;code>i&lt;/code>  天的股票价格。​&lt;/p>
&lt;p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p>
&lt;ul>
&lt;li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 315. 计算右侧小于当前元素的个数</title><link>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</link><pubDate>Wed, 07 Sep 2022 13:47:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/count-of-smaller-numbers-after-self/</guid><description>&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，按要求返回一个新数组  &lt;code>counts&lt;/code> 。数组 &lt;code>counts&lt;/code> 有该性质： &lt;code>counts[i]&lt;/code> 的值是   &lt;code>nums[i]&lt;/code> 右侧小于  &lt;code>nums[i]&lt;/code> 的元素的数量。&lt;/p></description></item><item><title>LeetCode 4. 寻找两个正序数组的中位数</title><link>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</link><pubDate>Wed, 07 Sep 2022 13:12:36 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/median-of-two-sorted-arrays/</guid><description>&lt;p>给定两个大小分别为 &lt;code>m&lt;/code> 和 &lt;code>n&lt;/code> 的正序（从小到大）数组  &lt;code>nums1&lt;/code> 和  &lt;code>nums2&lt;/code>。请你找出并返回这两个正序数组的 &lt;strong>中位数&lt;/strong> 。&lt;/p>
&lt;p>算法的时间复杂度应该为 &lt;code>O(log (m+n))&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 1231. 分享巧克力</title><link>https://tategotoazarasi.github.io/post/divide-chocolate/</link><pubDate>Thu, 25 Aug 2022 16:59:33 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/divide-chocolate/</guid><description>&lt;p>你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组  &lt;code>sweetness&lt;/code>  来表示每一小块的甜度。&lt;/p>
&lt;p>你打算和  &lt;code>K&lt;/code>  名朋友一起分享这块巧克力，所以你需要将切割  &lt;code>K&lt;/code>  次才能得到&lt;code>K+1&lt;/code>  块，每一块都由一些 &lt;strong>连续&lt;/strong>的小块组成。&lt;/p>
&lt;p>为了表现出你的慷慨，你将会吃掉  &lt;strong>总甜度最小&lt;/strong>的一块，并将其余几块分给你的朋友们。&lt;/p>
&lt;p>请找出一个最佳的切割策略，使得你所分得的巧克力  &lt;strong>总甜度最大&lt;/strong>，并返回这个&lt;strong>最大总甜度&lt;/strong>。&lt;/p></description></item><item><title>LeetCode 560. Subarray Sum Equals K</title><link>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</link><pubDate>Mon, 27 Jun 2022 14:37:09 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/subarray-sum-equals-k/</guid><description>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the total number of subarrays whose sum equals to&lt;/em> &lt;code>k&lt;/code>.&lt;/p>
&lt;p>A subarray is a contiguous &lt;strong>non-empty&lt;/strong> sequence of elements within an array.&lt;/p></description></item><item><title>LeetCode 435. Non-overlapping Intervals</title><link>https://tategotoazarasi.github.io/post/non-overlapping-intervals/</link><pubDate>Sun, 26 Jun 2022 13:49:43 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/non-overlapping-intervals/</guid><description>&lt;p>Given an array of intervals &lt;code>intervals&lt;/code> where \(intervals[i] = [start_i, end_i]\), return &lt;em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping&lt;/em>.&lt;/p></description></item><item><title>LeetCode 713. Subarray Product Less Than K</title><link>https://tategotoazarasi.github.io/post/subarray-product-less-than-k/</link><pubDate>Mon, 30 May 2022 13:24:11 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/subarray-product-less-than-k/</guid><description>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than&lt;/em> &lt;code>k&lt;/code>.&lt;/p></description></item><item><title>LeetCode 11. Container With Most Water</title><link>https://tategotoazarasi.github.io/post/container-with-most-water/</link><pubDate>Sun, 29 May 2022 14:00:35 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/container-with-most-water/</guid><description>&lt;p>You are given an integer array &lt;code>height&lt;/code> of length &lt;code>n&lt;/code>. There are &lt;code>n&lt;/code>
vertical lines drawn such that the two endpoints of the &lt;code>ith&lt;/code> line are
&lt;code>(i, 0)&lt;/code> and &lt;code>(i, height[i])&lt;/code>.&lt;/p>
&lt;p>Find two lines that together with the x-axis form a container, such that
the container contains the most water.&lt;/p>
&lt;p>Return &lt;em>the maximum amount of water a container can store&lt;/em>.&lt;/p></description></item><item><title>LeetCode 162. Find Peak Element</title><link>https://tategotoazarasi.github.io/post/find-peak-element/</link><pubDate>Fri, 27 May 2022 12:47:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/find-peak-element/</guid><description>&lt;p>A peak element is an element that is strictly greater than its neighbors.&lt;/p>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to &lt;strong>any of the peaks&lt;/strong>.&lt;/p>
&lt;p>You may imagine that &lt;code>nums[-1] = nums[n] = -∞&lt;/code>.&lt;/p>
&lt;p>You must write an algorithm that runs in &lt;code>O(log n)&lt;/code> time.&lt;/p></description></item><item><title>LeetCode 380. Insert Delete GetRandom O(1)</title><link>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</link><pubDate>Wed, 13 Apr 2022 15:22:28 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/insert-delete-getrandom-o1/</guid><description>&lt;p>实现&lt;code>RandomizedSet&lt;/code> 类：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RandomizedSet()&lt;/code> 初始化 &lt;code>RandomizedSet&lt;/code> 对象&lt;/li>
&lt;li>&lt;code>bool insert(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 不存在时，向集合中插入该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>bool remove(int val)&lt;/code> 当元素 &lt;code>val&lt;/code> 存在时，从集合中移除该项，并返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/li>
&lt;li>&lt;code>int getRandom()&lt;/code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 &lt;strong>相同的概率&lt;/strong> 被返回。&lt;/li>
&lt;/ul>
&lt;p>你必须实现类的所有函数，并满足每个函数的 &lt;strong>平均&lt;/strong> 时间复杂度为 &lt;code>O(1)&lt;/code> 。&lt;/p></description></item><item><title>LeetCode 307. Range Sum Query - Mutable</title><link>https://tategotoazarasi.github.io/post/range-sum-query-mutable/</link><pubDate>Mon, 04 Apr 2022 12:46:58 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/range-sum-query-mutable/</guid><description>&lt;p>Given an integer array &lt;code>nums&lt;/code>, handle multiple queries of the following types:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Update&lt;/strong> the value of an element in &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>Calculate the &lt;strong>sum&lt;/strong> of the elements of &lt;code>nums&lt;/code> between indices &lt;code>left&lt;/code> and &lt;code>right&lt;/code> &lt;strong>inclusive&lt;/strong> where &lt;code>left &amp;lt;= right&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Implement the &lt;code>NumArray&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>&lt;code>NumArray(int[] nums)&lt;/code> Initializes the object with the integer array &lt;code>nums&lt;/code>.&lt;/li>
&lt;li>&lt;code>void update(int index, int val)&lt;/code> &lt;strong>Updates&lt;/strong> the value of &lt;code>nums[index]&lt;/code> to be &lt;code>val&lt;/code>.&lt;/li>
&lt;li>&lt;code>int sumRange(int left, int right)&lt;/code> Returns the &lt;strong>sum&lt;/strong> of the elements of &lt;code>nums&lt;/code> between indices &lt;code>left&lt;/code> and &lt;code>right&lt;/code> &lt;strong>inclusive&lt;/strong> (i.e. &lt;code>nums[left] + nums[left + 1] + ... + nums[right]&lt;/code>).&lt;/li>
&lt;/ul></description></item><item><title>LeetCode 798. Smallest Rotation with Highest Score</title><link>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</link><pubDate>Wed, 09 Mar 2022 14:47:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/smallest-rotation-with-highest-score/</guid><description>&lt;p>You are given an array &lt;code>nums&lt;/code>. You can rotate it by a non-negative integer &lt;code>k&lt;/code> so that the array becomes &lt;code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]&lt;/code>. Afterward, any entries that are less than or equal to their index are worth one point.&lt;/p>
&lt;ul>
&lt;li>For example, if we have &lt;code>nums = [2,4,1,3,0]&lt;/code>, and we rotate by &lt;code>k = 2&lt;/code>, it becomes &lt;code>[1,3,0,2,4]&lt;/code>. This is worth &lt;code>3&lt;/code> points because &lt;code>1 &amp;gt; 0&lt;/code> [no points], &lt;code>3 &amp;gt; 1&lt;/code> [no points], &lt;code>0 &amp;lt;= 2&lt;/code> [one point], &lt;code>2 &amp;lt;= 3&lt;/code> [one point], &lt;code>4 &amp;lt;= 4&lt;/code> [one point].&lt;/li>
&lt;/ul>
&lt;p>Return &lt;em>the rotation index&lt;/em> &lt;code>k&lt;/code> &lt;em>that corresponds to the highest score we can achieve if we rotated&lt;/em> &lt;code>nums&lt;/code> &lt;em>by it&lt;/em>. If there are multiple answers, return the smallest such index &lt;code>k&lt;/code>.&lt;/p></description></item><item><title>LeetCode 2104. Sum of Subarray Ranges</title><link>https://tategotoazarasi.github.io/post/sum-of-subarray-ranges/</link><pubDate>Fri, 04 Mar 2022 13:09:50 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/sum-of-subarray-ranges/</guid><description>&lt;p>You are given an integer array &lt;code>nums&lt;/code>. The &lt;strong>range&lt;/strong> of a subarray of &lt;code>nums&lt;/code> is the difference between the largest and smallest element in the subarray.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>sum of all&lt;/strong> subarray ranges of&lt;/em> &lt;code>nums&lt;/code>&lt;em>.&lt;/em>&lt;/p>
&lt;p>A subarray is a contiguous &lt;strong>non-empty&lt;/strong> sequence of elements within an array.&lt;/p></description></item><item><title>LeetCode 1994. 好子集的数目</title><link>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</link><pubDate>Tue, 22 Feb 2022 09:23:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-good-subsets/</guid><description>&lt;p>给你一个整数数组  &lt;code>nums&lt;/code> 。如果  &lt;code>nums&lt;/code>  的一个子集中，所有元素的乘积可以表示为一个或多个 &lt;strong>互不相同的质数&lt;/strong> 的乘积，那么我们称它为  &lt;strong>好子集&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>比方说，如果  &lt;code>nums = [1, 2, 3, 4]&lt;/code> ：
&lt;ul>
&lt;li>&lt;code>[2, 3]&lt;/code> ，&lt;code>[1, 2, 3]&lt;/code>  和  &lt;code>[1, 3]&lt;/code>  是 &lt;strong>好&lt;/strong>  子集，乘积分别为  &lt;code>6 = 2*3&lt;/code> ，&lt;code>6 = 2*3&lt;/code>  和  &lt;code>3 = 3&lt;/code> 。&lt;/li>
&lt;li>&lt;code>[1, 4]&lt;/code> 和  &lt;code>[4]&lt;/code>  不是 &lt;strong>好&lt;/strong>  子集，因为乘积分别为  &lt;code>4 = 2*2&lt;/code> 和  &lt;code>4 = 2*2&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>请你返回 &lt;code>nums&lt;/code>  中不同的  &lt;strong>好&lt;/strong>  子集的数目对 &lt;code>109 + 7&lt;/code> &lt;strong>取余&lt;/strong>  的结果。&lt;/p>
&lt;p>&lt;code>nums&lt;/code>  中的 &lt;strong>子集&lt;/strong>  是通过删除 &lt;code>nums&lt;/code>  中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。&lt;/p></description></item><item><title>LeetCode 1996. 游戏中弱角色的数量</title><link>https://tategotoazarasi.github.io/post/the-number-of-weak-characters-in-the-game/</link><pubDate>Fri, 28 Jan 2022 10:27:51 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/the-number-of-weak-characters-in-the-game/</guid><description>&lt;p>你正在参加一个多角色游戏，每个角色都有两个主要属性：&lt;strong>攻击&lt;/strong> 和 &lt;strong>防御&lt;/strong> 。给你一个二维整数数组 &lt;code>properties&lt;/code> ，其中 \(properties[i] = [attack_i, defense_i]\) 表示游戏中第 &lt;code>i&lt;/code> 个角色的属性。&lt;/p>
&lt;p>如果存在一个其他角色的攻击和防御等级 &lt;strong>都严格高于&lt;/strong> 该角色的攻击和防御等级，则认为该角色为 &lt;strong>弱角色&lt;/strong> 。更正式地，如果认为角色 &lt;code>i&lt;/code> &lt;strong>弱于&lt;/strong> 存在的另一个角色 &lt;code>j&lt;/code> ，那么 \(attack_j &amp;gt; attack_i\) 且 \(defense_j &amp;gt; defense_i\) 。&lt;/p>
&lt;p>返回 &lt;strong>弱角色&lt;/strong> 的数量。&lt;/p></description></item><item><title>LeetCode 1036. 逃离大迷宫</title><link>https://tategotoazarasi.github.io/post/escape-a-large-maze/</link><pubDate>Tue, 11 Jan 2022 16:08:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/escape-a-large-maze/</guid><description>&lt;p>在一个 \(10^6 \times 10^6\) 的网格中，每个网格上方格的坐标为 &lt;code>(x, y)&lt;/code> 。&lt;/p>
&lt;p>现在从源方格 \(source = [s_x, s_y]\) 开始出发，意图赶往目标方格 \(target = [t_x, t_y]\) 。数组 &lt;code>blocked&lt;/code> 是封锁的方格列表，其中每个 \(blocked[i] = [x_i, y_i]\) 表示坐标为 \((x_i, y_i)\) 的方格是禁止通行的。&lt;/p>
&lt;p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 &lt;strong>不&lt;/strong> 在给出的封锁列表 &lt;code>blocked&lt;/code> 上。同时，不允许走出网格。&lt;/p>
&lt;p>只有在可以通过一系列的移动从源方格 &lt;code>source&lt;/code> 到达目标方格 &lt;code>target&lt;/code> 时才返回 &lt;code>true&lt;/code>。否则，返回 &lt;code>false&lt;/code>。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item><item><title>LeetCode 5965. 相同元素的间隔之和</title><link>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</link><pubDate>Sun, 26 Dec 2021 15:11:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/intervals-between-identical-elements/</guid><description>&lt;p>给你一个下标从 &lt;strong>0&lt;/strong> 开始、由 &lt;code>n&lt;/code> 个整数组成的数组 &lt;code>arr&lt;/code> 。&lt;/p>
&lt;p>&lt;code>arr&lt;/code> 中两个元素的 &lt;strong>间隔&lt;/strong> 定义为它们下标之间的 &lt;strong>绝对差&lt;/strong> 。更正式地，&lt;code>arr[i]&lt;/code> 和 &lt;code>arr[j]&lt;/code> 之间的间隔是 &lt;code>|i - j|&lt;/code> 。&lt;/p>
&lt;p>返回一个长度为 &lt;code>n&lt;/code> 的数组  &lt;code>intervals&lt;/code> ，其中 &lt;code>intervals[i]&lt;/code> 是 &lt;code>arr[i]&lt;/code> 和 &lt;code>arr&lt;/code> 中每个相同元素（与 &lt;code>arr[i]&lt;/code> 的值相同）的 &lt;strong>间隔之和&lt;/strong> &lt;em>。&lt;/em>&lt;/p></description></item><item><title>LeetCode 119. 杨辉三角 II</title><link>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</link><pubDate>Mon, 20 Dec 2021 11:13:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/pascals-triangle-ii/</guid><description>&lt;p>给定一个非负索引 &lt;code>rowIndex&lt;/code>，返回「杨辉三角」的第 &lt;code>rowIndex&lt;/code> 行。&lt;/p>
&lt;p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。&lt;/p></description></item></channel></rss>