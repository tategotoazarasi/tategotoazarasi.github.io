<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>深度优先搜索 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link><description>Recent content in 深度优先搜索 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 31 Dec 2021 11:55:26 +0800</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode 538. 把二叉搜索树转换为累加树</title><link>https://tategotoazarasi.github.io/post/convert-bst-to-greater-tree/</link><pubDate>Fri, 31 Dec 2021 11:55:26 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/convert-bst-to-greater-tree/</guid><description>&lt;p>给出二叉 &lt;strong>搜索&lt;/strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 &lt;code>node&lt;/code>  的新值等于原树中大于或等于  &lt;code>node.val&lt;/code>  的值之和。&lt;/p></description></item><item><title>LeetCode 472. 连接词</title><link>https://tategotoazarasi.github.io/post/concatenated-words/</link><pubDate>Tue, 28 Dec 2021 15:56:48 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/concatenated-words/</guid><description>&lt;p>给你一个 &lt;strong>不含重复&lt;/strong> 单词的字符串数组 &lt;code>words&lt;/code> ，请你找出并返回 &lt;code>words&lt;/code> 中的所有 &lt;strong>连接词&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>连接词&lt;/strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。&lt;/p></description></item><item><title>LeetCode 145. 二叉树的后序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-postorder-traversal/</link><pubDate>Thu, 23 Dec 2021 14:40:42 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-postorder-traversal/</guid><description>&lt;p>给定一个二叉树，返回它的 &lt;em>后序&lt;/em> 遍历。&lt;/p></description></item><item><title>LeetCode 144. 二叉树的前序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-preorder-traversal/</link><pubDate>Wed, 22 Dec 2021 10:33:10 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-preorder-traversal/</guid><description>&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回它节点值的  &lt;strong>前序&lt;/strong> 遍历。&lt;/p></description></item><item><title>LeetCode 112. 路径总和</title><link>https://tategotoazarasi.github.io/post/path-sum/</link><pubDate>Sun, 19 Dec 2021 12:33:22 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/path-sum/</guid><description>&lt;p>给你二叉树的根节点  &lt;code>root&lt;/code> 和一个表示目标和的整数  &lt;code>targetSum&lt;/code> 。判断该树中是否存在 &lt;strong>根节点到叶子节点&lt;/strong> 的路径，这条路径上所有节点值相加等于目标和  &lt;code>targetSum&lt;/code> 。如果存在，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;p>&lt;strong>叶子节点&lt;/strong> 是指没有子节点的节点。&lt;/p></description></item><item><title>LeetCode 111. 二叉树的最小深度</title><link>https://tategotoazarasi.github.io/post/minimum-depth-of-binary-tree/</link><pubDate>Thu, 16 Dec 2021 10:23:00 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/minimum-depth-of-binary-tree/</guid><description>&lt;p>给定一个二叉树，找出其最小深度。&lt;/p>
&lt;p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p></description></item><item><title>LeetCode 110. 平衡二叉树</title><link>https://tategotoazarasi.github.io/post/balanced-binary-tree/</link><pubDate>Thu, 16 Dec 2021 10:02:54 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/balanced-binary-tree/</guid><description>&lt;p>给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p>
&lt;p>本题中，一棵高度平衡二叉树定义为：&lt;/p>
&lt;blockquote>
&lt;p>一个二叉树&lt;em>每个节点&lt;/em> 的左右两个子树的高度差的绝对值不超过 1 。&lt;/p>
&lt;/blockquote></description></item><item><title>LeetCode 104. 二叉树的最大深度</title><link>https://tategotoazarasi.github.io/post/maximum-depth-of-binary-tree/</link><pubDate>Wed, 15 Dec 2021 09:52:08 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/maximum-depth-of-binary-tree/</guid><description>&lt;p>给定一个二叉树，找出其最大深度。&lt;/p>
&lt;p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p></description></item><item><title>LeetCode 101. 对称二叉树</title><link>https://tategotoazarasi.github.io/post/symmetric-tree/</link><pubDate>Tue, 14 Dec 2021 10:23:43 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/symmetric-tree/</guid><description>&lt;p>给定一个二叉树，检查它是否是镜像对称的。&lt;/p></description></item><item><title>LeetCode 100. 相同的树</title><link>https://tategotoazarasi.github.io/post/same-tree/</link><pubDate>Tue, 14 Dec 2021 10:03:50 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/same-tree/</guid><description>&lt;p>给你两棵二叉树的根节点 &lt;code>p&lt;/code> 和 &lt;code>q&lt;/code> ，编写一个函数来检验这两棵树是否相同。&lt;/p>
&lt;p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p></description></item><item><title>LeetCode 94. 二叉树的中序遍历</title><link>https://tategotoazarasi.github.io/post/binary-tree-inorder-traversal/</link><pubDate>Mon, 13 Dec 2021 10:43:57 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/binary-tree-inorder-traversal/</guid><description>&lt;p>给定一个二叉树的根节点 &lt;code>root&lt;/code> ，返回它的 &lt;strong>中序&lt;/strong>  遍历。&lt;/p></description></item></channel></rss>