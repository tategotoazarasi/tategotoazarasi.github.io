<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>虚拟内存 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link><description>Recent content in 虚拟内存 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 17 Nov 2024 12:29:51 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.xml" rel="self" type="application/rss+xml"/><item><title>用户程序的虚拟内存原语</title><link>https://tategotoazarasi.github.io/post/appel-li/</link><pubDate>Sun, 29 May 2022 19:04:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/appel-li/</guid><description>&lt;p>传统上，操作系统使用内存管理单元(MMU)来实现磁盘分页虚拟内存。一些操作系统允许用户指定页的保护等级（不可访问、只读、可读写），并且允许用户程序来处理非法操作，但是这些机制并不总是健壮、有效或符合应用程序需求的。&lt;/p>
&lt;p>我们调查了几种页保护技术的用户态算法，并且分析了它们的共同点，以回答这样一个问题：“操作系统应该为用户提供什么样的虚拟内存原语，现今的操作系统又在何种程度上提供了？”&lt;/p>
&lt;p>虚拟内存的“传统”目的是通过只允许将经常访问的内存保存在物理内存上来拓展程序员可见的地址空间。但是虚拟内存也被用于很多其他目的。操作系统可以用虚拟内存来在不同的进程之间共享页，可以让指令空间只读（从而保证可以重复执行），让部分内存实现按需归零或写时复制，等等。事实上，操作系统可以把页保护硬件玩出很多花样。&lt;/p>
&lt;p>同样，现代操作系统也通过让用户进程为非法操作提供“处理程序”来让用户也能使用此类技巧。以Unix为例，当出现段错误信号时，用户可以指定一个子例程来处理。当一个程序访问内存越界时，用户提供的信号处理程序可以给出一条用户友好的错误信息，而不是不详的 &amp;ldquo;segmentation fault: core dumped.&amp;rdquo;&lt;/p>
&lt;p>这个简单的用户态错误处理程序是“危险的”，因为它可能导致操作系统和硬件设计者认为不需要高效地使用用户态处理程序（在“优雅地关闭错误”这一示例中肯定是这样的）。但是，用户态错误处理程序还有很多有趣的应用。这些应用程序非常严格地执行页保护和错误处理机制，操作系统的实现者应该理解这些机制。&lt;/p>
&lt;p>本文介绍了几种页保护技术的算法。在许多情况下，这些算法能够用“传统”的页硬件来代替“特殊”的微指令。在共享内存的多核处理器上，这些算法利用页保护硬件来实现低开销中等粒度的同步，以避免开销较大的同步序列化指令。&lt;/p></description></item></channel></rss>