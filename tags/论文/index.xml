<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>论文 on Harp Seal Pup Nursery and Caring Center</title><link>https://tategotoazarasi.github.io/tags/%E8%AE%BA%E6%96%87/</link><description>Recent content in 论文 on Harp Seal Pup Nursery and Caring Center</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 02 Sep 2024 07:05:00 +0000</lastBuildDate><atom:link href="https://tategotoazarasi.github.io/tags/%E8%AE%BA%E6%96%87/index.xml" rel="self" type="application/rss+xml"/><item><title>Dune：对特权 CPU 功能的安全用户级访问</title><link>https://tategotoazarasi.github.io/post/belay-dune/</link><pubDate>Sat, 04 Jun 2022 18:14:18 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/belay-dune/</guid><description>Dune 是一个系统，它为应用程序提供对硬件功能(如环保护、页表和标记 TLB)的直接但安全的访问，同时保留了现有的操作系统的进程接口。Dune 使用现代处理器中的虚拟化硬件来管理一个进程，而不是虚拟机。它由一个小型内核模块和一个用户级库组成，前者用于初始化虚拟化硬件并协调与内核的交互，后者用于帮助应用程序管理特权硬件功能。我们介绍了 64 位 x86 Linux 的 Dune 的实现。我们用 Dune 实现了三个用户级应用，它们可以从访问特权硬件中受益：一个用于不受信任的代码的沙盒、一个特权分离工具和垃圾收集器。Dune 的使用极大地简化了这些应用程序的实现，并提供了显著的性能优势。</description></item><item><title>基于微内核的系统的性能</title><link>https://tategotoazarasi.github.io/post/microkernel/</link><pubDate>Tue, 31 May 2022 20:09:56 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/microkernel/</guid><description>&lt;p>第一代微内核以速度太慢和缺乏足够的灵活性而闻名。为了确定第二代微内核 L4 是否克服了这些限制，我们重复了几个早期的实验，并进行了一些新的实验。此外，我们将 Linux 操作系统移植到 L4 微内核之上运行，并将生成的系统与原生的 Linux 和 MkLinux(在第一代 Mach 衍生的 μ 内核之上执行的 Linux 版本)进行比较。&lt;/p>
&lt;p>对于 L4Linux，AIM 基准测试报告的最大吞吐量仅比原生 Linux 低 5%。对于位于同一位置的内核版本的 MkLinux，相应的惩罚要高出 5 倍，而对于 MkLinux 的用户级版本，则是 7 倍。这些数字表明，在微内核之上实现高性能的传统操作系统是可能的，并且微内核的性能对于实现这一点至关重要。&lt;/p>
&lt;p>进一步的实验表明，所得到的系统是高度可扩展的，并且扩展后的系统表现良好。甚至包括二级缓存分配在内的实时内存管理也可以在用户级实现，与 L4Linux 共存。&lt;/p></description></item><item><title>用户程序的虚拟内存原语</title><link>https://tategotoazarasi.github.io/post/appel-li/</link><pubDate>Sun, 29 May 2022 19:04:32 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/appel-li/</guid><description>&lt;p>传统上，操作系统使用内存管理单元(MMU)来实现磁盘分页虚拟内存。一些操作系统允许用户指定页的保护等级（不可访问、只读、可读写），并且允许用户程序来处理非法操作，但是这些机制并不总是健壮、有效或符合应用程序需求的。&lt;/p>
&lt;p>我们调查了几种页保护技术的用户态算法，并且分析了它们的共同点，以回答这样一个问题：“操作系统应该为用户提供什么样的虚拟内存原语，现今的操作系统又在何种程度上提供了？”&lt;/p>
&lt;p>虚拟内存的“传统”目的是通过只允许将经常访问的内存保存在物理内存上来拓展程序员可见的地址空间。但是虚拟内存也被用于很多其他目的。操作系统可以用虚拟内存来在不同的进程之间共享页，可以让指令空间只读（从而保证可以重复执行），让部分内存实现按需归零或写时复制，等等。事实上，操作系统可以把页保护硬件玩出很多花样。&lt;/p>
&lt;p>同样，现代操作系统也通过让用户进程为非法操作提供“处理程序”来让用户也能使用此类技巧。以Unix为例，当出现段错误信号时，用户可以指定一个子例程来处理。当一个程序访问内存越界时，用户提供的信号处理程序可以给出一条用户友好的错误信息，而不是不详的 &amp;ldquo;segmentation fault: core dumped.&amp;rdquo;&lt;/p>
&lt;p>这个简单的用户态错误处理程序是“危险的”，因为它可能导致操作系统和硬件设计者认为不需要高效地使用用户态处理程序（在“优雅地关闭错误”这一示例中肯定是这样的）。但是，用户态错误处理程序还有很多有趣的应用。这些应用程序非常严格地执行页保护和错误处理机制，操作系统的实现者应该理解这些机制。&lt;/p>
&lt;p>本文介绍了几种页保护技术的算法。在许多情况下，这些算法能够用“传统”的页硬件来代替“特殊”的微指令。在共享内存的多核处理器上，这些算法利用页保护硬件来实现低开销中等粒度的同步，以避免开销较大的同步序列化指令。&lt;/p></description></item><item><title>为 Linux ext2fs 文件系统记录日志</title><link>https://tategotoazarasi.github.io/post/journal-design/</link><pubDate>Mon, 23 May 2022 20:25:45 +0800</pubDate><guid>https://tategotoazarasi.github.io/post/journal-design/</guid><description>&lt;p>本文描述了为 Linux ext2fs 文件系统设计和实现事务性元数据日志的工作进展。我们回顾了崩溃后恢复文件系统的问题，并描述了一种设计，旨在通过在文件系统中添加事务日志来提高 ext2fs 的崩溃恢复速度和可靠性。&lt;/p>
&lt;p>文件系统是任何现代操作系统的核心部分，人们期望它既快速又极其可靠。然而，由于硬件、软件或电源故障，问题仍然存在，机器可能会意外停机。&lt;/p>
&lt;p>在一次意外重启之后，系统可能需要一些时间才能将其文件系统恢复到一致的状态。随着磁盘容量的增加，这个时间可能会成为一个严重的问题，系统会花费超过一个小时来扫描、检查和修复磁盘，在此期间你只能等待。尽管磁盘驱动器的速度每年都在提高，但与它们在容量上的巨大增长相比，这种速度的增长并不明显。不幸的是，在使用传统的文件系统检查技术时，磁盘容量每增加一倍，恢复时间就会增加一倍。&lt;/p>
&lt;p>在对系统可用性要求很高的情况下，可能并不允许跳过检查以节省时间，因此需要一种机制，以避免每次机器重启要经历长时间的恢复阶段。&lt;/p></description></item></channel></rss>