<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标 | Tategoto Azarasi</title>
<meta name=keywords content="python,geopandas,folium,data-visualization,gis,urban-planning,spatial-analysis,smart-city,data-science,hackathon"><meta name=description content="本文复盘了如何利用 Python、Geopandas 和 Folium 将住房规划、治安数据与社会经济指标融合，构建支持动态权重的城市决策可视化系统。"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tategotoazarasi.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tategotoazarasi.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tategotoazarasi.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tategotoazarasi.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.tategotoazarasi.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/><link rel=alternate hreflang=zh href=https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标"><meta property="og:description" content="本文复盘了如何利用 Python、Geopandas 和 Folium 将住房规划、治安数据与社会经济指标融合，构建支持动态权重的城市决策可视化系统。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-03T20:32:25+00:00"><meta property="article:modified_time" content="2025-12-03T20:32:25+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Geopandas"><meta property="article:tag" content="Folium"><meta property="article:tag" content="Data-Visualization"><meta property="article:tag" content="Gis"><meta property="article:tag" content="Urban-Planning"><meta name=twitter:card content="summary"><meta name=twitter:title content="打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标"><meta name=twitter:description content="本文复盘了如何利用 Python、Geopandas 和 Folium 将住房规划、治安数据与社会经济指标融合，构建支持动态权重的城市决策可视化系统。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tategotoazarasi.me/zh/posts/"},{"@type":"ListItem","position":2,"name":"打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标","item":"https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标","name":"打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标","description":"本文复盘了如何利用 Python、Geopandas 和 Folium 将住房规划、治安数据与社会经济指标融合，构建支持动态权重的城市决策可视化系统。","keywords":["python","geopandas","folium","data-visualization","gis","urban-planning","spatial-analysis","smart-city","data-science","hackathon"],"articleBody":"最近，我有幸参加了由利物浦城市地区联合管理局（LCR CA）与 Homes England 联合举办的一场黑客松。这次活动的背景非常宏大且务实：政府目前掌握着一份包含约 350 个地块、总计超过 57,000 套新房的住房开发清单（Housing Pipeline）。然而，这些数据静静地躺在 Excel 表格里，仅仅是冰冷的数字。\n我们的任务是：如何让这些数据“活”过来？\n作为开发者，我们深知仅仅在地图上标出“这里要建房”是远远不够的。城市规划是一个复杂的系统工程。我们在哪里建房？那个地方安全吗？那里的能源贫困率如何？是否存在社会剥夺现象？我们是否应当优先开发废弃的褐地（Brownfield）？\n为了回答这些问题，我带领团队构建了一个基于 Python 的地理空间分析与可视化系统。我们没有止步于简单的数据展示，而是将治安数据、社会剥夺指数、褐地数据与住房规划进行了深度融合，并通过自定义 JavaScript 实现了一个动态权重的“脆弱性热力图”。\n这篇文章将复盘整个技术实现过程，希望能给对 GIS（地理信息系统）和数据可视化感兴趣的朋友提供一些思路。\n数据的孤岛与桥梁 在开始写代码之前，我们面临的最大挑战是数据源的异构性。我们手头有五种完全不同格式的数据：\n住房规划数据（Housing Pipeline）：这是核心数据，Excel 格式，包含项目名称、开发商、邮编、规划单元数等。 行政边界数据（Boundaries）：GeoJSON 格式，定义了利物浦城市地区的地理边界。 LSOA 统计分区数据：LSOA（Lower Layer Super Output Areas）是英国统计局定义的小地理单元，是我们进行空间分析的基准。 多重剥夺指数（IMD）与燃料贫困数据：Excel 格式，提供了每个 LSOA 的社会经济指标。 警方治安数据：这是最棘手的部分。它是按月分文件夹存储的数百个 CSV 文件，包含具体的经纬度坐标。 褐地（Brownfield）数据：GeoJSON 格式，包含废弃土地的位置和面积。 我们的目标是将这些散落在不同维度的“孤岛”数据，全部统一映射到 LSOA 这个地理单元上。\n数据清洗与地理编码 住房规划数据中只有邮编（Postcode），没有经纬度。这是地理分析中常见的问题。我们使用了 pgeocode 库来解决这个问题，它基于 GeoNames 数据库，查询速度极快，不需要调用昂贵的 Google Maps API。\nimport pgeocode import pandas as pd # 初始化英国的邮编查询对象 nomi = pgeocode.Nominatim(\"GB\") def batch_geocode(df, postcode_col): # 清洗邮编格式 clean_postcodes = df[postcode_col].astype(str).str.strip() unique_pcs = clean_postcodes.unique() # 批量查询，提高效率 geo_results = nomi.query_postal_code(unique_pcs) # 建立映射字典 pc_to_lat = dict(zip(unique_pcs, geo_results.latitude)) pc_to_lon = dict(zip(unique_pcs, geo_results.longitude)) df[\"lat\"] = clean_postcodes.map(pc_to_lat) df[\"lon\"] = clean_postcodes.map(pc_to_lon) return df.dropna(subset=[\"lat\", \"lon\"]) 这一步至关重要，它将业务数据（Excel）转化为了空间数据（Points）。\n处理海量治安数据 警方提供的数据非常详尽，涵盖了过去三年的每个月的犯罪记录，甚至包括“拦截搜查”（Stop \u0026 Search）的具体坐标。文件数量多达几百个。\n如果我们直接读取所有 CSV 并试图在地图上画点，浏览器会瞬间崩溃。因此，空间聚合（Spatial Aggregation） 是唯一的出路。我们需要计算出每个 LSOA 区域内发生了多少起犯罪。\n这里我们使用了 pathlib 进行递归文件查找，并结合 Pandas 进行数据清洗：\nfrom pathlib import Path # 递归查找所有 CSV 文件 all_csvs = list(Path(\"police_data\").rglob(\"*.csv\")) stop_search_points = [] for csv_file in all_csvs: try: # 只读取必要的经纬度列，节省内存 df = pd.read_csv(csv_file, usecols=[\"Latitude\", \"Longitude\"]) df = df.dropna() # 粗略过滤掉不在利物浦范围内的点，加速后续处理 mask = (df['Latitude'].between(53.0, 54.0)) \u0026 \\ (df['Longitude'].between(-3.5, -2.0)) stop_search_points.append(df[mask]) except: continue # 合并所有数据帧 all_stops = pd.concat(stop_search_points, ignore_index=True) 空间连接 现在我们有了一堆犯罪地点的“点”，和一堆代表社区的“面”（LSOA Polygons）。我们要回答的问题是：这个点属于哪个面？\n在 geopandas 中，sjoin（Spatial Join）函数是处理这类问题的神器。它是基于几何关系的数据库连接操作。\nimport geopandas as gpd # 将警方数据转换为 GeoDataFrame gdf_stops = gpd.GeoDataFrame( all_stops, geometry=gpd.points_from_xy(all_stops.Longitude, all_stops.Latitude), crs=\"EPSG:4326\" ) # 核心操作：判断点在哪个多边形内 (predicate='within') # lsoa_lcr 是我们的行政区划多边形数据 stops_with_lsoa = gpd.sjoin(gdf_stops, lsoa_lcr[['LSOA21CD', 'geometry']], predicate='within') # 聚合统计：计算每个 LSOA 的犯罪数量 stop_counts = stops_with_lsoa['LSOA21CD'].value_counts().reset_index() stop_counts.columns = ['LSOA21CD', 'StopSearch_Count'] 通过这一步，我们将数以万计的离散坐标点，转化为了每个社区的单一统计指标。这是数据降维的关键。\n同理，我们将燃料贫困数据（Fuel Poverty）和多重剥夺指数（IMD）通过 LSOA21CD 代码 merge 到我们的主 GeoDataFrame 中。\n构建“脆弱性评分”与动态归一化 有了原始数据后，我们面临一个新问题：不同指标的量纲完全不同。犯罪数量可能是 0 到 500，而贫困率是 0% 到 100%，IMD 是 1 到 10 的等级。为了在一个地图上综合展示这些信息，我们需要进行归一化（Normalization）。\n我们采用了 Min-Max 归一化，将所有指标映射到 0 到 1 之间。值得注意的是，对于 IMD（1 代表最贫困），我们需要反转它，使得 1 代表“高风险/高脆弱性”。\n# 归一化燃料贫困率 f_min, f_max = master_gdf[\"Fuel_Poverty_Rate\"].min(), master_gdf[\"Fuel_Poverty_Rate\"].max() master_gdf[\"norm_fuel\"] = (master_gdf[\"Fuel_Poverty_Rate\"] - f_min) / (f_max - f_min) # 归一化 IMD (反转，10为最不贫困，1为最贫困 -\u003e 映射后 1.0 为高风险) master_gdf[\"norm_imd\"] = (11 - master_gdf[\"IMD_Decile\"]) / 10.0 # 归一化犯罪数据 (使用 95 分位值作为最大值，防止极端异常值拉低整体区分度) c_max = master_gdf[\"Crime_Count\"].quantile(0.95) master_gdf[\"norm_crime\"] = (master_gdf[\"Crime_Count\"] / c_max).clip(upper=1.0) 为什么使用 95 分位数？ 在实际的城市数据中，市中心（City Centre）的犯罪率往往是郊区的几十倍。如果直接使用最大值进行归一化，市中心会是深红色，而其他所有区域都会变成近乎白色的浅色，导致郊区之间的差异无法体现。截断极端值可以保留大部分区域的对比度。\n可视化 如果只是用 matplotlib 画一张静态图，那对于决策者来说意义有限。我们需要的是交互性。我们选择了 Folium（基于 Leaflet.js），但原生的 Folium 功能有限，无法实现“拖动滑块实时改变权重”的功能。\n为了解决这个问题，我采用了注入自定义 JavaScript 的方案。\n图层分级策略 在地图上叠加多个图层时，遮挡是最大的敌人。我们通过自定义 Pane 并设置 z-index 来严格控制图层层级：\nLSOA 基础着色层 (z=400)：最底层，显示脆弱性热力图。 住房项目层 (z=620)：中间层，显示规划中的新房（气泡图）。 褐地数据层 (z=650)：最顶层，显示可用的废弃土地点位。 import folium m = folium.Map(location=[centre_lat, centre_lon], zoom_start=11, tiles=\"CartoDB positron\") # 创建自定义图层面板 folium.map.CustomPane(\"poly_pane\", z_index=400).add_to(m) folium.map.CustomPane(\"housing_pane\", z_index=620).add_to(m) folium.map.CustomPane(\"brownfield_pane\", z_index=650).add_to(m) 注入 JavaScript 实现动态权重计算 这是本项目最核心的创新点。我们不希望仅仅展示一张死板的地图，而是希望让用户（比如警察局长、城市规划师或社会工作者）根据他们的关注点调整权重。\n我们将处理好的 GeoJSON 数据和前端逻辑直接写入 HTML 中。\nfrom branca.element import Element # 将 Python 处理好的数据转为 JSON 字符串注入前端 geojson_str = master_gdf.to_json() custom_ui = f\"\"\" Layer Weights (LSOA Scoring) Fuel Poverty Crime Density \"\"\" m.get_root().html.add_child(Element(custom_ui)) 这段代码实现了一个完全前端的交互逻辑：数据在 Python 后端处理完毕后，前端浏览器负责实时的渲染和数学计算。这保证了地图的流畅性，用户在拖动滑块时，地图颜色会平滑过渡，直观地展示出不同侧重下的高风险区域。\n住房规划与褐地的可视化细节 对于住房项目，我们使用 CircleMarker。\n大小：代表规划的房屋数量（使用了平方根缩放，避免气泡过大）。 填充颜色：代表开发阶段（短期、中期、长期）。 边框颜色：代表地块面积大小。 对于褐地（Brownfield），我们将其作为最顶层的黑色小点显示，点击后会弹出详细的规划许可状态和此前用途。这样的设计让规划者可以一目了然地看到：在这个高风险（红色）区域，是否有可利用的褐地（黑点）来建设新房，从而起到旧城改造的作用？\n","wordCount":"451","inLanguage":"zh","datePublished":"2025-12-03T20:32:25Z","dateModified":"2025-12-03T20:32:25Z","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://blog.tategotoazarasi.me/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tategotoazarasi.me/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.tategotoazarasi.me/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.tategotoazarasi.me/zh/ title=首页><span>首页</span></a></li><li><a href=https://blog.tategotoazarasi.me/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tategotoazarasi.me/zh/>主页</a>&nbsp;»&nbsp;<a href=https://blog.tategotoazarasi.me/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标</h1><div class=post-meta><span title='2025-12-03 20:32:25 +0000 UTC'>十二月 3, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;451 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://blog.tategotoazarasi.me/en/posts/building-a-data-driven-city-python-gis-visualization/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#数据的孤岛与桥梁>数据的孤岛与桥梁</a><ol><li><a href=#数据清洗与地理编码>数据清洗与地理编码</a></li><li><a href=#处理海量治安数据>处理海量治安数据</a></li></ol></li><li><a href=#空间连接>空间连接</a></li><li><a href=#构建脆弱性评分与动态归一化>构建“脆弱性评分”与动态归一化</a></li><li><a href=#可视化>可视化</a><ol><li><a href=#图层分级策略>图层分级策略</a></li><li><a href=#注入-javascript-实现动态权重计算>注入 JavaScript 实现动态权重计算</a></li><li><a href=#住房规划与褐地的可视化细节>住房规划与褐地的可视化细节</a></li></ol></li></ol></nav></div></details></div><div class=post-content><p>最近，我有幸参加了由利物浦城市地区联合管理局（LCR CA）与 Homes England 联合举办的一场黑客松。这次活动的背景非常宏大且务实：政府目前掌握着一份包含约 350 个地块、总计超过 57,000 套新房的住房开发清单（Housing Pipeline）。然而，这些数据静静地躺在 Excel 表格里，仅仅是冰冷的数字。</p><p>我们的任务是：<strong>如何让这些数据“活”过来？</strong></p><p>作为开发者，我们深知仅仅在地图上标出“这里要建房”是远远不够的。城市规划是一个复杂的系统工程。我们在哪里建房？那个地方安全吗？那里的能源贫困率如何？是否存在社会剥夺现象？我们是否应当优先开发废弃的褐地（Brownfield）？</p><p>为了回答这些问题，我带领团队构建了一个基于 Python 的地理空间分析与可视化系统。我们没有止步于简单的数据展示，而是将治安数据、社会剥夺指数、褐地数据与住房规划进行了深度融合，并通过自定义 JavaScript 实现了一个动态权重的“脆弱性热力图”。</p><p>这篇文章将复盘整个技术实现过程，希望能给对 GIS（地理信息系统）和数据可视化感兴趣的朋友提供一些思路。</p><hr><h2 id=数据的孤岛与桥梁>数据的孤岛与桥梁<a hidden class=anchor aria-hidden=true href=#数据的孤岛与桥梁>#</a></h2><p>在开始写代码之前，我们面临的最大挑战是数据源的异构性。我们手头有五种完全不同格式的数据：</p><ol><li><strong>住房规划数据（Housing Pipeline）</strong>：这是核心数据，Excel 格式，包含项目名称、开发商、邮编、规划单元数等。</li><li><strong>行政边界数据（Boundaries）</strong>：GeoJSON 格式，定义了利物浦城市地区的地理边界。</li><li><strong>LSOA 统计分区数据</strong>：LSOA（Lower Layer Super Output Areas）是英国统计局定义的小地理单元，是我们进行空间分析的基准。</li><li><strong>多重剥夺指数（IMD）与燃料贫困数据</strong>：Excel 格式，提供了每个 LSOA 的社会经济指标。</li><li><strong>警方治安数据</strong>：这是最棘手的部分。它是按月分文件夹存储的数百个 CSV 文件，包含具体的经纬度坐标。</li><li><strong>褐地（Brownfield）数据</strong>：GeoJSON 格式，包含废弃土地的位置和面积。</li></ol><p>我们的目标是将这些散落在不同维度的“孤岛”数据，全部统一映射到 <strong>LSOA</strong> 这个地理单元上。</p><h3 id=数据清洗与地理编码>数据清洗与地理编码<a hidden class=anchor aria-hidden=true href=#数据清洗与地理编码>#</a></h3><p>住房规划数据中只有邮编（Postcode），没有经纬度。这是地理分析中常见的问题。我们使用了 <code>pgeocode</code> 库来解决这个问题，它基于 GeoNames 数据库，查询速度极快，不需要调用昂贵的 Google Maps API。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pgeocode
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 初始化英国的邮编查询对象</span>
</span></span><span style=display:flex><span>nomi <span style=color:#f92672>=</span> pgeocode<span style=color:#f92672>.</span>Nominatim(<span style=color:#e6db74>&#34;GB&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>batch_geocode</span>(df, postcode_col):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 清洗邮编格式</span>
</span></span><span style=display:flex><span>    clean_postcodes <span style=color:#f92672>=</span> df[postcode_col]<span style=color:#f92672>.</span>astype(str)<span style=color:#f92672>.</span>str<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>    unique_pcs <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>unique()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 批量查询，提高效率</span>
</span></span><span style=display:flex><span>    geo_results <span style=color:#f92672>=</span> nomi<span style=color:#f92672>.</span>query_postal_code(unique_pcs)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 建立映射字典</span>
</span></span><span style=display:flex><span>    pc_to_lat <span style=color:#f92672>=</span> dict(zip(unique_pcs, geo_results<span style=color:#f92672>.</span>latitude))
</span></span><span style=display:flex><span>    pc_to_lon <span style=color:#f92672>=</span> dict(zip(unique_pcs, geo_results<span style=color:#f92672>.</span>longitude))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;lat&#34;</span>] <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>map(pc_to_lat)
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;lon&#34;</span>] <span style=color:#f92672>=</span> clean_postcodes<span style=color:#f92672>.</span>map(pc_to_lon)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> df<span style=color:#f92672>.</span>dropna(subset<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;lat&#34;</span>, <span style=color:#e6db74>&#34;lon&#34;</span>])
</span></span></code></pre></div><p>这一步至关重要，它将业务数据（Excel）转化为了空间数据（Points）。</p><h3 id=处理海量治安数据>处理海量治安数据<a hidden class=anchor aria-hidden=true href=#处理海量治安数据>#</a></h3><p>警方提供的数据非常详尽，涵盖了过去三年的每个月的犯罪记录，甚至包括“拦截搜查”（Stop & Search）的具体坐标。文件数量多达几百个。</p><p>如果我们直接读取所有 CSV 并试图在地图上画点，浏览器会瞬间崩溃。因此，<strong>空间聚合（Spatial Aggregation）</strong> 是唯一的出路。我们需要计算出每个 LSOA 区域内发生了多少起犯罪。</p><p>这里我们使用了 <code>pathlib</code> 进行递归文件查找，并结合 Pandas 进行数据清洗：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 递归查找所有 CSV 文件</span>
</span></span><span style=display:flex><span>all_csvs <span style=color:#f92672>=</span> list(Path(<span style=color:#e6db74>&#34;police_data&#34;</span>)<span style=color:#f92672>.</span>rglob(<span style=color:#e6db74>&#34;*.csv&#34;</span>))
</span></span><span style=display:flex><span>stop_search_points <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> csv_file <span style=color:#f92672>in</span> all_csvs:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 只读取必要的经纬度列，节省内存</span>
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(csv_file, usecols<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;Latitude&#34;</span>, <span style=color:#e6db74>&#34;Longitude&#34;</span>])
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>dropna()
</span></span><span style=display:flex><span>        <span style=color:#75715e># 粗略过滤掉不在利物浦范围内的点，加速后续处理</span>
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> (df[<span style=color:#e6db74>&#39;Latitude&#39;</span>]<span style=color:#f92672>.</span>between(<span style=color:#ae81ff>53.0</span>, <span style=color:#ae81ff>54.0</span>)) <span style=color:#f92672>&amp;</span> \
</span></span><span style=display:flex><span>               (df[<span style=color:#e6db74>&#39;Longitude&#39;</span>]<span style=color:#f92672>.</span>between(<span style=color:#f92672>-</span><span style=color:#ae81ff>3.5</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span>))
</span></span><span style=display:flex><span>        stop_search_points<span style=color:#f92672>.</span>append(df[mask])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 合并所有数据帧</span>
</span></span><span style=display:flex><span>all_stops <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>concat(stop_search_points, ignore_index<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><hr><h2 id=空间连接>空间连接<a hidden class=anchor aria-hidden=true href=#空间连接>#</a></h2><p>现在我们有了一堆犯罪地点的“点”，和一堆代表社区的“面”（LSOA Polygons）。我们要回答的问题是：<strong>这个点属于哪个面？</strong></p><p>在 <code>geopandas</code> 中，<code>sjoin</code>（Spatial Join）函数是处理这类问题的神器。它是基于几何关系的数据库连接操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> geopandas <span style=color:#66d9ef>as</span> gpd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将警方数据转换为 GeoDataFrame</span>
</span></span><span style=display:flex><span>gdf_stops <span style=color:#f92672>=</span> gpd<span style=color:#f92672>.</span>GeoDataFrame(
</span></span><span style=display:flex><span>    all_stops, 
</span></span><span style=display:flex><span>    geometry<span style=color:#f92672>=</span>gpd<span style=color:#f92672>.</span>points_from_xy(all_stops<span style=color:#f92672>.</span>Longitude, all_stops<span style=color:#f92672>.</span>Latitude),
</span></span><span style=display:flex><span>    crs<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;EPSG:4326&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 核心操作：判断点在哪个多边形内 (predicate=&#39;within&#39;)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lsoa_lcr 是我们的行政区划多边形数据</span>
</span></span><span style=display:flex><span>stops_with_lsoa <span style=color:#f92672>=</span> gpd<span style=color:#f92672>.</span>sjoin(gdf_stops, lsoa_lcr[[<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>, <span style=color:#e6db74>&#39;geometry&#39;</span>]], predicate<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;within&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 聚合统计：计算每个 LSOA 的犯罪数量</span>
</span></span><span style=display:flex><span>stop_counts <span style=color:#f92672>=</span> stops_with_lsoa[<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>]<span style=color:#f92672>.</span>value_counts()<span style=color:#f92672>.</span>reset_index()
</span></span><span style=display:flex><span>stop_counts<span style=color:#f92672>.</span>columns <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;LSOA21CD&#39;</span>, <span style=color:#e6db74>&#39;StopSearch_Count&#39;</span>]
</span></span></code></pre></div><p>通过这一步，我们将数以万计的离散坐标点，转化为了每个社区的单一统计指标。这是数据降维的关键。</p><p>同理，我们将燃料贫困数据（Fuel Poverty）和多重剥夺指数（IMD）通过 <code>LSOA21CD</code> 代码 merge 到我们的主 GeoDataFrame 中。</p><hr><h2 id=构建脆弱性评分与动态归一化>构建“脆弱性评分”与动态归一化<a hidden class=anchor aria-hidden=true href=#构建脆弱性评分与动态归一化>#</a></h2><p>有了原始数据后，我们面临一个新问题：不同指标的量纲完全不同。犯罪数量可能是 0 到 500，而贫困率是 0% 到 100%，IMD 是 1 到 10 的等级。为了在一个地图上综合展示这些信息，我们需要进行<strong>归一化（Normalization）</strong>。</p><p>我们采用了 Min-Max 归一化，将所有指标映射到 0 到 1 之间。值得注意的是，对于 IMD（1 代表最贫困），我们需要反转它，使得 1 代表“高风险/高脆弱性”。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 归一化燃料贫困率</span>
</span></span><span style=display:flex><span>f_min, f_max <span style=color:#f92672>=</span> master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>]<span style=color:#f92672>.</span>min(), master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_fuel&#34;</span>] <span style=color:#f92672>=</span> (master_gdf[<span style=color:#e6db74>&#34;Fuel_Poverty_Rate&#34;</span>] <span style=color:#f92672>-</span> f_min) <span style=color:#f92672>/</span> (f_max <span style=color:#f92672>-</span> f_min)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 归一化 IMD (反转，10为最不贫困，1为最贫困 -&gt; 映射后 1.0 为高风险)</span>
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_imd&#34;</span>] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>11</span> <span style=color:#f92672>-</span> master_gdf[<span style=color:#e6db74>&#34;IMD_Decile&#34;</span>]) <span style=color:#f92672>/</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 归一化犯罪数据 (使用 95 分位值作为最大值，防止极端异常值拉低整体区分度)</span>
</span></span><span style=display:flex><span>c_max <span style=color:#f92672>=</span> master_gdf[<span style=color:#e6db74>&#34;Crime_Count&#34;</span>]<span style=color:#f92672>.</span>quantile(<span style=color:#ae81ff>0.95</span>)
</span></span><span style=display:flex><span>master_gdf[<span style=color:#e6db74>&#34;norm_crime&#34;</span>] <span style=color:#f92672>=</span> (master_gdf[<span style=color:#e6db74>&#34;Crime_Count&#34;</span>] <span style=color:#f92672>/</span> c_max)<span style=color:#f92672>.</span>clip(upper<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>)
</span></span></code></pre></div><p><strong>为什么使用 95 分位数？</strong>
在实际的城市数据中，市中心（City Centre）的犯罪率往往是郊区的几十倍。如果直接使用最大值进行归一化，市中心会是深红色，而其他所有区域都会变成近乎白色的浅色，导致郊区之间的差异无法体现。截断极端值可以保留大部分区域的对比度。</p><hr><h2 id=可视化>可视化<a hidden class=anchor aria-hidden=true href=#可视化>#</a></h2><p>如果只是用 <code>matplotlib</code> 画一张静态图，那对于决策者来说意义有限。我们需要的是交互性。我们选择了 <code>Folium</code>（基于 Leaflet.js），但原生的 Folium 功能有限，无法实现“拖动滑块实时改变权重”的功能。</p><p>为了解决这个问题，我采用了<strong>注入自定义 JavaScript</strong> 的方案。</p><h3 id=图层分级策略>图层分级策略<a hidden class=anchor aria-hidden=true href=#图层分级策略>#</a></h3><p>在地图上叠加多个图层时，遮挡是最大的敌人。我们通过自定义 Pane 并设置 <code>z-index</code> 来严格控制图层层级：</p><ol><li><strong>LSOA 基础着色层 (z=400)</strong>：最底层，显示脆弱性热力图。</li><li><strong>住房项目层 (z=620)</strong>：中间层，显示规划中的新房（气泡图）。</li><li><strong>褐地数据层 (z=650)</strong>：最顶层，显示可用的废弃土地点位。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> folium
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> folium<span style=color:#f92672>.</span>Map(location<span style=color:#f92672>=</span>[centre_lat, centre_lon], zoom_start<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>, tiles<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;CartoDB positron&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建自定义图层面板</span>
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;poly_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>400</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;housing_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>620</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span><span style=display:flex><span>folium<span style=color:#f92672>.</span>map<span style=color:#f92672>.</span>CustomPane(<span style=color:#e6db74>&#34;brownfield_pane&#34;</span>, z_index<span style=color:#f92672>=</span><span style=color:#ae81ff>650</span>)<span style=color:#f92672>.</span>add_to(m)
</span></span></code></pre></div><h3 id=注入-javascript-实现动态权重计算>注入 JavaScript 实现动态权重计算<a hidden class=anchor aria-hidden=true href=#注入-javascript-实现动态权重计算>#</a></h3><p>这是本项目最核心的创新点。我们不希望仅仅展示一张死板的地图，而是希望让用户（比如警察局长、城市规划师或社会工作者）根据他们的关注点调整权重。</p><p>我们将处理好的 GeoJSON 数据和前端逻辑直接写入 HTML 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> branca.element <span style=color:#f92672>import</span> Element
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将 Python 处理好的数据转为 JSON 字符串注入前端</span>
</span></span><span style=display:flex><span>geojson_str <span style=color:#f92672>=</span> master_gdf<span style=color:#f92672>.</span>to_json()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>custom_ui <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;div id=&#34;controls&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;h4&gt;Layer Weights (LSOA Scoring)&lt;/h4&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;!-- 滑块控件 --&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;div&gt;&lt;label&gt;Fuel Poverty&lt;/label&gt;&lt;input type=&#34;range&#34; id=&#34;w_fuel&#34; oninput=&#34;updateWeights()&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;div&gt;&lt;label&gt;Crime Density&lt;/label&gt;&lt;input type=&#34;range&#34; id=&#34;w_crime&#34; oninput=&#34;updateWeights()&#34;&gt;&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &lt;!-- ... 其他滑块 ... --&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;script&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    var lsoaData = </span><span style=color:#e6db74>{</span>geojson_str<span style=color:#e6db74>}</span><span style=color:#e6db74>; // 注入数据
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    // 动态计算分数的函数
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    function updateWeights() </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        // 获取滑块的值
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        var w_fuel = parseFloat(document.getElementById(&#39;w_fuel&#39;).value);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        var w_crime = parseFloat(document.getElementById(&#39;w_crime&#39;).value);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        // 遍历每个地理单元重新计算颜色
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        geojsonLayer.eachLayer(function(layer) </span><span style=color:#ae81ff>{{</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            var p = layer.feature.properties;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            // 加权平均公式
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            var score = (p.norm_fuel * w_fuel + p.norm_crime * w_crime) / (w_fuel + w_crime);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            // 动态设置样式
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            layer.setStyle(</span><span style=color:#ae81ff>{{</span><span style=color:#e6db74> fillColor: getColor(score) </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    </span><span style=color:#ae81ff>}}</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;/script&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>m<span style=color:#f92672>.</span>get_root()<span style=color:#f92672>.</span>html<span style=color:#f92672>.</span>add_child(Element(custom_ui))
</span></span></code></pre></div><p>这段代码实现了一个完全前端的交互逻辑：数据在 Python 后端处理完毕后，前端浏览器负责实时的渲染和数学计算。这保证了地图的流畅性，用户在拖动滑块时，地图颜色会平滑过渡，直观地展示出不同侧重下的高风险区域。</p><h3 id=住房规划与褐地的可视化细节>住房规划与褐地的可视化细节<a hidden class=anchor aria-hidden=true href=#住房规划与褐地的可视化细节>#</a></h3><p>对于住房项目，我们使用 <code>CircleMarker</code>。</p><ul><li><strong>大小</strong>：代表规划的房屋数量（使用了平方根缩放，避免气泡过大）。</li><li><strong>填充颜色</strong>：代表开发阶段（短期、中期、长期）。</li><li><strong>边框颜色</strong>：代表地块面积大小。</li></ul><p>对于褐地（Brownfield），我们将其作为最顶层的黑色小点显示，点击后会弹出详细的规划许可状态和此前用途。这样的设计让规划者可以一目了然地看到：<strong>在这个高风险（红色）区域，是否有可利用的褐地（黑点）来建设新房，从而起到旧城改造的作用？</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tategotoazarasi.me/zh/tags/python/>Python</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/geopandas/>Geopandas</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/folium/>Folium</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/data-visualization/>Data-Visualization</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/gis/>Gis</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/urban-planning/>Urban-Planning</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/spatial-analysis/>Spatial-Analysis</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/smart-city/>Smart-City</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/data-science/>Data-Science</a></li><li><a href=https://blog.tategotoazarasi.me/zh/tags/hackathon/>Hackathon</a></li></ul><nav class=paginav><a class=prev href=https://blog.tategotoazarasi.me/zh/posts/reproducing-retinasim-on-hpc-cluster/><span class=title>« 上一页</span><br><span>在 HPC 集群上复现 RetinaSim</span>
</a><a class=next href=https://blog.tategotoazarasi.me/zh/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/><span class=title>下一页 »</span><br><span>将我的大学课程表导入个人日历：一次手动 API 探索与 iCalendar 文件生成实践</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.tategotoazarasi.me/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>