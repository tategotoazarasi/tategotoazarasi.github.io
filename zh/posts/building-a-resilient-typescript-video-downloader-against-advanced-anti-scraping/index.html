<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>构建一个能应对复杂反爬机制的 TypeScript 视频下载器 | Tategoto Azarasi</title>
<meta name=keywords content="typescript,nodejs,playwright,web-scraping,automation,video-downloader,anti-scraping,race-condition,network-interception,browser-automation,typescript-video-downloader,nodejs-playwright-tutorial,bypass-anti-scraping,handle-dynamic-content,playwright-network-interception,browser-automation-scripting,download-streaming-video,race-condition-in-web-scraping,page-evaluate-fetch,robust-downloader-nodejs,typescript-project-from-scratch,debugging-playwright,advanced-web-scraping-techniques,playwright-vs-puppeteer,content-delivery-network-cdn-scraping"><meta name=description content="记录了如何使用 TypeScript、Node.js 和 Playwright 从零开始构建一个能够应对复杂反爬机制、动态加载和网络竞态条件的健壮视频下载器。"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="构建一个能应对复杂反爬机制的 TypeScript 视频下载器"><meta property="og:description" content="记录了如何使用 TypeScript、Node.js 和 Playwright 从零开始构建一个能够应对复杂反爬机制、动态加载和网络竞态条件的健壮视频下载器。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-09T19:33:20+00:00"><meta property="article:modified_time" content="2025-11-09T19:33:20+00:00"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Playwright"><meta property="article:tag" content="Web-Scraping"><meta property="article:tag" content="Automation"><meta property="article:tag" content="Video-Downloader"><meta name=twitter:card content="summary"><meta name=twitter:title content="构建一个能应对复杂反爬机制的 TypeScript 视频下载器"><meta name=twitter:description content="记录了如何使用 TypeScript、Node.js 和 Playwright 从零开始构建一个能够应对复杂反爬机制、动态加载和网络竞态条件的健壮视频下载器。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"构建一个能应对复杂反爬机制的 TypeScript 视频下载器","item":"https://tategotoazarasi.github.io/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"构建一个能应对复杂反爬机制的 TypeScript 视频下载器","name":"构建一个能应对复杂反爬机制的 TypeScript 视频下载器","description":"记录了如何使用 TypeScript、Node.js 和 Playwright 从零开始构建一个能够应对复杂反爬机制、动态加载和网络竞态条件的健壮视频下载器。","keywords":["typescript","nodejs","playwright","web-scraping","automation","video-downloader","anti-scraping","race-condition","network-interception","browser-automation","typescript-video-downloader","nodejs-playwright-tutorial","bypass-anti-scraping","handle-dynamic-content","playwright-network-interception","browser-automation-scripting","download-streaming-video","race-condition-in-web-scraping","page-evaluate-fetch","robust-downloader-nodejs","typescript-project-from-scratch","debugging-playwright","advanced-web-scraping-techniques","playwright-vs-puppeteer","content-delivery-network-cdn-scraping"],"articleBody":"在现代 Web 开发中，我们经常会遇到一些看似简单但实际上充满挑战的任务。最近，我就遇到了这样一个需求：从一个特定的视频网站下载一个视频。这个网站并非简单的静态页面，它大量使用 JavaScript 动态加载内容，并且部署了相当复杂的反爬虫和内容保护机制。这篇博客将详细记录我如何从零开始，使用 Node.js、TypeScript 和 Playwright，一步步构建出一个能够应对这些挑战的健壮下载工具的完整过程。\n初步构想与技术选型 任务的起点非常明确：给定一个网页 URL，我需要将该页面上的主视频下载到本地。我的第一反应是检查网页的源代码，看看是否能直接找到 .mp4 文件的链接。然而，现实很快给了我一击。打开浏览器的开发者工具，我发现初始的 HTML 文档中根本没有任何直接指向视频文件的 URL。所有的视频播放器、视频源信息，都是在页面加载后，通过执行一系列复杂的 JavaScript 脚本才动态生成和注入到页面中的。\n这立刻排除了使用 curl 或 wget，甚至是 Node.js 中简单的 axios 或 node-fetch 等传统 HTTP 请求库的方案。这些工具只能获取到最初的、不包含任何视频信息的 HTML 骨架。它们无法模拟一个真实的用户环境，无法执行 JavaScript，因此也就永远无法“看到”那个由脚本动态生成的视频播放器。\n我立刻意识到，解决这个问题的关键在于模拟一个完整的浏览器环境。我需要一个工具，它不仅能加载网页，还要能像 Chrome 或 Firefox 一样，拥有一个 JavaScript 引擎来执行页面上的所有脚本，渲染 DOM，并响应用户的交互。\n在技术选型上，我很快锁定了几个关键技术栈：\nNode.js: 作为后端运行环境，它拥有强大的文件系统操作能力和丰富的生态系统，是构建这类自动化工具的理想平台。\nTypeScript: 我选择 TypeScript 而不是原生 JavaScript，主要是出于对项目长期可维护性和健壮性的考虑。TypeScript 的静态类型检查可以在编码阶段就发现大量的潜在错误，比如拼写错误、类型不匹配等。对于一个需要处理复杂浏览器 API 和网络数据流的项目来说，类型安全能够极大地提升开发效率和代码质量。这不仅仅是一个个人偏好，更是一个工程决策。\nPlaywright: 在浏览器自动化工具方面，有两个主流选择：Puppeteer 和 Playwright。尽管两者都非常出色，但我最终选择了 Playwright。Playwright 是由微软推出的更现代化的工具，它提供了跨浏览器（Chromium, Firefox, WebKit）支持，API 设计更加简洁和强大，并且在处理等待、交互和网络拦截等方面提供了非常灵活和可靠的接口。我相信，对于一个可能存在复杂反爬机制的网站，Playwright 提供的强大网络控制能力将是至关重要的。\n技术栈确定后，我开始了项目的搭建。这个过程本身就是展示一个工程师基本功底的环节。我创建了一个新的项目目录，使用 npm init -y 初始化了 package.json，然后安装了核心依赖 playwright 和开发依赖 typescript, ts-node, @types/node。接着，通过 npx tsc --init 创建了 tsconfig.json 文件。\n我对 tsconfig.json 进行了精心的配置，使其符合现代 Node.js 开发的最佳实践。例如，我将 target 设置为 ES2020 以便使用 async/await 等现代语法，module 设置为 CommonJS（这是我们旅程初期的选择，后来会演进），并明确了 rootDir 和 outDir 来分离源码和编译产物。这些看似微小的配置，却是一个项目走向规范化的第一步。\n模拟点击与被动监听 项目框架搭建完毕，我开始编写核心逻辑。我的第一个版本的核心思路非常直接，可以概括为“模拟用户，监听网络”。\n首先，我设计了一个 VideoDownloader 类，将所有相关的操作封装起来。这是一个良好的工程习惯，可以使代码结构更清晰，易于扩展和维护。\n我的第一步是实现最基本的用户行为模拟。我编写了几个核心的私有方法：initialize 用于启动 Playwright 并创建一个新的浏览器页面实例；navigateToPage 用于导航到用户提供的目标 URL；clickPlayButton 用于找到并点击页面上的播放按钮。\n这里的关键假设是：视频的真实 URL 只有在用户点击了播放按钮之后才会开始加载。因此，我的主要任务就是找到那个播放按钮。通过检查页面的 DOM 结构，我定位到了播放按钮的 CSS 选择器，它是一个带有特定类名的 button 元素。\n但是，仅仅点击按钮是不够的。点击之后，浏览器会发起对视频文件的网络请求，我需要捕获这个请求。Playwright 强大的网络监听功能在这里派上了用场。我在 initialize 方法中，紧接着创建页面实例之后，就注册了一个网络响应监听器：\n// 核心代码片段 - 注册响应监听器 this.page.on('response', this.handleResponse.bind(this)); 这个监听器会捕获页面上发生的所有网络响应。handleResponse 方法则是我实现的核心过滤和数据处理逻辑。\n在这个方法里，我需要从成百上千的网络请求中精确地找出视频分片。通过在浏览器开发者工具的网络面板中观察，我发现了视频请求的几个显著特征：\n第一，请求的 URL 包含特定的文件扩展名，比如 .mp4。 第二，视频通常是分片加载的，以支持拖动进度条和节省带宽。这种分片加载在 HTTP 协议中通过 Range 请求头和状态码 206 Partial Content 来实现。服务器返回的响应头里会包含一个 Content-Range 字段，明确告知这个分片在整个视频文件中的位置和总大小。\n基于这些观察，我确定了我的过滤逻辑：只处理那些 URL 包含特定关键字（如 .mp4）且 HTTP 状态码为 206 的响应。\n接下来的问题是，如何处理这些捕获到的、可能乱序到达的视频分片？如果简单地把它们放进一个数组里，最后拼接出来的文件很可能是损坏的。正确的做法是根据它们在完整视频中的位置来存储。Content-Range 头提供了这个关键信息，例如 bytes 0-5242879/906098800，表示这是从第 0 字节开始的数据块。\n因此，我决定使用一个 Map 数据结构来存储分片，以分片的起始字节作为键（key），以包含二进制数据的 Buffer 作为值（value）。\n// 核心代码片段 - 使用 Map 存储分片 private videoChunks: Map\u003cnumber, Buffer\u003e = new Map(); // 在 handleResponse 中 const rangeMatch = contentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/); if (rangeMatch) { const start = Number.parseInt(rangeMatch[1], 10); const buffer = await response.body(); // 这是我们早期的一个错误，后面会详述 this.videoChunks.set(start, buffer); } 这种做法的优势在于，无论分片以何种顺序到达，我都能将它们精确地放置在正确的位置上。\n最后一步是文件组装。当所有分片都下载完毕后，我需要将它们按正确的顺序写入一个本地文件。为了效率和内存考虑，我没有选择将所有分片在内存中拼接成一个巨大的 Buffer，而是利用了 Node.js 的流（Stream）API。我创建了一个 fs.createWriteStream，然后遍历 Map 中所有的键（也就是分片的起始字节），对这些键进行排序，再依次从 Map 中取出对应的 Buffer 写入到流中。这种流式写入的方式内存占用极低，即使是几十 GB 的大文件也能轻松处理。\n至此，我的第一个版本的逻辑已经完整。它看起来很完美：模拟用户点击，监听网络，过滤视频分片，有序存储，高效写入。我满怀信心地运行了脚本。\n超时与 networkidle 的陷阱 程序运行后，终端输出停在了“正在导航到页面…”，然后在一分钟后，一个鲜红的错误信息宣告了第一次尝试的失败：page.goto: Timeout 60000ms exceeded. waiting until \"networkidle\"。\n超时错误。这是自动化测试和网络爬虫中非常常见的问题。我立刻审查了我的 navigateToPage 方法：\n// 早期错误代码 await this.page.goto(this.url, { waitUntil: 'networkidle', timeout: 60000 }); 问题就出在 waitUntil: 'networkidle' 这个选项上。它的意思是告诉 Playwright，等到页面加载完毕，并且网络在 500 毫秒内没有任何新的活动时，才算导航成功。\n这个选项在处理一些简单的、加载完就“安静”下来的静态页面时非常有用。然而，对于我正在处理的这个现代化的、动态的视频网站来说，这简直是一个不可能满足的条件。这类网站的前端应用非常复杂，它们在后台会持续不断地进行各种网络活动：\n发送用户行为分析和跟踪数据。 定时刷新广告内容。 通过长轮询或 WebSocket 与服务器保持连接以获取实时更新。 预加载图片或其他媒体资源。 在这种情况下，页面的网络活动几乎永远不会“空闲”超过 500 毫秒。我的程序苦苦等待了 60 秒，最终只能无奈超时。\n这次失败让我意识到，我的等待策略必须更加精确。我不需要等待整个页面都“风平浪静”，我只需要等到我需要交互的那个关键元素——播放按钮——出现并可用即可。\n我迅速调整了策略。首先，我将 page.goto 的等待条件从 networkidle 放宽为 domcontentloaded。这个选项告诉 Playwright，只要页面的核心 HTML 文档加载并解析完成，就可以继续执行下一步，无需等待所有图片、样式表和异步脚本加载完毕。这使得导航步骤能够快速、可靠地完成。\n然后，我将真正的、精确的等待逻辑放在了 clickPlayButton 方法中。这个方法内部本来就已经有了 await this.page.waitForSelector(playButtonSelector, ...) 的调用。这才是正确的“等待”，因为它等待的是一个具体的目标，而不是一个模糊的、难以达成的网络状态。\n在修复这个问题的过程中，我还做了一个额外的优化。我意识到，那些持续不断的后台网络活动，很多都与广告和追踪脚本有关。这些请求不仅拖慢了页面加载速度，增加了 networkidle 超时的风险，而且对于我的下载任务来说是完全无用的。于是，我决定在导航之前就设置一个请求拦截器，主动屏蔽掉这些不必要的请求。\n// 核心代码片段 - 屏蔽不必要的请求 await this.page.route('**/*', (route) =\u003e { const url = route.request().url(); if (url.includes('google-analytics.com') || url.includes('doubleclick.net')) { return route.abort(); } return route.continue(); }); 这个小小的改动，不仅让页面加载更快，也让我的自动化脚本运行环境更干净、更可预测。这体现了一个工程师从“让它工作”到“让它工作得更好”的思维转变。\n竞态条件 解决了导航超时问题后，我再次运行程序。这一次，日志显示页面成功加载，播放按钮也被成功点击。我仿佛听到了胜利的号角。然而，几秒钟后，一个新的、更诡异的错误出现了：Protocol error (Network.getResponseBody): No data found for resource with given identifier。\n程序捕获到了视频分片的响应（response 对象），但在尝试获取其内容（await response.body()）时失败了。错误信息非常底层，直指浏览器开发工具协议（CDP）的层面。\n我花了很多时间来调试和理解这个错误。起初我怀疑是 Playwright 的 Bug，或者是网站有什么特殊的加密。但经过反复试验和查阅资料，我最终锁定了问题的根源——一个经典而棘手的“竞态条件”（Race Condition）。\n我的代码和浏览器内部的媒体处理管线，正在进行一场速度竞赛，而我输了。\n事情的经过是这样的：\n浏览器发起对视频分片的请求。 服务器返回数据，Playwright 的底层通过 CDP 协议检测到了这个响应，并通知了我的 Node.js 进程。 Node.js 的事件循环机制将一个 'response' 事件放入事件队列。 与此同时，浏览器作为一个高度优化的 C++ 程序，并没有等待我的 Node.js 脚本。它的网络堆栈收到视频数据后，可能立即就通过“零拷贝”之类的技术将数据直接送往 GPU 或媒体解码器进行播放。为了极致的性能，它在完成这个操作后，会立刻从内存中清除这份数据，因为它认为这份数据已经“消费”完毕。 轮到 Node.js 的事件循环处理我的 'response' 事件时，我的 handleResponse 回调函数开始执行。当代码运行到 await response.body() 时，它通过 CDP 协议向浏览器请求：“请把刚才那个响应的数据给我。” 浏览器回复：“抱歉，你说的那个东西，我早就处理完扔掉了。数据已经不在了。” 于是，No data found for resource 的错误就发生了。 这个过程中的延迟可能只有几毫秒甚至微秒，但在高性能的浏览器内核面前，这点时间足以让数据消失。我意识到，任何形式的“事后监听”，即在响应发生之后再去尝试获取数据的方案，都存在失败的风险。\n为了战胜这个竞态条件，我需要一种更主动、更具侵入性的方法。我再次求助于 page.route。这次，我不仅仅是用它来 abort() 请求，而是要用它来完全地“代理”视频请求。我的新思路是：\n拦截一个即将发出的视频请求。 不让浏览器自己去请求，而是调用 route.fetch()，让 Playwright 的后端代替浏览器去完成这个请求。 拿到 route.fetch() 返回的 APIResponse 对象后，我可以安全地从中 await response.body()，因为这是我自己的请求，数据被完整地保留了下来。 获取到数据并存入我的 videoChunks Map 之后，我再调用 route.fulfill({ response })，将我获取到的这个响应“伪造”一份交还给浏览器，让页面上的播放器以为一切正常。 这个方案理论上是完美的。它把被动的监听变成了主动的代理，从根本上解决了竞态问题。我重构了代码，满怀信心地再次运行。\n程序运行了！我成功地捕获到了第一个、第二个分片的数据！然而，喜悦是短暂的。下载了几个分片（大约 9MB）之后，网络请求戛然而止。程序在等待 20 秒后超时退出，留下一个不完整的文件。\n为什么下载链会中断？我的 route.fulfill() 难道没有成功“欺骗”播放器吗？\n为了找出真相，我为我的拦截器添加了极其详尽的日志，打印每一个被拦截的请求的 URL、方法、类型，以及视频响应的完整头信息。\n日志很快揭示了第一个惊人的发现：播放器在点击播放后，同时并发地请求了多个不同分辨率的视频流！例如 720P.mp4, 1440P.mp4, 2048P.mp4。它似乎是在探测当前网速最适合哪个码率。\n而我的代码存在一个严重的逻辑缺陷：我用一个全局的 activeVideoUrl 变量来锁定我下载的第一个视频流。当 720P.mp4 的请求先到时，我的程序就“认定”了这是要下载的目标，然后无情地忽略了所有后续的 1440P 和 2048P 请求。然而，播放器在短暂的探测后，可能最终决定持续播放的是 2048P 的流。由于我的程序没有正确地 fulfill 2048P 的请求（因为它忽略了它们），播放器的状态机被破坏，于是它停止了所有后续的请求。\n我立刻修正了这个逻辑。我不再“先入为主”，而是维护一个所有候选流的列表。下载结束后，我再从中选择一个“最佳”的流进行组装。我最初的“最佳”标准是“分片数量最多”。\n然而，再次运行后，问题依旧。日志显示，所有分辨率的流都只被请求了 2 个分片，然后就都停止了。我的“选择分片数量最多”的策略在这种情况下退化成了“选择第一个”，依然是错误的。\n这时，我才终于触及了问题的本质。不是我的选择逻辑有问题，而是**route.fulfill() 本身就是有问题的**。我用 route.fetch() 获取的 APIResponse 对象，虽然包含了数据，但它终究是一个“克隆品”。当通过 route.fulfill() 交还给浏览器时，它可能丢失了某些对播放器至关重要的底层连接句柄、时序信息或其他元数据。这个“不完美”的响应，虽然能提供最初的几个分片数据，但足以破坏播放器精密的内部状态，导致它无法或不愿请求后续的分片。\n从被动监听到主动控制 在经历了 page.on('response') 的竞态失败和 route.fulfill() 的状态破坏之后，我陷入了沉思。我似乎陷入了一个两难的境地：要么太慢，要么干扰太大。\n就在这时，一个全新的思路在我脑中形成。我之前所有的尝试，都围绕着一个核心思想：如何从浏览器发起的请求中“窃取”数据。无论是监听还是代理，我都是一个依附于浏览器行为的“寄生者”。\n为什么不反过来呢？我为什么不能成为下载过程的主导者？\n这个想法彻底改变了我的整个架构。新的、最终的方案诞生了，它分为两个明确的阶段：侦察和接管。\n侦察 我依然使用 page.route 拦截网络请求。但这一次，它的目的变得极其单纯：只看不碰。当一个视频分片请求被拦截时，我什么也不做，只是立刻调用 route.continue()，让浏览器畅通无阻地进行它自己的网络通信。这保证了播放器状态的绝对纯净和连续。 同时，我在后台悄悄地使用 page.waitForResponse() 等待这个刚刚被我放行的请求完成。当响应到达时，我从中解析出我需要的所有信息：完整的 URL（包含动态生成的 token）、视频总大小、以及分辨率。我将这些信息存入我的 discoveredStreams Map 中。 我设置一个 5-10 秒的侦察窗口。在这段时间里，播放器会像往常一样探测所有分辨率的流。我的侦察器会收集到所有这些流的信息。侦察窗口结束后，我检查 discoveredStreams，选择分辨率最高的那个流。至此，我拥有了下载完整高清视频所需的一切关键情报。\n接管 侦察任务完成，我不再关心浏览器后续的网络活动。我启动一个全新的、由我完全控制的下载循环。在这个循环中，我将执行整个方案中最核心、最精妙的操作：在浏览器内部为我工作。\n我使用 page.evaluate() 函数。这个函数可以在浏览器页面的上下文中执行任意的 JavaScript 代码。我在 Node.js 端计算出我需要下载的下一个分片的范围，例如 bytes=0-5242879，然后将这个范围和侦察到的高分辨率 URL 一起作为参数传递给 page.evaluate。\n// 核心代码片段 - 在浏览器内发起 fetch 请求 const chunkData = await this.page.evaluate(async ({ url, range }) =\u003e { const response = await fetch(url, { headers: { 'Range': range } }); if (!response.ok) throw new Error(`Fetch failed: ${response.status}`); const buffer = await response.arrayBuffer(); return { data: Array.from(new Uint8Array(buffer)) }; }, { url, range }); 这段代码的魔力在于，fetch(url, ...) 是在浏览器内部执行的。这意味着这个请求：\n自动携带了当前页面的所有 cookies 和 session 信息。 源自于同一个 IP 地址和浏览器指纹。 完全通过了网站可能部署的任何 Cloudflare 或其他 JavaScript 人机验证。 它是一个完美的、合法的、源自于真实用户会话的请求。服务器无法将其与播放器自身的请求区分开来。\nfetch 的响应是一个 ArrayBuffer，这是一个无法直接从浏览器传回 Node.js 的对象。因此，我巧妙地将其转换为一个普通的 JavaScript 数字数组 Array.from(new Uint8Array(buffer))，这是一个可以被序列化为 JSON 并跨进程边界传递的数据结构。\n在 Node.js 端，我接收到这个数字数组，再用 Buffer.from(chunkData.data) 将其转换回 Node.js 的 Buffer 对象，然后稳稳地写入文件流。\n我以一个 for 循环重复这个过程，按照我设定的分片大小，从头到尾，顺序地请求整个视频文件，直到下载完所有字节。\n这个方案最终被证明是无懈可击的。它彻底规避了竞态条件，因为它不再被动监听。它也完全避免了干扰播放器状态，因为它让浏览器的归浏览器，下载的归下载。我们只是借用了浏览器的“身份”去发我们自己的请求。\n完善用户体验和健壮性 解决了核心的下载难题后，我并没有就此止步。一个优秀的工程师不仅要解决问题，还要交付一个好用的工具。我开始为这个脚本添加一系列专业化的功能。\n支持命令行参数 我移除了硬编码的 TARGET_URL，改为使用 Node.js 的 process.argv 来解析命令行参数。现在，用户可以直接在 npm start 后面跟上任何想下载的视频 URL，极大地提高了工具的灵活性。我还添加了参数检查，如果用户没有提供 URL，程序会打印出用法提示并友好地退出。\n实现丰富的进度显示 一个漫长的下载过程如果没有进度反馈，体验是非常糟糕的。我创建了一个独立的 DownloadTracker 辅助类，专门用于处理下载统计。它在下载开始时记录一个时间戳，每次收到数据块时更新已下载的字节数。 为了避免因频繁更新而刷屏，我使用了一个简单的节流技巧：进度信息最多每秒更新一次。在每次更新时，它会计算：\n平均下载速度（Mbps）: (总下载字节 * 8) / 经过的秒数 / 1024 / 1024 剩余时间（秒）: (总大小 - 已下载大小) / 平均速度 预计完成时间（ETA）: 当前时间 + 剩余时间 然后，我将这些信息格式化成一行清晰的、不断刷新的状态栏，例如： Progress: 25.13% | 216.05MB / 860.00MB | Speed: 123.45 Mbps | ETA: 19:30:45 (55s remaining) 这为用户提供了极佳的实时反馈。 增加下载重试机制 网络是不稳定的。在下载一个大文件的过程中，任何一个分片因为暂时的网络波动而失败，都不应该导致整个任务的中止。我为下载单个分片的逻辑 downloadChunkWithRetries 增加了一个 while 循环实现的重试机制。 如果一次 fetch 失败，它不会立即放弃，而是会进入 catch 块。在这里，我会增加重试计数器，并采用“指数退避”策略计算一个等待时间（例如，第1次重试等2秒，第2次等4秒，第3次等8秒……）。在短暂等待后，它会再次尝试下载同一个分片。只有在达到最大重试次数（例如5次）后，程序才会最终放弃并中止整个下载。这个机制极大地增强了程序在不稳定网络环境下的健壮性。\n智能文件名提取 最后：从页面中提取有意义的标题作为文件名。我编写了一个 extractVideoTitle 方法，它会按优先级顺序查找页面中的特定元素（先是 p[lang=\"ja\"]，然后是 h2.mt-16），如果都找不到，则回退到使用 URL 的一部分。我还对提取出的标题进行了清理，移除了所有在文件名中非法的字符。最终，下载的文件被命名为 [视频标题]-[分辨率].mp4，一目了然。\n","wordCount":"637","inLanguage":"zh","datePublished":"2025-11-09T19:33:20Z","dateModified":"2025-11-09T19:33:20Z","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">构建一个能应对复杂反爬机制的 TypeScript 视频下载器</h1><div class=post-meta><span title='2025-11-09 19:33:20 +0000 UTC'>十一月 9, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;637 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/en/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#初步构想与技术选型>初步构想与技术选型</a></li><li><a href=#模拟点击与被动监听>模拟点击与被动监听</a></li><li><a href=#超时与-networkidle-的陷阱>超时与 <code>networkidle</code> 的陷阱</a></li><li><a href=#竞态条件>竞态条件</a></li><li><a href=#从被动监听到主动控制>从被动监听到主动控制</a><ol><li><a href=#侦察>侦察</a></li><li><a href=#接管>接管</a></li></ol></li><li><a href=#完善用户体验和健壮性>完善用户体验和健壮性</a><ol><li><a href=#支持命令行参数>支持命令行参数</a></li><li><a href=#实现丰富的进度显示>实现丰富的进度显示</a></li><li><a href=#增加下载重试机制>增加下载重试机制</a></li><li><a href=#智能文件名提取>智能文件名提取</a></li></ol></li></ol></nav></div></details></div><div class=post-content><p>在现代 Web 开发中，我们经常会遇到一些看似简单但实际上充满挑战的任务。最近，我就遇到了这样一个需求：从一个特定的视频网站下载一个视频。这个网站并非简单的静态页面，它大量使用 JavaScript 动态加载内容，并且部署了相当复杂的反爬虫和内容保护机制。这篇博客将详细记录我如何从零开始，使用 Node.js、TypeScript 和 Playwright，一步步构建出一个能够应对这些挑战的健壮下载工具的完整过程。</p><h2 id=初步构想与技术选型>初步构想与技术选型<a hidden class=anchor aria-hidden=true href=#初步构想与技术选型>#</a></h2><p>任务的起点非常明确：给定一个网页 URL，我需要将该页面上的主视频下载到本地。我的第一反应是检查网页的源代码，看看是否能直接找到 <code>.mp4</code> 文件的链接。然而，现实很快给了我一击。打开浏览器的开发者工具，我发现初始的 HTML 文档中根本没有任何直接指向视频文件的 URL。所有的视频播放器、视频源信息，都是在页面加载后，通过执行一系列复杂的 JavaScript 脚本才动态生成和注入到页面中的。</p><p>这立刻排除了使用 <code>curl</code> 或 <code>wget</code>，甚至是 Node.js 中简单的 <code>axios</code> 或 <code>node-fetch</code> 等传统 HTTP 请求库的方案。这些工具只能获取到最初的、不包含任何视频信息的 HTML 骨架。它们无法模拟一个真实的用户环境，无法执行 JavaScript，因此也就永远无法“看到”那个由脚本动态生成的视频播放器。</p><p>我立刻意识到，解决这个问题的关键在于模拟一个完整的浏览器环境。我需要一个工具，它不仅能加载网页，还要能像 Chrome 或 Firefox 一样，拥有一个 JavaScript 引擎来执行页面上的所有脚本，渲染 DOM，并响应用户的交互。</p><p>在技术选型上，我很快锁定了几个关键技术栈：</p><p><strong>Node.js</strong>: 作为后端运行环境，它拥有强大的文件系统操作能力和丰富的生态系统，是构建这类自动化工具的理想平台。</p><p><strong>TypeScript</strong>: 我选择 TypeScript 而不是原生 JavaScript，主要是出于对项目长期可维护性和健壮性的考虑。TypeScript 的静态类型检查可以在编码阶段就发现大量的潜在错误，比如拼写错误、类型不匹配等。对于一个需要处理复杂浏览器 API 和网络数据流的项目来说，类型安全能够极大地提升开发效率和代码质量。这不仅仅是一个个人偏好，更是一个工程决策。</p><p><strong>Playwright</strong>: 在浏览器自动化工具方面，有两个主流选择：Puppeteer 和 Playwright。尽管两者都非常出色，但我最终选择了 Playwright。Playwright 是由微软推出的更现代化的工具，它提供了跨浏览器（Chromium, Firefox, WebKit）支持，API 设计更加简洁和强大，并且在处理等待、交互和网络拦截等方面提供了非常灵活和可靠的接口。我相信，对于一个可能存在复杂反爬机制的网站，Playwright 提供的强大网络控制能力将是至关重要的。</p><p>技术栈确定后，我开始了项目的搭建。这个过程本身就是展示一个工程师基本功底的环节。我创建了一个新的项目目录，使用 <code>npm init -y</code> 初始化了 <code>package.json</code>，然后安装了核心依赖 <code>playwright</code> 和开发依赖 <code>typescript</code>, <code>ts-node</code>, <code>@types/node</code>。接着，通过 <code>npx tsc --init</code> 创建了 <code>tsconfig.json</code> 文件。</p><p>我对 <code>tsconfig.json</code> 进行了精心的配置，使其符合现代 Node.js 开发的最佳实践。例如，我将 <code>target</code> 设置为 <code>ES2020</code> 以便使用 <code>async/await</code> 等现代语法，<code>module</code> 设置为 <code>CommonJS</code>（这是我们旅程初期的选择，后来会演进），并明确了 <code>rootDir</code> 和 <code>outDir</code> 来分离源码和编译产物。这些看似微小的配置，却是一个项目走向规范化的第一步。</p><h2 id=模拟点击与被动监听>模拟点击与被动监听<a hidden class=anchor aria-hidden=true href=#模拟点击与被动监听>#</a></h2><p>项目框架搭建完毕，我开始编写核心逻辑。我的第一个版本的核心思路非常直接，可以概括为“模拟用户，监听网络”。</p><p>首先，我设计了一个 <code>VideoDownloader</code> 类，将所有相关的操作封装起来。这是一个良好的工程习惯，可以使代码结构更清晰，易于扩展和维护。</p><p>我的第一步是实现最基本的用户行为模拟。我编写了几个核心的私有方法：<code>initialize</code> 用于启动 Playwright 并创建一个新的浏览器页面实例；<code>navigateToPage</code> 用于导航到用户提供的目标 URL；<code>clickPlayButton</code> 用于找到并点击页面上的播放按钮。</p><p>这里的关键假设是：视频的真实 URL 只有在用户点击了播放按钮之后才会开始加载。因此，我的主要任务就是找到那个播放按钮。通过检查页面的 DOM 结构，我定位到了播放按钮的 CSS 选择器，它是一个带有特定类名的 <code>button</code> 元素。</p><p>但是，仅仅点击按钮是不够的。点击之后，浏览器会发起对视频文件的网络请求，我需要捕获这个请求。Playwright 强大的网络监听功能在这里派上了用场。我在 <code>initialize</code> 方法中，紧接着创建页面实例之后，就注册了一个网络响应监听器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 核心代码片段 - 注册响应监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;response&#39;</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handleResponse</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>this</span>));
</span></span></code></pre></div><p>这个监听器会捕获页面上发生的所有网络响应。<code>handleResponse</code> 方法则是我实现的核心过滤和数据处理逻辑。</p><p>在这个方法里，我需要从成百上千的网络请求中精确地找出视频分片。通过在浏览器开发者工具的网络面板中观察，我发现了视频请求的几个显著特征：</p><p>第一，请求的 URL 包含特定的文件扩展名，比如 <code>.mp4</code>。
第二，视频通常是分片加载的，以支持拖动进度条和节省带宽。这种分片加载在 HTTP 协议中通过 <code>Range</code> 请求头和状态码 <code>206 Partial Content</code> 来实现。服务器返回的响应头里会包含一个 <code>Content-Range</code> 字段，明确告知这个分片在整个视频文件中的位置和总大小。</p><p>基于这些观察，我确定了我的过滤逻辑：只处理那些 URL 包含特定关键字（如 <code>.mp4</code>）且 HTTP 状态码为 <code>206</code> 的响应。</p><p>接下来的问题是，如何处理这些捕获到的、可能乱序到达的视频分片？如果简单地把它们放进一个数组里，最后拼接出来的文件很可能是损坏的。正确的做法是根据它们在完整视频中的位置来存储。<code>Content-Range</code> 头提供了这个关键信息，例如 <code>bytes 0-5242879/906098800</code>，表示这是从第 <code>0</code> 字节开始的数据块。</p><p>因此，我决定使用一个 <code>Map</code> 数据结构来存储分片，以分片的起始字节作为键（<code>key</code>），以包含二进制数据的 <code>Buffer</code> 作为值（<code>value</code>）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 核心代码片段 - 使用 Map 存储分片
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#a6e22e>videoChunks</span>: <span style=color:#66d9ef>Map</span>&lt;<span style=color:#f92672>number</span>, <span style=color:#a6e22e>Buffer</span>&gt; <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 handleResponse 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rangeMatch</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>contentRange</span>.<span style=color:#a6e22e>match</span>(<span style=color:#e6db74>/bytes (\d+)-(\d+)\/(\d+)/</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>rangeMatch</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>start</span> <span style=color:#f92672>=</span> Number.parseInt(<span style=color:#a6e22e>rangeMatch</span>[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>body</span>(); <span style=color:#75715e>// 这是我们早期的一个错误，后面会详述
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>videoChunks</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>start</span>, <span style=color:#a6e22e>buffer</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种做法的优势在于，无论分片以何种顺序到达，我都能将它们精确地放置在正确的位置上。</p><p>最后一步是文件组装。当所有分片都下载完毕后，我需要将它们按正确的顺序写入一个本地文件。为了效率和内存考虑，我没有选择将所有分片在内存中拼接成一个巨大的 <code>Buffer</code>，而是利用了 Node.js 的流（Stream）API。我创建了一个 <code>fs.createWriteStream</code>，然后遍历 <code>Map</code> 中所有的键（也就是分片的起始字节），对这些键进行排序，再依次从 <code>Map</code> 中取出对应的 <code>Buffer</code> 写入到流中。这种流式写入的方式内存占用极低，即使是几十 GB 的大文件也能轻松处理。</p><p>至此，我的第一个版本的逻辑已经完整。它看起来很完美：模拟用户点击，监听网络，过滤视频分片，有序存储，高效写入。我满怀信心地运行了脚本。</p><h2 id=超时与-networkidle-的陷阱>超时与 <code>networkidle</code> 的陷阱<a hidden class=anchor aria-hidden=true href=#超时与-networkidle-的陷阱>#</a></h2><p>程序运行后，终端输出停在了“正在导航到页面&mldr;”，然后在一分钟后，一个鲜红的错误信息宣告了第一次尝试的失败：<code>page.goto: Timeout 60000ms exceeded. waiting until "networkidle"</code>。</p><p>超时错误。这是自动化测试和网络爬虫中非常常见的问题。我立刻审查了我的 <code>navigateToPage</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 早期错误代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span>.<span style=color:#66d9ef>goto</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span>, { <span style=color:#a6e22e>waitUntil</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;networkidle&#39;</span>, <span style=color:#a6e22e>timeout</span>: <span style=color:#66d9ef>60000</span> });
</span></span></code></pre></div><p>问题就出在 <code>waitUntil: 'networkidle'</code> 这个选项上。它的意思是告诉 Playwright，等到页面加载完毕，并且网络在 500 毫秒内没有任何新的活动时，才算导航成功。</p><p>这个选项在处理一些简单的、加载完就“安静”下来的静态页面时非常有用。然而，对于我正在处理的这个现代化的、动态的视频网站来说，这简直是一个不可能满足的条件。这类网站的前端应用非常复杂，它们在后台会持续不断地进行各种网络活动：</p><ul><li>发送用户行为分析和跟踪数据。</li><li>定时刷新广告内容。</li><li>通过长轮询或 WebSocket 与服务器保持连接以获取实时更新。</li><li>预加载图片或其他媒体资源。</li></ul><p>在这种情况下，页面的网络活动几乎永远不会“空闲”超过 500 毫秒。我的程序苦苦等待了 60 秒，最终只能无奈超时。</p><p>这次失败让我意识到，我的等待策略必须更加精确。我不需要等待整个页面都“风平浪静”，我只需要等到我需要交互的那个<strong>关键元素</strong>——播放按钮——出现并可用即可。</p><p>我迅速调整了策略。首先，我将 <code>page.goto</code> 的等待条件从 <code>networkidle</code> 放宽为 <code>domcontentloaded</code>。这个选项告诉 Playwright，只要页面的核心 HTML 文档加载并解析完成，就可以继续执行下一步，无需等待所有图片、样式表和异步脚本加载完毕。这使得导航步骤能够快速、可靠地完成。</p><p>然后，我将真正的、精确的等待逻辑放在了 <code>clickPlayButton</code> 方法中。这个方法内部本来就已经有了 <code>await this.page.waitForSelector(playButtonSelector, ...)</code> 的调用。这才是正确的“等待”，因为它等待的是一个具体的目标，而不是一个模糊的、难以达成的网络状态。</p><p>在修复这个问题的过程中，我还做了一个额外的优化。我意识到，那些持续不断的后台网络活动，很多都与广告和追踪脚本有关。这些请求不仅拖慢了页面加载速度，增加了 <code>networkidle</code> 超时的风险，而且对于我的下载任务来说是完全无用的。于是，我决定在导航之前就设置一个请求拦截器，主动屏蔽掉这些不必要的请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 核心代码片段 - 屏蔽不必要的请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>route</span>(<span style=color:#e6db74>&#39;**/*&#39;</span>, (<span style=color:#a6e22e>route</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>request</span>().<span style=color:#a6e22e>url</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;google-analytics.com&#39;</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;doubleclick.net&#39;</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>route</span>.<span style=color:#a6e22e>abort</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>route</span>.<span style=color:#66d9ef>continue</span>();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>这个小小的改动，不仅让页面加载更快，也让我的自动化脚本运行环境更干净、更可预测。这体现了一个工程师从“让它工作”到“让它工作得更好”的思维转变。</p><h2 id=竞态条件>竞态条件<a hidden class=anchor aria-hidden=true href=#竞态条件>#</a></h2><p>解决了导航超时问题后，我再次运行程序。这一次，日志显示页面成功加载，播放按钮也被成功点击。我仿佛听到了胜利的号角。然而，几秒钟后，一个新的、更诡异的错误出现了：<code>Protocol error (Network.getResponseBody): No data found for resource with given identifier</code>。</p><p>程序捕获到了视频分片的响应（<code>response</code> 对象），但在尝试获取其内容（<code>await response.body()</code>）时失败了。错误信息非常底层，直指浏览器开发工具协议（CDP）的层面。</p><p>我花了很多时间来调试和理解这个错误。起初我怀疑是 Playwright 的 Bug，或者是网站有什么特殊的加密。但经过反复试验和查阅资料，我最终锁定了问题的根源——一个经典而棘手的“竞态条件”（Race Condition）。</p><p>我的代码和浏览器内部的媒体处理管线，正在进行一场速度竞赛，而我输了。</p><p>事情的经过是这样的：</p><ol><li>浏览器发起对视频分片的请求。</li><li>服务器返回数据，Playwright 的底层通过 CDP 协议检测到了这个响应，并通知了我的 Node.js 进程。</li><li>Node.js 的事件循环机制将一个 <code>'response'</code> 事件放入事件队列。</li><li>与此同时，浏览器作为一个高度优化的 C++ 程序，并没有等待我的 Node.js 脚本。它的网络堆栈收到视频数据后，可能立即就通过“零拷贝”之类的技术将数据直接送往 GPU 或媒体解码器进行播放。为了极致的性能，它在完成这个操作后，会立刻从内存中清除这份数据，因为它认为这份数据已经“消费”完毕。</li><li>轮到 Node.js 的事件循环处理我的 <code>'response'</code> 事件时，我的 <code>handleResponse</code> 回调函数开始执行。当代码运行到 <code>await response.body()</code> 时，它通过 CDP 协议向浏览器请求：“请把刚才那个响应的数据给我。”</li><li>浏览器回复：“抱歉，你说的那个东西，我早就处理完扔掉了。数据已经不在了。” 于是，<code>No data found for resource</code> 的错误就发生了。</li></ol><p>这个过程中的延迟可能只有几毫秒甚至微秒，但在高性能的浏览器内核面前，这点时间足以让数据消失。我意识到，任何形式的“事后监听”，即在响应发生之后再去尝试获取数据的方案，都存在失败的风险。</p><p>为了战胜这个竞态条件，我需要一种更主动、更具侵入性的方法。我再次求助于 <code>page.route</code>。这次，我不仅仅是用它来 <code>abort()</code> 请求，而是要用它来完全地“代理”视频请求。我的新思路是：</p><ol><li>拦截一个即将发出的视频请求。</li><li><strong>不让浏览器自己去请求</strong>，而是调用 <code>route.fetch()</code>，让 Playwright 的后端代替浏览器去完成这个请求。</li><li>拿到 <code>route.fetch()</code> 返回的 <code>APIResponse</code> 对象后，我可以安全地从中 <code>await response.body()</code>，因为这是我自己的请求，数据被完整地保留了下来。</li><li>获取到数据并存入我的 <code>videoChunks</code> Map 之后，我再调用 <code>route.fulfill({ response })</code>，将我获取到的这个响应“伪造”一份交还给浏览器，让页面上的播放器以为一切正常。</li></ol><p>这个方案理论上是完美的。它把被动的监听变成了主动的代理，从根本上解决了竞态问题。我重构了代码，满怀信心地再次运行。</p><p>程序运行了！我成功地捕获到了第一个、第二个分片的数据！然而，喜悦是短暂的。下载了几个分片（大约 9MB）之后，网络请求戛然而止。程序在等待 20 秒后超时退出，留下一个不完整的文件。</p><p>为什么下载链会中断？我的 <code>route.fulfill()</code> 难道没有成功“欺骗”播放器吗？</p><p>为了找出真相，我为我的拦截器添加了极其详尽的日志，打印每一个被拦截的请求的 URL、方法、类型，以及视频响应的完整头信息。</p><p>日志很快揭示了第一个惊人的发现：播放器在点击播放后，<strong>同时并发地请求了多个不同分辨率的视频流</strong>！例如 <code>720P.mp4</code>, <code>1440P.mp4</code>, <code>2048P.mp4</code>。它似乎是在探测当前网速最适合哪个码率。</p><p>而我的代码存在一个严重的逻辑缺陷：我用一个全局的 <code>activeVideoUrl</code> 变量来锁定我下载的第一个视频流。当 <code>720P.mp4</code> 的请求先到时，我的程序就“认定”了这是要下载的目标，然后无情地忽略了所有后续的 <code>1440P</code> 和 <code>2048P</code> 请求。然而，播放器在短暂的探测后，可能最终决定持续播放的是 <code>2048P</code> 的流。由于我的程序没有正确地 <code>fulfill</code> <code>2048P</code> 的请求（因为它忽略了它们），播放器的状态机被破坏，于是它停止了所有后续的请求。</p><p>我立刻修正了这个逻辑。我不再“先入为主”，而是维护一个所有候选流的列表。下载结束后，我再从中选择一个“最佳”的流进行组装。我最初的“最佳”标准是“分片数量最多”。</p><p>然而，再次运行后，问题依旧。日志显示，所有分辨率的流都只被请求了 2 个分片，然后就都停止了。我的“选择分片数量最多”的策略在这种情况下退化成了“选择第一个”，依然是错误的。</p><p>这时，我才终于触及了问题的本质。不是我的选择逻辑有问题，而是**<code>route.fulfill()</code> 本身就是有问题的**。我用 <code>route.fetch()</code> 获取的 <code>APIResponse</code> 对象，虽然包含了数据，但它终究是一个“克隆品”。当通过 <code>route.fulfill()</code> 交还给浏览器时，它可能丢失了某些对播放器至关重要的底层连接句柄、时序信息或其他元数据。这个“不完美”的响应，虽然能提供最初的几个分片数据，但足以破坏播放器精密的内部状态，导致它无法或不愿请求后续的分片。</p><h2 id=从被动监听到主动控制>从被动监听到主动控制<a hidden class=anchor aria-hidden=true href=#从被动监听到主动控制>#</a></h2><p>在经历了 <code>page.on('response')</code> 的竞态失败和 <code>route.fulfill()</code> 的状态破坏之后，我陷入了沉思。我似乎陷入了一个两难的境地：要么太慢，要么干扰太大。</p><p>就在这时，一个全新的思路在我脑中形成。我之前所有的尝试，都围绕着一个核心思想：<strong>如何从浏览器发起的请求中“窃取”数据</strong>。无论是监听还是代理，我都是一个依附于浏览器行为的“寄生者”。</p><p>为什么不反过来呢？我为什么不能成为下载过程的主导者？</p><p>这个想法彻底改变了我的整个架构。新的、最终的方案诞生了，它分为两个明确的阶段：<strong>侦察</strong>和<strong>接管</strong>。</p><h3 id=侦察>侦察<a hidden class=anchor aria-hidden=true href=#侦察>#</a></h3><p>我依然使用 <code>page.route</code> 拦截网络请求。但这一次，它的目的变得极其单纯：<strong>只看不碰</strong>。当一个视频分片请求被拦截时，我什么也不做，只是立刻调用 <code>route.continue()</code>，让浏览器畅通无阻地进行它自己的网络通信。这保证了播放器状态的绝对纯净和连续。
同时，我在后台悄悄地使用 <code>page.waitForResponse()</code> 等待这个刚刚被我放行的请求完成。当响应到达时，我从中解析出我需要的所有信息：完整的 URL（包含动态生成的 token）、视频总大小、以及分辨率。我将这些信息存入我的 <code>discoveredStreams</code> Map 中。
我设置一个 5-10 秒的侦察窗口。在这段时间里，播放器会像往常一样探测所有分辨率的流。我的侦察器会收集到所有这些流的信息。侦察窗口结束后，我检查 <code>discoveredStreams</code>，选择分辨率最高的那个流。至此，我拥有了下载完整高清视频所需的一切关键情报。</p><h3 id=接管>接管<a hidden class=anchor aria-hidden=true href=#接管>#</a></h3><p>侦察任务完成，我不再关心浏览器后续的网络活动。我启动一个全新的、由我完全控制的下载循环。在这个循环中，我将执行整个方案中最核心、最精妙的操作：在浏览器内部为我工作。</p><p>我使用 <code>page.evaluate()</code> 函数。这个函数可以在浏览器页面的上下文中执行任意的 JavaScript 代码。我在 Node.js 端计算出我需要下载的下一个分片的范围，例如 <code>bytes=0-5242879</code>，然后将这个范围和侦察到的高分辨率 URL 一起作为参数传递给 <code>page.evaluate</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// 核心代码片段 - 在浏览器内发起 fetch 请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>chunkData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>evaluate</span>(<span style=color:#66d9ef>async</span> ({ <span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>range</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>response</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>, { <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> { <span style=color:#e6db74>&#39;Range&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>range</span> } });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>ok</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>`Fetch failed: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>status</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>arrayBuffer</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>data</span>: <span style=color:#66d9ef>Array.from</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#a6e22e>buffer</span>)) };
</span></span><span style=display:flex><span>}, { <span style=color:#a6e22e>url</span>, <span style=color:#a6e22e>range</span> });
</span></span></code></pre></div><p>这段代码的魔力在于，<code>fetch(url, ...)</code> 是在浏览器<strong>内部</strong>执行的。这意味着这个请求：</p><ul><li>自动携带了当前页面的所有 cookies 和 session 信息。</li><li>源自于同一个 IP 地址和浏览器指纹。</li><li>完全通过了网站可能部署的任何 Cloudflare 或其他 JavaScript 人机验证。</li></ul><p>它是一个完美的、合法的、源自于真实用户会话的请求。服务器无法将其与播放器自身的请求区分开来。</p><p><code>fetch</code> 的响应是一个 <code>ArrayBuffer</code>，这是一个无法直接从浏览器传回 Node.js 的对象。因此，我巧妙地将其转换为一个普通的 JavaScript 数字数组 <code>Array.from(new Uint8Array(buffer))</code>，这是一个可以被序列化为 JSON 并跨进程边界传递的数据结构。</p><p>在 Node.js 端，我接收到这个数字数组，再用 <code>Buffer.from(chunkData.data)</code> 将其转换回 Node.js 的 <code>Buffer</code> 对象，然后稳稳地写入文件流。</p><p>我以一个 <code>for</code> 循环重复这个过程，按照我设定的分片大小，从头到尾，顺序地请求整个视频文件，直到下载完所有字节。</p><p>这个方案最终被证明是无懈可击的。它彻底规避了竞态条件，因为它不再被动监听。它也完全避免了干扰播放器状态，因为它让浏览器的归浏览器，下载的归下载。我们只是借用了浏览器的“身份”去发我们自己的请求。</p><h2 id=完善用户体验和健壮性>完善用户体验和健壮性<a hidden class=anchor aria-hidden=true href=#完善用户体验和健壮性>#</a></h2><p>解决了核心的下载难题后，我并没有就此止步。一个优秀的工程师不仅要解决问题，还要交付一个好用的工具。我开始为这个脚本添加一系列专业化的功能。</p><h3 id=支持命令行参数>支持命令行参数<a hidden class=anchor aria-hidden=true href=#支持命令行参数>#</a></h3><p>我移除了硬编码的 <code>TARGET_URL</code>，改为使用 Node.js 的 <code>process.argv</code> 来解析命令行参数。现在，用户可以直接在 <code>npm start</code> 后面跟上任何想下载的视频 URL，极大地提高了工具的灵活性。我还添加了参数检查，如果用户没有提供 URL，程序会打印出用法提示并友好地退出。</p><h3 id=实现丰富的进度显示>实现丰富的进度显示<a hidden class=anchor aria-hidden=true href=#实现丰富的进度显示>#</a></h3><p>一个漫长的下载过程如果没有进度反馈，体验是非常糟糕的。我创建了一个独立的 <code>DownloadTracker</code> 辅助类，专门用于处理下载统计。它在下载开始时记录一个时间戳，每次收到数据块时更新已下载的字节数。
为了避免因频繁更新而刷屏，我使用了一个简单的节流技巧：进度信息最多每秒更新一次。在每次更新时，它会计算：</p><ul><li><strong>平均下载速度（Mbps）</strong>: <code>(总下载字节 * 8) / 经过的秒数 / 1024 / 1024</code></li><li><strong>剩余时间（秒）</strong>: <code>(总大小 - 已下载大小) / 平均速度</code></li><li><strong>预计完成时间（ETA）</strong>: <code>当前时间 + 剩余时间</code>
然后，我将这些信息格式化成一行清晰的、不断刷新的状态栏，例如：
<code>Progress: 25.13% | 216.05MB / 860.00MB | Speed: 123.45 Mbps | ETA: 19:30:45 (55s remaining)</code>
这为用户提供了极佳的实时反馈。</li></ul><h3 id=增加下载重试机制>增加下载重试机制<a hidden class=anchor aria-hidden=true href=#增加下载重试机制>#</a></h3><p>网络是不稳定的。在下载一个大文件的过程中，任何一个分片因为暂时的网络波动而失败，都不应该导致整个任务的中止。我为下载单个分片的逻辑 <code>downloadChunkWithRetries</code> 增加了一个 <code>while</code> 循环实现的重试机制。
如果一次 <code>fetch</code> 失败，它不会立即放弃，而是会进入 <code>catch</code> 块。在这里，我会增加重试计数器，并采用“指数退避”策略计算一个等待时间（例如，第1次重试等2秒，第2次等4秒，第3次等8秒……）。在短暂等待后，它会再次尝试下载<strong>同一个</strong>分片。只有在达到最大重试次数（例如5次）后，程序才会最终放弃并中止整个下载。这个机制极大地增强了程序在不稳定网络环境下的健壮性。</p><h3 id=智能文件名提取>智能文件名提取<a hidden class=anchor aria-hidden=true href=#智能文件名提取>#</a></h3><p>最后：从页面中提取有意义的标题作为文件名。我编写了一个 <code>extractVideoTitle</code> 方法，它会按优先级顺序查找页面中的特定元素（先是 <code>p[lang="ja"]</code>，然后是 <code>h2.mt-16</code>），如果都找不到，则回退到使用 URL 的一部分。我还对提取出的标题进行了清理，移除了所有在文件名中非法的字符。最终，下载的文件被命名为 <code>[视频标题]-[分辨率].mp4</code>，一目了然。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/zh/tags/typescript/>Typescript</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/nodejs/>Nodejs</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/playwright/>Playwright</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/web-scraping/>Web-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/automation/>Automation</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/video-downloader/>Video-Downloader</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/anti-scraping/>Anti-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/race-condition/>Race-Condition</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/network-interception/>Network-Interception</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/browser-automation/>Browser-Automation</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/typescript-video-downloader/>Typescript-Video-Downloader</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/nodejs-playwright-tutorial/>Nodejs-Playwright-Tutorial</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/bypass-anti-scraping/>Bypass-Anti-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/handle-dynamic-content/>Handle-Dynamic-Content</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/playwright-network-interception/>Playwright-Network-Interception</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/browser-automation-scripting/>Browser-Automation-Scripting</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/download-streaming-video/>Download-Streaming-Video</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/race-condition-in-web-scraping/>Race-Condition-in-Web-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/page-evaluate-fetch/>Page-Evaluate-Fetch</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/robust-downloader-nodejs/>Robust-Downloader-Nodejs</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/typescript-project-from-scratch/>Typescript-Project-From-Scratch</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/debugging-playwright/>Debugging-Playwright</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/advanced-web-scraping-techniques/>Advanced-Web-Scraping-Techniques</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/playwright-vs-puppeteer/>Playwright-vs-Puppeteer</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/content-delivery-network-cdn-scraping/>Content-Delivery-Network-Cdn-Scraping</a></li></ul><nav class=paginav><a class=next href=https://tategotoazarasi.github.io/zh/posts/uol-2025-wk3/><span class=title>下一页 »</span><br><span>Uol 2025 Wk3 && LeetCode Biweekly Contest 168 题解</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>