<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享 | Tategoto Azarasi</title>
<meta name=keywords content="wasm,wasmtime,cpp,rust,ffi,shared-memory,bidirectional-communication,host-guest,linear-memory,struct-passing,state-management,wasi,runtime,sandboxing,wasmtime-api,c-plus-plus"><meta name=description content="一篇详细的技术指南，介绍如何使用 Wasmtime 运行时在 C++ 宿主应用程序与 Rust WebAssembly 模块之间实现复杂的双向通信、共享内存访问和结构体传递。"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享"><meta property="og:description" content="一篇详细的技术指南，介绍如何使用 Wasmtime 运行时在 C++ 宿主应用程序与 Rust WebAssembly 模块之间实现复杂的双向通信、共享内存访问和结构体传递。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-06T16:34:33+08:00"><meta property="article:modified_time" content="2025-04-06T16:34:33+08:00"><meta property="article:tag" content="Wasm"><meta property="article:tag" content="Wasmtime"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Ffi"><meta property="article:tag" content="Shared-Memory"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享"><meta name=twitter:description content="一篇详细的技术指南，介绍如何使用 Wasmtime 运行时在 C++ 宿主应用程序与 Rust WebAssembly 模块之间实现复杂的双向通信、共享内存访问和结构体传递。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享","item":"https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享","name":"深入探索 Wasmtime：C\u002b\u002b 与 Rust Wasm 模块的双向通信与内存共享","description":"一篇详细的技术指南，介绍如何使用 Wasmtime 运行时在 C++ 宿主应用程序与 Rust WebAssembly 模块之间实现复杂的双向通信、共享内存访问和结构体传递。","keywords":["wasm","wasmtime","cpp","rust","ffi","shared-memory","bidirectional-communication","host-guest","linear-memory","struct-passing","state-management","wasi","runtime","sandboxing","wasmtime-api","c-plus-plus"],"articleBody":"今天我们来聊一个越来越火热的技术：WebAssembly（简称 Wasm）。不过，我们不把它局限在浏览器里，而是探讨如何在服务器端或者桌面应用中，利用 Wasmtime 这个运行时，让 C++ 程序能够加载和运行 Rust 编译的 Wasm 模块，并且实现它们之间复杂的交互，比如双向函数调用、共享内存、传递结构体，甚至相互修改状态。\nWebAssembly 与 Wasmtime 简介 首先，简单说说 WebAssembly 是什么。你可以把它想象成一种为现代 Web 设计的、可移植的二进制指令格式。它不是用来取代 JavaScript 的，而是作为一种强大的补充，让那些性能敏感或者需要利用底层能力的 C/C++/Rust 等语言编写的代码，也能在 Web 环境（以及其他支持 Wasm 的环境）中以接近本地的速度运行。Wasm 的核心优势在于其沙箱化的安全模型和平台无关的特性。\n而 Wasmtime，则是由 Bytecode Alliance（一个由 Mozilla、Fastly、Intel、Red Hat 等公司组成的联盟）推出的一个独立、高效、安全的 WebAssembly 运行时。它允许你在浏览器之外的环境（比如服务器、命令行工具、嵌入式设备）中运行 Wasm 模块。Wasmtime 提供了 C、C++、Python、Rust、Go 等多种语言的 API，方便我们将 Wasm 集成到现有的应用程序中。\n为什么选择 C++ Host + Rust Wasm？ 这种组合有几个吸引人的地方：很多成熟的项目拥有庞大的 C++ 基础。通过 Wasm，可以在不重写核心逻辑的情况下，将其部分功能模块化、沙箱化，或者提供插件系统。Rust 语言以其内存安全和并发安全著称，非常适合编写需要高度可靠性的 Wasm 模块。在 Wasm 的沙箱之上，Rust 又加了一层保障。 C++ 和 Rust 都是高性能语言，编译成 Wasm 后，借助 Wasmtime 这样的 JIT 运行时，可以获得接近本地代码的执行效率。 Wasm 模块和宿主之间的交互必须通过明确定义的接口（导入/导出），这有助于维持清晰的架构。\n本文的目标就是通过一个具体的例子，展示如何使用 Wasmtime 的 C++ API，搭建一个 C++ 宿主程序，加载一个用 Rust 编写的 Wasm 模块，并实现两者之间各种有趣的互动。\n核心概念：连接 C++ 与 Wasm 的桥梁 在深入代码之前，我们需要理解几个关键概念：\n宿主（Host）与访客（Guest） 在这个场景中，C++ 应用程序是宿主，它负责加载、管理和运行 Wasm 模块。Rust 编译成的 Wasm 模块则是访客，它运行在宿主提供的 Wasmtime 运行时环境中，受到沙箱的限制。\nWasm 的导入（Imports）与导出（Exports） Wasm 模块与外界通信的主要方式就是通过导入和导出。\nWasm 模块可以导出函数、内存、全局变量或表，供宿主或其他 Wasm 模块调用或访问。在 Rust 中，我们通常使用 #[no_mangle] pub extern \"C\" 来标记需要导出的函数。\nWasm 模块可以声明它需要从宿主环境导入哪些功能（通常是函数）。宿主在实例化 Wasm 模块时，必须提供这些导入项的实现。在 Rust 中，我们使用 extern \"C\" { ... } 块配合 #[link(wasm_import_module = \"...\")] 来声明导入。\n这个导入/导出的机制构成了宿主与 Wasm 模块之间的接口契约。\n线性内存（Linear Memory） 每个 Wasm 实例（通常）都有自己的一块线性内存。这是一块连续的、可由 Wasm 代码和宿主代码共同读写的字节数组。Wasm 代码中的指针，实际上就是这块内存区域的偏移量（通常是 32 位或 64 位整数）。\n关键点在于，Wasm 本身是沙箱化的，它不能直接访问宿主的内存。宿主也不能随意访问 Wasm 内部的变量。但是，宿主可以通过 Wasmtime 提供的 API 获取到 Wasm 实例导出的线性内存的访问权（通常是一个指向内存起始位置的指针或 Span），然后直接读写这块内存。同样，Wasm 代码也可以通过调用宿主提供的函数（导入函数），间接地操作宿主的状态或资源。\n这种通过共享线性内存进行数据交换的方式是 Wasm 交互的核心。传递复杂数据结构（如 C++ 的 struct 或 Rust 的 struct）通常就是通过将它们序列化到这块内存中，然后传递指向内存的指针（偏移量）来实现的。\nWASI (WebAssembly System Interface) WASI 是一套标准化的系统接口，旨在让 Wasm 模块能够以安全、可移植的方式与底层操作系统进行交互，比如文件系统访问、网络通信、标准输入输出等。虽然我们的例子不涉及复杂的文件操作，但 Rust 标准库中的 println! 宏依赖于底层的标准输出功能。为了让 Wasm 模块中的 println! 能正常工作（将内容打印到宿主的控制台），我们需要在宿主中配置并链接 WASI 支持。\n构建 C++ 宿主：Wasmtime 的舞台搭建者 现在，我们来看看 C++ 宿主端都需要做些什么。为了更好地组织代码，我们通常会创建一个类（比如 WasmHost）来封装与 Wasmtime 的交互逻辑。\n加载与编译 Wasm 模块 第一步是读取 Wasm 模块文件（.wasm 二进制文件）的内容，然后使用 Wasmtime 的 Engine 来编译它。Engine 可以看作是 Wasmtime 的核心编译和执行引擎，它负责将 Wasm 字节码转换为可执行的机器码。编译的结果是一个 Module 对象。这个 Module 对象是线程安全的，可以被多个 Store 重用。\n// 伪代码示例 (实际代码在 wasm_host.cpp) #include \"wasmtime.hh\" // 包含 Wasmtime C++ 头文件 #include #include #include using namespace wasmtime; // ... WasmHost 类的定义 ... std::vector\u003cuint8_t\u003e WasmHost::readWasmFile() { std::ifstream file(wasm_path_, std::ios::binary | std::ios::ate); // ... 错误处理 ... std::streamsize size = file.tellg(); file.seekg(0, std::ios::beg); std::vector\u003cuint8_t\u003e buffer(static_cast\u003csize_t\u003e(size)); // ... 读取文件内容到 buffer ... return buffer; } void WasmHost::loadAndCompile() { std::vector\u003cuint8_t\u003e wasm_bytes = readWasmFile(); std::cout \u003c\u003c \"[Host Setup] Compiling WASM module...\" \u003c\u003c std::endl; // engine_ 是 WasmHost 的成员变量，类型为 wasmtime::Engine Result\u003cModule\u003e module_res = Module::compile(engine_, wasm_bytes); if (!module_res) { throw std::runtime_error(\"Module compilation failed: \" + module_res.err().message()); } // module_ 也是 WasmHost 的成员变量，类型为 std::optional module_ = std::move(module_res.ok()); std::cout \u003c\u003c \"[Host Setup] Module compiled successfully.\" \u003c\u003c std::endl; } // 在 WasmHost 构造函数或初始化函数中调用 loadAndCompile() Engine 与 Store Engine 负责编译代码，而 Store 则代表了一个 Wasm 实例的“世界”或者说“上下文”。所有与 Wasm 实例相关的数据，比如内存、全局变量、表，以及实例本身，都 属于一个特定的 Store。一个 Engine 可以关联多个 Store，但一个 Store 只与一个 Engine 关联。Store 不是线程安全的，通常一个线程对应一个 Store。\n// WasmHost 类成员变量 Engine engine_; Store store_; // WasmHost 构造函数 WasmHost::WasmHost(std::string wasm_path) : wasm_path_(std::move(wasm_path)), engine_(), // 创建默认 Engine store_(engine_) // 基于 Engine 创建 Store { // ... } 配置 WASI 如前所述，如果 Wasm 模块需要进行系统调用（比如 println!），我们需要为 Store 配置 WASI。这通常在实例化模块之前 完成。Wasmtime 提供了 WasiConfig 类来配置 WASI 的行为，比如是否继承宿主的标准输入/输出/错误流、环境变量、命令行参数等。配置好的 WasiConfig 需要设置到 Store 的上下文中。\n// WasmHost::setupWasi() 方法 void WasmHost::setupWasi() { // ... 检查是否已初始化或已配置 ... std::cout \u003c\u003c \"[Host Setup] Configuring WASI...\" \u003c\u003c std::endl; WasiConfig wasi; wasi.inherit_stdout(); // 让 Wasm 的 stdout 输出到宿主的 stdout wasi.inherit_stderr(); // 同上，stderr // store_ 是 WasmHost 的成员变量 auto wasi_set_res = store_.context().set_wasi(std::move(wasi)); if (!wasi_set_res) { throw std::runtime_error(\"Failed setting WASI config in store: \" + wasi_set_res.err().message()); } wasi_configured_ = true; std::cout \u003c\u003c \"[Host Setup] WASI configured for Store.\" \u003c\u003c std::endl; // 还需要在 Linker 中定义 WASI 导入 linkWasiImports(); } // WasmHost::linkWasiImports() 方法 void WasmHost::linkWasiImports() { // ... 检查 WASI 是否配置 ... std::cout \u003c\u003c \"[Host Setup] Defining WASI imports in linker...\" \u003c\u003c std::endl; // linker_ 是 WasmHost 的成员变量，类型为 wasmtime::Linker auto linker_define_wasi_res = linker_.define_wasi(); if (!linker_define_wasi_res) { throw std::runtime_error(\"Failed defining WASI imports in linker: \" + linker_define_wasi_res.err().message()); } std::cout \u003c\u003c \"[Host Setup] WASI imports defined.\" \u003c\u003c std::endl; } Linker：连接宿主与 Wasm 的桥梁 Linker 是 Wasmtime 中用于解析模块导入并将它们链接到宿主提供的实现的工具。在实例化模块之前，我们需要告诉 Linker 如何满足 Wasm 模块的所有导入需求。\n这包括两个主要部分：\n链接 WASI 导入： 如果我们配置了 WASI，需要调用 linker_.define_wasi()，它会自动将标准的 WASI 函数实现添加到 Linker 中。 链接自定义宿主函数导入： Wasm 模块可能需要调用我们自己定义的宿主函数。我们需要将这些 C++ 函数（或 lambda）包装成 Wasmtime 能理解的形式，并使用 linker_.define() 或 linker_.func_wrap() 将它们注册到 Linker 中，指定它们对应的 Wasm 模块名（在 Rust 代码中 #[link(wasm_import_module = \"...\")] 指定的）和函数名。 定义可被 Wasm 调用的宿主函数 这是实现 Wasm 调用 Host 功能的关键。我们需要在 C++ 中编写实现函数，它们的签名需要与 Rust 中声明的 extern \"C\" 函数相匹配（或者 Wasmtime C++ API 可以通过模板推断进行适配）。\n例如，Rust 中声明了导入：\n// src/ffi.rs #[link(wasm_import_module = \"env\")] // 模块名是 \"env\" unsafe extern \"C\" { fn host_log_value(value: i32); fn host_get_shared_value() -\u003e i32; fn host_set_shared_value(value: i32); } 那么在 C++ 宿主中，我们需要提供这三个函数的实现，并将它们注册到 Linker 中，关联到 “env” 模块。\n// host.cpp #include #include // 宿主状态 int32_t shared_host_value = 42; // C++ 实现函数 void host_log_value_impl_target(int32_t value) { std::cout \u003c\u003c \"[Host Target] host_log_value called by WASM with value: \" \u003c\u003c value \u003c\u003c std::endl; } int32_t host_get_shared_value_impl_target() { std::cout \u003c\u003c \"[Host Target] host_get_shared_value called by WASM. Returning: \" \u003c\u003c shared_host_value \u003c\u003c std::endl; return shared_host_value; } void host_set_shared_value_impl_target(int32_t new_value) { std::cout \u003c\u003c \"[Host Target] host_set_shared_value called by WASM. Old host value: \" \u003c\u003c shared_host_value \u003c\u003c \", New host value: \" \u003c\u003c new_value \u003c\u003c std::endl; shared_host_value = new_value; // 修改宿主状态 } // 在 WasmHost 类或主函数中，使用 Linker 注册这些函数 // (这是 WasmHost 类中的简化版包装函数) template \u003ctypename FuncPtr\u003e void WasmHost::defineHostFunction(std::string_view module_name, std::string_view func_name, FuncPtr func_ptr) { if (is_initialized_) { throw std::logic_error(\"Cannot define host functions after initialization.\"); } std::cout \u003c\u003c \"[Host Setup] Defining host function: \" \u003c\u003c module_name \u003c\u003c \"::\" \u003c\u003c func_name \u003c\u003c \"...\" \u003c\u003c std::endl; // linker_ 是 WasmHost 成员变量 auto result = linker_.func_wrap(module_name, func_name, func_ptr); if (!result) { throw std::runtime_error(\"Failed to define host function '\" + std::string(func_name) + \"': \" + result.err().message()); } } // 在 main 函数中调用 host.defineHostFunction(\"env\", \"host_log_value\", host_log_value_impl_target); host.defineHostFunction(\"env\", \"host_get_shared_value\", host_get_shared_value_impl_target); host.defineHostFunction(\"env\", \"host_set_shared_value\", host_set_shared_value_impl_target); linker_.func_wrap() 是一个方便的模板函数，它可以自动推断 C++ 函数的参数和返回类型，并将其转换为对应的 Wasm 函数类型，然后进行注册。这通常比手动创建 FuncType 并使用 linker_.define() 更简单。\n实例化模块 当所有导入项（WASI 和自定义函数）都在 Linker 中定义好之后，我们就可以使用 linker_.instantiate() 来创建 Wasm 模块的一个实例 (Instance) 了。实例化过程会将 Wasm 代码与宿主提供的实现连接起来，并在 Store 中分配内存、全局变量等资源。\n// WasmHost::instantiateModule() 方法 void WasmHost::instantiateModule() { // ... 检查 module_ 是否有效 ... std::cout \u003c\u003c \"[Host Setup] Instantiating module...\" \u003c\u003c std::endl; // store_ 是 WasmHost 成员变量 TrapResult\u003cInstance\u003e instance_res = linker_.instantiate(store_.context(), module_.value()); if (!instance_res) { // 处理实例化错误（可能是链接错误或 Wasm 启动陷阱） throw std::runtime_error(\"Module instantiation failed: \" + instance_res.err().message()); } // instance_ 是 WasmHost 成员, 类型 std::optional instance_ = std::move(instance_res.ok()); std::cout \u003c\u003c \"[Host Setup] Module instantiated successfully.\" \u003c\u003c std::endl; } 访问 Wasm 线性内存 为了与 Wasm 模块交换复杂数据或直接读写其内存状态，宿主需要获取对 Wasm 实例线性内存的访问权限。Wasm 模块通常会导出一个名为 “memory” 的内存对象。我们可以通过 instance_.get() 来获取它。\n// WasmHost::getMemory() 方法 void WasmHost::getMemory() { // ... 检查 instance_ 是否有效 ... std::cout \u003c\u003c \"[Host Setup] Getting exported memory 'memory'...\" \u003c\u003c std::endl; // store_ 是 WasmHost 成员变量 auto memory_export_opt = instance_.value().get(store_.context(), \"memory\"); if (memory_export_opt \u0026\u0026 std::holds_alternative\u003cMemory\u003e(*memory_export_opt)) { // memory_ 是 WasmHost 成员, 类型 std::optional memory_ = std::get\u003cMemory\u003e(*memory_export_opt); std::cout \u003c\u003c \"[Host Setup] Found exported memory. Size: \" \u003c\u003c memory_.value().data(store_.context()).size() \u003c\u003c \" bytes.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"[Host Setup] Export 'memory' not found or not a memory. Proceeding without memory access.\" \u003c\u003c std::endl; } } // 获取内存的 Span，它提供了对内存区域的视图 Span\u003cuint8_t\u003e WasmHost::getMemorySpan() { if (!is_initialized_ || !memory_.has_value()) { throw std::logic_error(\"Memory not available or host not initialized.\"); } return memory_.value().data(store_.context()); } 获取到的 wasmtime::Memory 对象有一个 data() 方法，它返回一个 wasmtime::Span（如果 C++20 可用，就是 std::span）。这个 Span 提供了对 Wasm 线性内存区域的直接、底层的访问接口（一个指针和大小）。有了这个 Span，我们就可以在宿主端直接读写 Wasm 的内存了。\n构建 Wasm 模块：Rust 的安全地带 现在切换到 Rust 这边，看看 Wasm 模块是如何构建的。\n项目结构 通常我们会将 FFI（Foreign Function Interface）相关的代码放在一个独立的模块（如 src/ffi.rs）中，而将核心的、安全的 Rust 逻辑放在另一个模块（如 src/core.rs 或直接在 src/lib.rs 中定义）。\nsrc/lib.rs 作为库的入口，会声明并导出 ffi 模块中需要暴露给外部（宿主）的接口，并可能包含或调用 core 模块的逻辑。\n// src/lib.rs mod ffi; // 声明 ffi 模块 pub(crate) mod core; // 声明内部的 core 模块 // 重新导出 FFI 层中需要被宿主调用的函数和类型 pub use ffi::{ Point, get_plugin_shared_value_ptr, just_add, point_add, simple_add, trigger_host_calls, }; FFI 层 (src/ffi.rs) 这是 Rust 与外部世界（C++ 宿主）交互的边界。\n声明宿主函数导入： 使用 extern \"C\" 块和 #[link(wasm_import_module = \"env\")] 来告诉 Rust 编译器和 Wasm 运行时，存在一些由名为 “env” 的模块提供的外部函数。这些函数的签名必须与 C++ 宿主提供的实现相匹配。注意 extern \"C\" 块内部通常是 unsafe 的，因为调用外部函数无法保证 Rust 的内存安全规则。\n// src/ffi.rs #[link(wasm_import_module = \"env\")] unsafe extern \"C\" { fn host_log_value(value: i32); fn host_get_shared_value() -\u003e i32; fn host_set_shared_value(value: i32); } 提供安全封装： 为了避免在业务逻辑代码中到处写 unsafe，通常会为导入的 unsafe 函数提供安全的 Rust 包装函数。\n// src/ffi.rs pub fn log_value_from_host(value: i32) { unsafe { host_log_value(value) } // unsafe 调用被封装在内部 } // ... 其他包装函数 ... 导出 Wasm 函数： 使用 #[no_mangle] 防止 Rust 编译器对函数名进行混淆，并使用 pub extern \"C\" 指定 C 语言的调用约定，使得这些函数可以被 C++ 宿主按名称查找和调用。\n// src/ffi.rs #[no_mangle] // 防止名称混淆 pub extern \"C\" fn just_add(left: u64, right: u64) -\u003e u64 { println!(\"[WASM FFI] just_add called...\"); // 使用 WASI 的 println! core::perform_basic_add(left, right) // 调用核心逻辑 } #[no_mangle] pub extern \"C\" fn trigger_host_calls(input_val: i32) { println!(\"[WASM FFI] trigger_host_calls called...\"); core::perform_host_calls_test(input_val); // 调用核心逻辑 } // ... 其他导出函数 ... 核心逻辑层 (src/core.rs) 这里是实现 Wasm 模块具体功能的地方，应该尽量使用安全的 Rust 代码。它会调用 FFI 层提供的安全包装函数来与宿主交互。\n// src/lib.rs (core 模块) pub(crate) mod core { use crate::ffi::{ // 导入 FFI 层的安全包装器 Point, get_shared_value_from_host, log_value_from_host, set_shared_value_in_host, // ... }; pub fn perform_basic_add(left: u64, right: u64) -\u003e u64 { println!(\"[WASM Core] perform_basic_add: {} + {}\", left, right); left.wrapping_add(right) // 安全的加法 } pub fn perform_host_calls_test(input_val: i32) { println!(\"[WASM Core] perform_host_calls_test with input: {}\", input_val); // 调用宿主函数 (通过安全包装器) log_value_from_host(input_val * 2); let host_val = get_shared_value_from_host(); set_shared_value_in_host(host_val + input_val + 5); // ... } // ... 其他核心逻辑函数 ... } 定义共享数据结构 如果需要在 C++ 和 Rust 之间传递复杂的数据结构，必须确保两者对该结构的内存布局有相同的理解。在 Rust 中，使用 #[repr(C)] 属性可以强制结构体使用 C 语言兼容的内存布局。在 C++ 中，虽然编译器通常会按顺序布局，但为了绝对保险，可以使用 #pragma pack(push, 1) 和 #pragma pack(pop) 来确保紧凑（无填充）的布局，或者确保两边的对齐方式一致。\n// src/ffi.rs #[repr(C)] // 关键：保证 C 兼容布局 #[derive(Debug, Copy, Clone, Default)] pub struct Point { pub x: i32, pub y: i32, } // host.cpp #pragma pack(push, 1) // 建议：确保与 Rust 端一致的紧凑布局 struct Point { int32_t x; int32_t y; }; #pragma pack(pop) 管理 Wasm 内部状态 Wasm 模块有时也需要维护自己的状态。一种方法是使用 Rust 的 static mut 变量。但是，访问 static mut 需要 unsafe 块，因为它可能引入数据竞争（虽然在单线程 Wasm 环境中风险较小，但 Rust 依然要求 unsafe）。\n// src/ffi.rs static mut PLUGIN_SHARED_VALUE: i32 = 100; // Wasm 模块内部状态 // FFI 内部帮助函数，用于安全地读取（仍然需要 unsafe 块） pub(crate) fn read_plugin_value_internal() -\u003e i32 { unsafe { PLUGIN_SHARED_VALUE } } // 在 core 模块中使用 // use crate::ffi::read_plugin_value_internal; // let val = read_plugin_value_internal(); 如果需要让宿主能够直接修改这个状态，可以导出一个函数，返回该 static mut 变量的指针（内存偏移量）。\n// src/ffi.rs #[no_mangle] pub unsafe extern \"C\" fn get_plugin_shared_value_ptr() -\u003e *mut i32 { // 注意：这里需要 `unsafe` fn 并且内部还需要 `unsafe` 块 // 使用 `\u0026raw mut` (较新 Rust 语法) 或直接转换来获取原始指针 // let ptr = unsafe { \u0026mut PLUGIN_SHARED_VALUE as *mut i32 }; let ptr = { \u0026raw mut PLUGIN_SHARED_VALUE as *mut i32 }; // 使用 \u0026raw mut 避免 Miri 抱怨 println!(\"[WASM FFI] get_plugin_shared_value_ptr() -\u003e {:?}\", ptr); ptr } 警告： 直接向宿主暴露内部可变状态的指针是一种非常危险的做法！这打破了 Wasm 的封装性，宿主可以直接修改 Wasm 内部的数据，可能导致意想不到的后果或破坏 Wasm 内部的不变性。在实际应用中应极力避免这种模式，除非有非常明确和受控的理由。更好的方式是通过导出的函数来间接、安全地修改内部状态。这里展示它主要是为了演示内存操作的可能性。\n交互模式详解 现在我们结合 C++ 宿主和 Rust Wasm 模块的代码，来看看具体的交互流程是如何实现的。\n模式一：宿主调用简单 Wasm 函数 (just_add) 这是最基本的交互。宿主需要调用 Wasm 模块导出的一个纯计算函数。\nC++ 宿主端 (host.cpp):\n获取函数： 通过 WasmHost 封装的方法（内部调用 instance_.get() 和 func.typed()）获取类型安全的 Wasm 函数代理 TypedFunc。 准备参数： 将 C++ 的 uint64_t 参数包装在 std::tuple 中。 调用： 使用 typed_func.call() 方法调用 Wasm 函数。Wasmtime C++ API 会处理参数和返回值的传递。 处理结果： 从返回的 Result 中获取结果 std::tuple，并提取出 uint64_t 的返回值。 // host.cpp (main 函数内, Test 1) uint64_t arg1 = 15, arg2 = 27; auto args = std::make_tuple(arg1, arg2); std::cout \u003c\u003c \"[Host Main] Calling Wasm function 'just_add(\" \u003c\u003c arg1 \u003c\u003c \", \" \u003c\u003c arg2 \u003c\u003c \")'...\" \u003c\u003c std::endl; // host 是 WasmHost 实例 // 类型推导：返回值是 tuple, 参数是 tuple auto result_tuple = host.callFunction\u003cstd::tuple\u003cuint64_t\u003e, std::tuple\u003cuint64_t, uint64_t\u003e\u003e( \"just_add\", args); // result_tuple 是 Result","wordCount":"3053","inLanguage":"zh","datePublished":"2025-04-06T16:34:33+08:00","dateModified":"2025-04-06T16:34:33+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入探索 Wasmtime：C++ 与 Rust Wasm 模块的双向通信与内存共享</h1><div class=post-meta><span title='2025-04-06 16:34:33 +0800 +0800'>四月 6, 2025</span>&nbsp;·&nbsp;15 分钟&nbsp;·&nbsp;3053 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/en/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#webassembly-与-wasmtime-简介>WebAssembly 与 Wasmtime 简介</a></li><li><a href=#为什么选择-c-host--rust-wasm>为什么选择 C++ Host + Rust Wasm？</a></li><li><a href=#核心概念连接-c-与-wasm-的桥梁>核心概念：连接 C++ 与 Wasm 的桥梁</a><ol><li><a href=#宿主host与访客guest>宿主（Host）与访客（Guest）</a></li><li><a href=#wasm-的导入imports与导出exports>Wasm 的导入（Imports）与导出（Exports）</a></li><li><a href=#线性内存linear-memory>线性内存（Linear Memory）</a></li><li><a href=#wasi-webassembly-system-interface>WASI (WebAssembly System Interface)</a></li></ol></li><li><a href=#构建-c-宿主wasmtime-的舞台搭建者>构建 C++ 宿主：Wasmtime 的舞台搭建者</a><ol><li><a href=#加载与编译-wasm-模块>加载与编译 Wasm 模块</a></li><li><a href=#engine-与-store>Engine 与 Store</a></li><li><a href=#配置-wasi>配置 WASI</a></li><li><a href=#linker连接宿主与-wasm-的桥梁>Linker：连接宿主与 Wasm 的桥梁</a></li><li><a href=#定义可被-wasm-调用的宿主函数>定义可被 Wasm 调用的宿主函数</a></li><li><a href=#实例化模块>实例化模块</a></li><li><a href=#访问-wasm-线性内存>访问 Wasm 线性内存</a></li></ol></li><li><a href=#构建-wasm-模块rust-的安全地带>构建 Wasm 模块：Rust 的安全地带</a><ol><li><a href=#项目结构>项目结构</a></li><li><a href=#ffi-层-srcffirs>FFI 层 (<code>src/ffi.rs</code>)</a></li><li><a href=#核心逻辑层-srccorers>核心逻辑层 (<code>src/core.rs</code>)</a></li><li><a href=#定义共享数据结构>定义共享数据结构</a></li><li><a href=#管理-wasm-内部状态>管理 Wasm 内部状态</a></li></ol></li><li><a href=#交互模式详解>交互模式详解</a><ol><li><a href=#模式一宿主调用简单-wasm-函数-just_add>模式一：宿主调用简单 Wasm 函数 (<code>just_add</code>)</a></li><li><a href=#模式二wasm-调用宿主函数-trigger_host_calls>模式二：Wasm 调用宿主函数 (<code>trigger_host_calls</code>)</a></li><li><a href=#模式三通过内存共享结构体-point_add>模式三：通过内存共享结构体 (<code>point_add</code>)</a></li><li><a href=#模式四宿主直接读写-wasm-内部状态>模式四：宿主直接读写 Wasm 内部状态</a></li><li><a href=#模式五wasm-验证内部状态被宿主修改>模式五：Wasm 验证内部状态被宿主修改</a></li></ol></li><li><a href=#关键要点与思考>关键要点与思考</a></li><li><a href=#结语>结语</a></li></ol></nav></div></details></div><div class=post-content><p>今天我们来聊一个越来越火热的技术：WebAssembly（简称 Wasm）。不过，我们不把它局限在浏览器里，而是探讨如何在服务器端或者桌面应用中，利用
Wasmtime 这个运行时，让 C++ 程序能够加载和运行 Rust 编译的 Wasm 模块，并且实现它们之间复杂的交互，比如双向函数调用、共享内存、传递结构体，甚至相互修改状态。</p><h2 id=webassembly-与-wasmtime-简介>WebAssembly 与 Wasmtime 简介<a hidden class=anchor aria-hidden=true href=#webassembly-与-wasmtime-简介>#</a></h2><p>首先，简单说说 WebAssembly 是什么。你可以把它想象成一种为现代 Web 设计的、可移植的二进制指令格式。它不是用来取代 JavaScript
的，而是作为一种强大的补充，让那些性能敏感或者需要利用底层能力的 C/C++/Rust 等语言编写的代码，也能在 Web 环境（以及其他支持
Wasm 的环境）中以接近本地的速度运行。Wasm 的核心优势在于其<strong>沙箱化</strong>的安全模型和<strong>平台无关</strong>的特性。</p><p>而 Wasmtime，则是由 Bytecode Alliance（一个由 Mozilla、Fastly、Intel、Red Hat 等公司组成的联盟）推出的一个<strong>独立、高效、安全</strong>的
WebAssembly 运行时。它允许你在浏览器之外的环境（比如服务器、命令行工具、嵌入式设备）中运行 Wasm 模块。Wasmtime 提供了
C、C++、Python、Rust、Go 等多种语言的 API，方便我们将 Wasm 集成到现有的应用程序中。</p><h2 id=为什么选择-c-host--rust-wasm>为什么选择 C++ Host + Rust Wasm？<a hidden class=anchor aria-hidden=true href=#为什么选择-c-host--rust-wasm>#</a></h2><p>这种组合有几个吸引人的地方：很多成熟的项目拥有庞大的 C++ 基础。通过 Wasm，可以在不重写核心逻辑的情况下，将其部分功能模块化、沙箱化，或者提供插件系统。Rust
语言以其内存安全和并发安全著称，非常适合编写需要高度可靠性的 Wasm 模块。在 Wasm 的沙箱之上，Rust 又加了一层保障。 C++ 和
Rust 都是高性能语言，编译成 Wasm 后，借助 Wasmtime 这样的 JIT 运行时，可以获得接近本地代码的执行效率。 Wasm
模块和宿主之间的交互必须通过明确定义的接口（导入/导出），这有助于维持清晰的架构。</p><p>本文的目标就是通过一个具体的例子，展示如何使用 Wasmtime 的 C++ API，搭建一个 C++ 宿主程序，加载一个用 Rust 编写的 Wasm
模块，并实现两者之间各种有趣的互动。</p><h2 id=核心概念连接-c-与-wasm-的桥梁>核心概念：连接 C++ 与 Wasm 的桥梁<a hidden class=anchor aria-hidden=true href=#核心概念连接-c-与-wasm-的桥梁>#</a></h2><p>在深入代码之前，我们需要理解几个关键概念：</p><h3 id=宿主host与访客guest>宿主（Host）与访客（Guest）<a hidden class=anchor aria-hidden=true href=#宿主host与访客guest>#</a></h3><p>在这个场景中，C++ 应用程序是<strong>宿主</strong>，它负责加载、管理和运行 Wasm 模块。Rust 编译成的 Wasm 模块则是<strong>访客</strong>，它运行在宿主提供的
Wasmtime 运行时环境中，受到沙箱的限制。</p><h3 id=wasm-的导入imports与导出exports>Wasm 的导入（Imports）与导出（Exports）<a hidden class=anchor aria-hidden=true href=#wasm-的导入imports与导出exports>#</a></h3><p>Wasm 模块与外界通信的主要方式就是通过导入和导出。</p><p>Wasm 模块可以<strong>导出</strong>函数、内存、全局变量或表，供宿主或其他 Wasm 模块调用或访问。在 Rust 中，我们通常使用
<code>#[no_mangle] pub extern "C"</code> 来标记需要导出的函数。</p><p>Wasm 模块可以声明它需要从宿主环境<strong>导入</strong>哪些功能（通常是函数）。宿主在实例化 Wasm 模块时，必须提供这些导入项的实现。在 Rust
中，我们使用 <code>extern "C" { ... }</code> 块配合 <code>#[link(wasm_import_module = "...")]</code> 来声明导入。</p><p>这个导入/导出的机制构成了宿主与 Wasm 模块之间的接口契约。</p><h3 id=线性内存linear-memory>线性内存（Linear Memory）<a hidden class=anchor aria-hidden=true href=#线性内存linear-memory>#</a></h3><p>每个 Wasm 实例（通常）都有自己的一块<strong>线性内存</strong>。这是一块连续的、可由 Wasm 代码和宿主代码共同读写的字节数组。Wasm
代码中的指针，实际上就是这块内存区域的<strong>偏移量</strong>（通常是 32 位或 64 位整数）。</p><p>关键点在于，Wasm 本身是沙箱化的，它不能直接访问宿主的内存。宿主也不能随意访问 Wasm 内部的变量。但是，宿主可以通过 Wasmtime
提供的 API 获取到 Wasm 实例导出的线性内存的<strong>访问权</strong>（通常是一个指向内存起始位置的指针或 Span），然后直接读写这块内存。同样，Wasm
代码也可以通过调用宿主提供的函数（导入函数），间接地操作宿主的状态或资源。</p><p>这种通过共享线性内存进行数据交换的方式是 Wasm 交互的核心。传递复杂数据结构（如 C++ 的 struct 或 Rust 的
struct）通常就是通过将它们序列化到这块内存中，然后传递指向内存的指针（偏移量）来实现的。</p><h3 id=wasi-webassembly-system-interface>WASI (WebAssembly System Interface)<a hidden class=anchor aria-hidden=true href=#wasi-webassembly-system-interface>#</a></h3><p>WASI 是一套标准化的系统接口，旨在让 Wasm 模块能够以安全、可移植的方式与底层操作系统进行交互，比如文件系统访问、网络通信、标准输入输出等。虽然我们的例子不涉及复杂的文件操作，但
Rust 标准库中的 <code>println!</code> 宏依赖于底层的标准输出功能。为了让 Wasm 模块中的 <code>println!</code> 能正常工作（将内容打印到宿主的控制台），我们需要在宿主中配置并链接
WASI 支持。</p><h2 id=构建-c-宿主wasmtime-的舞台搭建者>构建 C++ 宿主：Wasmtime 的舞台搭建者<a hidden class=anchor aria-hidden=true href=#构建-c-宿主wasmtime-的舞台搭建者>#</a></h2><p>现在，我们来看看 C++ 宿主端都需要做些什么。为了更好地组织代码，我们通常会创建一个类（比如 <code>WasmHost</code>）来封装与 Wasmtime
的交互逻辑。</p><h3 id=加载与编译-wasm-模块>加载与编译 Wasm 模块<a hidden class=anchor aria-hidden=true href=#加载与编译-wasm-模块>#</a></h3><p>第一步是读取 Wasm 模块文件（<code>.wasm</code> 二进制文件）的内容，然后使用 Wasmtime 的 <code>Engine</code> 来编译它。<code>Engine</code> 可以看作是 Wasmtime
的核心编译和执行引擎，它负责将 Wasm 字节码转换为可执行的机器码。编译的结果是一个 <code>Module</code> 对象。这个 <code>Module</code>
对象是线程安全的，可以被多个 <code>Store</code> 重用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 伪代码示例 (实际代码在 wasm_host.cpp)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;wasmtime.hh&#34;</span><span style=color:#75715e> </span><span style=color:#75715e>// 包含 Wasmtime C++ 头文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdexcept&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> wasmtime;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ... WasmHost 类的定义 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> WasmHost<span style=color:#f92672>::</span>readWasmFile() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ifstream file(wasm_path_, std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>binary <span style=color:#f92672>|</span> std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>ate);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 错误处理 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>streamsize size <span style=color:#f92672>=</span> file.tellg();
</span></span><span style=display:flex><span>    file.seekg(<span style=color:#ae81ff>0</span>, std<span style=color:#f92672>::</span>ios<span style=color:#f92672>::</span>beg);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> buffer(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(size));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 读取文件内容到 buffer ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> buffer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>loadAndCompile() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> wasm_bytes <span style=color:#f92672>=</span> readWasmFile();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Compiling WASM module...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// engine_ 是 WasmHost 的成员变量，类型为 wasmtime::Engine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Result<span style=color:#f92672>&lt;</span>Module<span style=color:#f92672>&gt;</span> module_res <span style=color:#f92672>=</span> Module<span style=color:#f92672>::</span>compile(engine_, wasm_bytes);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>module_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Module compilation failed: &#34;</span> <span style=color:#f92672>+</span> module_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// module_ 也是 WasmHost 的成员变量，类型为 std::optional&lt;wasmtime::Module&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    module_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(module_res.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Module compiled successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 WasmHost 构造函数或初始化函数中调用 loadAndCompile()
</span></span></span></code></pre></div><h3 id=engine-与-store>Engine 与 Store<a hidden class=anchor aria-hidden=true href=#engine-与-store>#</a></h3><p><code>Engine</code> 负责编译代码，而 <code>Store</code> 则代表了一个 Wasm 实例的“世界”或者说“上下文”。所有与 Wasm 实例相关的数据，比如内存、全局变量、表，以及实例本身，都
<strong>属于</strong>一个特定的 <code>Store</code>。一个 <code>Engine</code> 可以关联多个 <code>Store</code>，但一个 <code>Store</code> 只与一个 <code>Engine</code> 关联。<code>Store</code>
不是线程安全的，通常一个线程对应一个 <code>Store</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost 类成员变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Engine engine_;
</span></span><span style=display:flex><span>Store store_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost 构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>WasmHost<span style=color:#f92672>::</span>WasmHost(std<span style=color:#f92672>::</span>string wasm_path) <span style=color:#f92672>:</span> wasm_path_(std<span style=color:#f92672>::</span>move(wasm_path)),
</span></span><span style=display:flex><span>                                            engine_(), <span style=color:#75715e>// 创建默认 Engine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                            store_(engine_) <span style=color:#75715e>// 基于 Engine 创建 Store
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=配置-wasi>配置 WASI<a hidden class=anchor aria-hidden=true href=#配置-wasi>#</a></h3><p>如前所述，如果 Wasm 模块需要进行系统调用（比如 <code>println!</code>），我们需要为 <code>Store</code> 配置 WASI。这通常在实例化模块<strong>之前</strong>
完成。Wasmtime 提供了 <code>WasiConfig</code> 类来配置 WASI 的行为，比如是否继承宿主的标准输入/输出/错误流、环境变量、命令行参数等。配置好的
<code>WasiConfig</code> 需要设置到 <code>Store</code> 的上下文中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::setupWasi() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>setupWasi() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 检查是否已初始化或已配置 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Configuring WASI...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    WasiConfig wasi;
</span></span><span style=display:flex><span>    wasi.inherit_stdout(); <span style=color:#75715e>// 让 Wasm 的 stdout 输出到宿主的 stdout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wasi.inherit_stderr(); <span style=color:#75715e>// 同上，stderr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// store_ 是 WasmHost 的成员变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> wasi_set_res <span style=color:#f92672>=</span> store_.context().set_wasi(std<span style=color:#f92672>::</span>move(wasi));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>wasi_set_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed setting WASI config in store: &#34;</span> <span style=color:#f92672>+</span> wasi_set_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    wasi_configured_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] WASI configured for Store.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 还需要在 Linker 中定义 WASI 导入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    linkWasiImports();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost::linkWasiImports() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>linkWasiImports() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 检查 WASI 是否配置 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Defining WASI imports in linker...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linker_ 是 WasmHost 的成员变量，类型为 wasmtime::Linker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> linker_define_wasi_res <span style=color:#f92672>=</span> linker_.define_wasi();
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>linker_define_wasi_res) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed defining WASI imports in linker: &#34;</span> <span style=color:#f92672>+</span> linker_define_wasi_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] WASI imports defined.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=linker连接宿主与-wasm-的桥梁>Linker：连接宿主与 Wasm 的桥梁<a hidden class=anchor aria-hidden=true href=#linker连接宿主与-wasm-的桥梁>#</a></h3><p><code>Linker</code> 是 Wasmtime 中用于解析模块导入并将它们链接到宿主提供的实现的工具。在实例化模块之前，我们需要告诉 <code>Linker</code> 如何满足
Wasm 模块的所有导入需求。</p><p>这包括两个主要部分：</p><ol><li><strong>链接 WASI 导入：</strong> 如果我们配置了 WASI，需要调用 <code>linker_.define_wasi()</code>，它会自动将标准的 WASI 函数实现添加到
<code>Linker</code> 中。</li><li><strong>链接自定义宿主函数导入：</strong> Wasm 模块可能需要调用我们自己定义的宿主函数。我们需要将这些 C++ 函数（或 lambda）包装成
Wasmtime 能理解的形式，并使用 <code>linker_.define()</code> 或 <code>linker_.func_wrap()</code> 将它们注册到 <code>Linker</code> 中，指定它们对应的 Wasm
模块名（在 Rust 代码中 <code>#[link(wasm_import_module = "...")]</code> 指定的）和函数名。</li></ol><h3 id=定义可被-wasm-调用的宿主函数>定义可被 Wasm 调用的宿主函数<a hidden class=anchor aria-hidden=true href=#定义可被-wasm-调用的宿主函数>#</a></h3><p>这是实现 Wasm 调用 Host 功能的关键。我们需要在 C++ 中编写实现函数，它们的签名需要与 Rust 中声明的 <code>extern "C"</code> 函数相匹配（或者
Wasmtime C++ API 可以通过模板推断进行适配）。</p><p>例如，Rust 中声明了导入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[link(wasm_import_module = </span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#75715e>)]</span> <span style=color:#75715e>// 模块名是 &#34;env&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_log_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_get_shared_value</span>() -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_set_shared_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么在 C++ 宿主中，我们需要提供这三个函数的实现，并将它们注册到 <code>Linker</code> 中，关联到 &ldquo;env&rdquo; 模块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 宿主状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> shared_host_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// C++ 实现函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>host_log_value_impl_target</span>(<span style=color:#66d9ef>int32_t</span> value) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_log_value called by WASM with value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int32_t</span> <span style=color:#a6e22e>host_get_shared_value_impl_target</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_get_shared_value called by WASM. Returning: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> shared_host_value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> shared_host_value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>host_set_shared_value_impl_target</span>(<span style=color:#66d9ef>int32_t</span> new_value) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Target] host_set_shared_value called by WASM. Old host value: &#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>&lt;&lt;</span> shared_host_value <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, New host value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> new_value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    shared_host_value <span style=color:#f92672>=</span> new_value; <span style=color:#75715e>// 修改宿主状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 WasmHost 类或主函数中，使用 Linker 注册这些函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// (这是 WasmHost 类中的简化版包装函数)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> FuncPtr<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>defineHostFunction(std<span style=color:#f92672>::</span>string_view module_name, std<span style=color:#f92672>::</span>string_view func_name, FuncPtr func_ptr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (is_initialized_) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>logic_error(<span style=color:#e6db74>&#34;Cannot define host functions after initialization.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Defining host function: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> module_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;::&#34;</span> <span style=color:#f92672>&lt;&lt;</span> func_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linker_ 是 WasmHost 成员变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> result <span style=color:#f92672>=</span> linker_.func_wrap(module_name, func_name, func_ptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Failed to define host function &#39;&#34;</span> <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>string(func_name) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;: &#34;</span> <span style=color:#f92672>+</span> result.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 main 函数中调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_log_value&#34;</span>, host_log_value_impl_target);
</span></span><span style=display:flex><span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_get_shared_value&#34;</span>, host_get_shared_value_impl_target);
</span></span><span style=display:flex><span>host.defineHostFunction(<span style=color:#e6db74>&#34;env&#34;</span>, <span style=color:#e6db74>&#34;host_set_shared_value&#34;</span>, host_set_shared_value_impl_target);
</span></span></code></pre></div><p><code>linker_.func_wrap()</code> 是一个方便的模板函数，它可以自动推断 C++ 函数的参数和返回类型，并将其转换为对应的 Wasm
函数类型，然后进行注册。这通常比手动创建 <code>FuncType</code> 并使用 <code>linker_.define()</code> 更简单。</p><h3 id=实例化模块>实例化模块<a hidden class=anchor aria-hidden=true href=#实例化模块>#</a></h3><p>当所有导入项（WASI 和自定义函数）都在 <code>Linker</code> 中定义好之后，我们就可以使用 <code>linker_.instantiate()</code> 来创建 Wasm
模块的一个实例 (<code>Instance</code>) 了。实例化过程会将 Wasm 代码与宿主提供的实现连接起来，并在 <code>Store</code> 中分配内存、全局变量等资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::instantiateModule() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>instantiateModule() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 检查 module_ 是否有效 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Instantiating module...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store_ 是 WasmHost 成员变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TrapResult<span style=color:#f92672>&lt;</span>Instance<span style=color:#f92672>&gt;</span> instance_res <span style=color:#f92672>=</span> linker_.instantiate(store_.context(), module_.value());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>instance_res) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 处理实例化错误（可能是链接错误或 Wasm 启动陷阱）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Module instantiation failed: &#34;</span> <span style=color:#f92672>+</span> instance_res.err().message());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// instance_ 是 WasmHost 成员, 类型 std::optional&lt;wasmtime::Instance&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    instance_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(instance_res.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Module instantiated successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=访问-wasm-线性内存>访问 Wasm 线性内存<a hidden class=anchor aria-hidden=true href=#访问-wasm-线性内存>#</a></h3><p>为了与 Wasm 模块交换复杂数据或直接读写其内存状态，宿主需要获取对 Wasm 实例线性内存的访问权限。Wasm
模块通常会导出一个名为 &ldquo;memory&rdquo; 的内存对象。我们可以通过 <code>instance_.get()</code> 来获取它。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// WasmHost::getMemory() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>getMemory() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 检查 instance_ 是否有效 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Getting exported memory &#39;memory&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store_ 是 WasmHost 成员变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> memory_export_opt <span style=color:#f92672>=</span> instance_.value().get(store_.context(), <span style=color:#e6db74>&#34;memory&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (memory_export_opt <span style=color:#f92672>&amp;&amp;</span> std<span style=color:#f92672>::</span>holds_alternative<span style=color:#f92672>&lt;</span>Memory<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span>memory_export_opt)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// memory_ 是 WasmHost 成员, 类型 std::optional&lt;wasmtime::Memory&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        memory_ <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span>Memory<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span>memory_export_opt);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Found exported memory. Size: &#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> memory_.value().data(store_.context()).size() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; bytes.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Setup] Export &#39;memory&#39; not found or not a memory. Proceeding without memory access.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取内存的 Span&lt;uint8_t&gt;，它提供了对内存区域的视图
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Span<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> WasmHost<span style=color:#f92672>::</span>getMemorySpan() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>is_initialized_ <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>memory_.has_value()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>logic_error(<span style=color:#e6db74>&#34;Memory not available or host not initialized.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memory_.value().data(store_.context());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>获取到的 <code>wasmtime::Memory</code> 对象有一个 <code>data()</code> 方法，它返回一个 <code>wasmtime::Span&lt;uint8_t></code>（如果 C++20 可用，就是
<code>std::span&lt;uint8_t></code>）。这个 Span 提供了对 Wasm 线性内存区域的直接、底层的访问接口（一个指针和大小）。有了这个
Span，我们就可以在宿主端直接读写 Wasm 的内存了。</p><h2 id=构建-wasm-模块rust-的安全地带>构建 Wasm 模块：Rust 的安全地带<a hidden class=anchor aria-hidden=true href=#构建-wasm-模块rust-的安全地带>#</a></h2><p>现在切换到 Rust 这边，看看 Wasm 模块是如何构建的。</p><h3 id=项目结构>项目结构<a hidden class=anchor aria-hidden=true href=#项目结构>#</a></h3><p>通常我们会将 FFI（Foreign Function Interface）相关的代码放在一个独立的模块（如 <code>src/ffi.rs</code>）中，而将核心的、安全的 Rust
逻辑放在另一个模块（如 <code>src/core.rs</code> 或直接在 <code>src/lib.rs</code> 中定义）。</p><p><code>src/lib.rs</code> 作为库的入口，会声明并导出 <code>ffi</code> 模块中需要暴露给外部（宿主）的接口，并可能包含或调用 <code>core</code> 模块的逻辑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>mod</span> ffi; <span style=color:#75715e>// 声明 ffi 模块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>mod</span> core; <span style=color:#75715e>// 声明内部的 core 模块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 重新导出 FFI 层中需要被宿主调用的函数和类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>use</span> ffi::{
</span></span><span style=display:flex><span>    Point, get_plugin_shared_value_ptr, just_add, point_add, simple_add, trigger_host_calls,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=ffi-层-srcffirs>FFI 层 (<code>src/ffi.rs</code>)<a hidden class=anchor aria-hidden=true href=#ffi-层-srcffirs>#</a></h3><p>这是 Rust 与外部世界（C++ 宿主）交互的边界。</p><ol><li><p><strong>声明宿主函数导入：</strong> 使用 <code>extern "C"</code> 块和 <code>#[link(wasm_import_module = "env")]</code> 来告诉 Rust 编译器和 Wasm
运行时，存在一些由名为 &ldquo;env&rdquo; 的模块提供的外部函数。这些函数的签名必须与 C++ 宿主提供的实现相匹配。注意 <code>extern "C"</code>
块内部通常是 <code>unsafe</code> 的，因为调用外部函数无法保证 Rust 的内存安全规则。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[link(wasm_import_module = </span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_log_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_get_shared_value</span>() -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>host_set_shared_value</span>(value: <span style=color:#66d9ef>i32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>提供安全封装：</strong> 为了避免在业务逻辑代码中到处写 <code>unsafe</code>，通常会为导入的 <code>unsafe</code> 函数提供安全的 Rust 包装函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log_value_from_host</span>(value: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { host_log_value(value) } <span style=color:#75715e>// unsafe 调用被封装在内部
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ... 其他包装函数 ...
</span></span></span></code></pre></div></li><li><p><strong>导出 Wasm 函数：</strong> 使用 <code>#[no_mangle]</code> 防止 Rust 编译器对函数名进行混淆，并使用 <code>pub extern "C"</code> 指定 C
语言的调用约定，使得这些函数可以被 C++ 宿主按名称查找和调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span> <span style=color:#75715e>// 防止名称混淆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>just_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add called...&#34;</span>); <span style=color:#75715e>// 使用 WASI 的 println!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    core::perform_basic_add(left, right) <span style=color:#75715e>// 调用核心逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>trigger_host_calls</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls called...&#34;</span>);
</span></span><span style=display:flex><span>    core::perform_host_calls_test(input_val); <span style=color:#75715e>// 调用核心逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ... 其他导出函数 ...
</span></span></span></code></pre></div></li></ol><h3 id=核心逻辑层-srccorers>核心逻辑层 (<code>src/core.rs</code>)<a hidden class=anchor aria-hidden=true href=#核心逻辑层-srccorers>#</a></h3><p>这里是实现 Wasm 模块具体功能的地方，应该尽量使用安全的 Rust 代码。它会调用 FFI 层提供的安全包装函数来与宿主交互。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs (core 模块)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>mod</span> core {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::ffi::{ <span style=color:#75715e>// 导入 FFI 层的安全包装器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point,
</span></span><span style=display:flex><span>        get_shared_value_from_host,
</span></span><span style=display:flex><span>        log_value_from_host,
</span></span><span style=display:flex><span>        set_shared_value_in_host,
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_basic_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM Core] perform_basic_add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>        left.wrapping_add(right) <span style=color:#75715e>// 安全的加法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_host_calls_test</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM Core] perform_host_calls_test with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用宿主函数 (通过安全包装器)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        log_value_from_host(input_val <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> host_val <span style=color:#f92672>=</span> get_shared_value_from_host();
</span></span><span style=display:flex><span>        set_shared_value_in_host(host_val <span style=color:#f92672>+</span> input_val <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 其他核心逻辑函数 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=定义共享数据结构>定义共享数据结构<a hidden class=anchor aria-hidden=true href=#定义共享数据结构>#</a></h3><p>如果需要在 C++ 和 Rust 之间传递复杂的数据结构，必须确保两者对该结构的内存布局有相同的理解。在 Rust 中，使用 <code>#[repr(C)]</code>
属性可以强制结构体使用 C 语言兼容的内存布局。在 C++ 中，虽然编译器通常会按顺序布局，但为了绝对保险，可以使用
<code>#pragma pack(push, 1)</code> 和 <code>#pragma pack(pop)</code> 来确保紧凑（无填充）的布局，或者确保两边的对齐方式一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[repr(C)]</span> <span style=color:#75715e>// 关键：保证 C 兼容布局
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Debug, Copy, Clone, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> x: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> y: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma pack(push, 1) </span><span style=color:#75715e>// 建议：确保与 Rust 端一致的紧凑布局
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma pack(pop)
</span></span></span></code></pre></div><h3 id=管理-wasm-内部状态>管理 Wasm 内部状态<a hidden class=anchor aria-hidden=true href=#管理-wasm-内部状态>#</a></h3><p>Wasm 模块有时也需要维护自己的状态。一种方法是使用 Rust 的 <code>static mut</code> 变量。但是，访问 <code>static mut</code> 需要 <code>unsafe</code>
块，因为它可能引入数据竞争（虽然在单线程 Wasm 环境中风险较小，但 Rust 依然要求 <code>unsafe</code>）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// Wasm 模块内部状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// FFI 内部帮助函数，用于安全地读取（仍然需要 unsafe 块）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_plugin_value_internal</span>() -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在 core 模块中使用
</span></span></span><span style=display:flex><span><span style=color:#75715e>// use crate::ffi::read_plugin_value_internal;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// let val = read_plugin_value_internal();
</span></span></span></code></pre></div><p>如果需要让宿主能够直接修改这个状态，可以导出一个函数，返回该 <code>static mut</code> 变量的<strong>指针</strong>（内存偏移量）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_plugin_shared_value_ptr</span>() -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注意：这里需要 `unsafe` fn 并且内部还需要 `unsafe` 块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 使用 `&amp;raw mut` (较新 Rust 语法) 或直接转换来获取原始指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// let ptr = unsafe { &amp;mut PLUGIN_SHARED_VALUE as *mut i32 };
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> { <span style=color:#f92672>&amp;</span>raw <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> }; <span style=color:#75715e>// 使用 &amp;raw mut 避免 Miri 抱怨
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] get_plugin_shared_value_ptr() -&gt; </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>    ptr
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>警告：</strong> 直接向宿主暴露内部可变状态的指针是一种非常危险的做法！这打破了 Wasm 的封装性，宿主可以直接修改 Wasm
内部的数据，可能导致意想不到的后果或破坏 Wasm
内部的不变性。在实际应用中应极力避免这种模式，除非有非常明确和受控的理由。更好的方式是通过导出的函数来间接、安全地修改内部状态。这里展示它主要是为了演示内存操作的可能性。</p><h2 id=交互模式详解>交互模式详解<a hidden class=anchor aria-hidden=true href=#交互模式详解>#</a></h2><p>现在我们结合 C++ 宿主和 Rust Wasm 模块的代码，来看看具体的交互流程是如何实现的。</p><h3 id=模式一宿主调用简单-wasm-函数-just_add>模式一：宿主调用简单 Wasm 函数 (<code>just_add</code>)<a hidden class=anchor aria-hidden=true href=#模式一宿主调用简单-wasm-函数-just_add>#</a></h3><p>这是最基本的交互。宿主需要调用 Wasm 模块导出的一个纯计算函数。</p><p><strong>C++ 宿主端 (<code>host.cpp</code>):</strong></p><ol><li><strong>获取函数：</strong> 通过 <code>WasmHost</code> 封装的方法（内部调用 <code>instance_.get()</code> 和 <code>func.typed()</code>）获取类型安全的 Wasm 函数代理
<code>TypedFunc</code>。</li><li><strong>准备参数：</strong> 将 C++ 的 <code>uint64_t</code> 参数包装在 <code>std::tuple</code> 中。</li><li><strong>调用：</strong> 使用 <code>typed_func.call()</code> 方法调用 Wasm 函数。Wasmtime C++ API 会处理参数和返回值的传递。</li><li><strong>处理结果：</strong> 从返回的 <code>Result</code> 中获取结果 <code>std::tuple</code>，并提取出 <code>uint64_t</code> 的返回值。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main 函数内, Test 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint64_t</span> arg1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>, arg2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(arg1, arg2);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;just_add(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg2 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// host 是 WasmHost 实例
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 类型推导：返回值是 tuple&lt;u64&gt;, 参数是 tuple&lt;u64, u64&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> result_tuple <span style=color:#f92672>=</span> host.callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;just_add&#34;</span>, args);
</span></span><span style=display:flex><span><span style=color:#75715e>// result_tuple 是 Result&lt;std::tuple&lt;uint64_t&gt;, TrapError&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result_tuple) { <span style=color:#75715e>/* 错误处理 */</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> result_val <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(result_tuple.ok());
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] &#39;just_add&#39; Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_val <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span></code></pre></div><p>这里 <code>host.callFunction</code> 是 <code>WasmHost</code> 类中对 Wasmtime API 的封装，它隐藏了获取函数、类型检查和调用的细节。</p><p><strong>Rust Wasm 端 (<code>src/ffi.rs</code> 和 <code>src/lib.rs::core</code>):</strong></p><ol><li><code>#[no_mangle] pub extern "C" fn just_add</code> 函数被导出。</li><li>它接收两个 <code>u64</code> 参数，调用 <code>core::perform_basic_add</code> 进行计算。</li><li>返回 <code>u64</code> 结果。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>just_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add called with: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::core::perform_basic_add(left, right); <span style=color:#75715e>// 调用核心逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] just_add result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, result);
</span></span><span style=display:flex><span>    result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_basic_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] perform_basic_add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    left.wrapping_add(right) <span style=color:#75715e>// 使用安全加法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这个流程展示了从 C++ 到 Rust 的基本函数调用和简单数据类型传递。</p><h3 id=模式二wasm-调用宿主函数-trigger_host_calls>模式二：Wasm 调用宿主函数 (<code>trigger_host_calls</code>)<a hidden class=anchor aria-hidden=true href=#模式二wasm-调用宿主函数-trigger_host_calls>#</a></h3><p>这个模式反过来，Wasm 模块需要调用宿主提供的功能。</p><p><strong>C++ 宿主端:</strong></p><ol><li><strong>实现宿主函数：</strong> 如 <code>host_log_value_impl_target</code>, <code>host_get_shared_value_impl_target</code>,
<code>host_set_shared_value_impl_target</code>。这些函数可以直接访问和修改宿主的状态（如 <code>shared_host_value</code>）。</li><li><strong>注册到 Linker：</strong> 使用 <code>host.defineHostFunction("env", ...)</code> 将这些 C++ 函数与 Wasm 模块期望导入的 &ldquo;env&rdquo;
模块下的函数名关联起来。</li><li><strong>调用 Wasm 入口：</strong> 宿主调用 Wasm 导出的 <code>trigger_host_calls</code> 函数，这个函数会触发 Wasm
内部对宿主函数的调用。这里调用的是一个无返回值的函数，可以使用 <code>host.callFunctionVoid</code>。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main 函数内, Test 2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> trigger_arg <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int32_t</span> host_value_before <span style=color:#f92672>=</span> shared_host_value; <span style=color:#75715e>// 记录调用前状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;trigger_host_calls(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> trigger_arg <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// host.callFunctionVoid 封装了调用无返回值 Wasm 函数的逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 参数是 tuple&lt;i32&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.callFunctionVoid<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;trigger_host_calls&#34;</span>, std<span style=color:#f92672>::</span>make_tuple(trigger_arg));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Returned from &#39;trigger_host_calls&#39;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// 检查调用后宿主状态是否被 Wasm 修改
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ... 比较 shared_host_value 与预期值 ...
</span></span></span></code></pre></div><p><strong>Rust Wasm 端:</strong></p><ol><li><strong>声明导入：</strong> 在 <code>src/ffi.rs</code> 中使用 <code>extern "C"</code> 和 <code>#[link(wasm_import_module = "env")]</code> 声明需要从宿主导入的函数。</li><li><strong>提供安全包装：</strong> 在 <code>src/ffi.rs</code> 中提供如 <code>log_value_from_host</code>, <code>get_shared_value_from_host</code>,
<code>set_shared_value_in_host</code> 的安全包装器。</li><li><strong>导出触发函数：</strong> <code>trigger_host_calls</code> 函数被导出。</li><li><strong>调用宿主函数：</strong> 在 <code>core::perform_host_calls_test</code>（被 <code>trigger_host_calls</code> 调用）中，通过调用 FFI 层的安全包装器来间接调用
C++ 宿主函数，从而读取和修改宿主状态。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - 导入声明和安全包装 (前面已展示)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - 导出触发函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>trigger_host_calls</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls called with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>crate</span>::core::perform_host_calls_test(input_val); <span style=color:#75715e>// 调用核心逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] trigger_host_calls finished.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core - 核心逻辑，调用宿主函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_host_calls_test</span>(input_val: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] perform_host_calls_test with input: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, input_val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 调用 host_log_value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    log_value_from_host(input_val <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 调用 host_get_shared_value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> host_val <span style=color:#f92672>=</span> get_shared_value_from_host();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] Received value from host: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, host_val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 调用 host_set_shared_value (修改宿主状态)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> new_host_val <span style=color:#f92672>=</span> host_val.wrapping_add(input_val).wrapping_add(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    set_shared_value_in_host(new_host_val);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>这个流程展示了从 Wasm 到 C++ 的调用，以及 Wasm 如何通过调用宿主函数来影响宿主的状态。</p><h3 id=模式三通过内存共享结构体-point_add>模式三：通过内存共享结构体 (<code>point_add</code>)<a hidden class=anchor aria-hidden=true href=#模式三通过内存共享结构体-point_add>#</a></h3><p>这是更复杂的交互，涉及到在宿主和 Wasm 之间传递结构体数据。由于不能直接传递 C++ 或 Rust 对象，我们利用共享的线性内存。</p><p><strong>C++ 宿主端 (<code>host.cpp</code>, Test 3):</strong></p><ol><li><strong>定义结构体：</strong> 定义 <code>Point</code> 结构体，并使用 <code>#pragma pack</code> 确保布局可控。</li><li><strong>计算内存偏移量：</strong> 在 Wasm 线性内存中选择几个地址（偏移量）用于存放输入点 <code>p1</code>, <code>p2</code> 和结果点 <code>result</code>
。需要确保这些地址不会冲突，并且有足够的空间。</li><li><strong>写入内存：</strong> 创建 C++ <code>Point</code> 对象 <code>host_p1</code>, <code>host_p2</code>。使用 <code>host.writeMemory()</code> 方法将这两个对象的数据按字节复制到
Wasm 线性内存中对应的偏移量 <code>offset_p1</code>, <code>offset_p2</code> 处。<code>writeMemory</code> 内部会获取内存 Span 并执行 <code>memcpy</code>。</li><li><strong>调用 Wasm 函数：</strong> 调用 Wasm 导出的 <code>point_add</code> 函数。注意，传递给 Wasm 的参数是之前计算好的<strong>内存偏移量</strong>（作为
<code>int32_t</code> 指针）。</li><li><strong>读取内存：</strong> Wasm 函数执行完毕后，结果已经写回到了 Wasm 内存的 <code>offset_result</code> 位置。宿主使用
<code>host.readMemory&lt;Point>()</code> 方法从该偏移量读取数据，并将其解析为一个 C++ <code>Point</code> 对象。<code>readMemory</code> 内部同样会获取内存
Span 并执行 <code>memcpy</code>。</li><li><strong>验证结果：</strong> 比较从 Wasm 内存读回的结果与预期结果。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main 函数内, Test 3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> size_t point_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(Point);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_p1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2048</span>; <span style=color:#75715e>// 示例偏移量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_p2 <span style=color:#f92672>=</span> offset_p1 <span style=color:#f92672>+</span> point_size;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> offset_result <span style=color:#f92672>=</span> offset_p2 <span style=color:#f92672>+</span> point_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Point host_p1 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>};
</span></span><span style=display:flex><span>Point host_p2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>70</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Writing points to WASM memory...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// host.writeMemory 封装了获取 Span 和 memcpy 的逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.writeMemory(offset_p1, host_p1); <span style=color:#75715e>// 将 host_p1 写入 Wasm 内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>host.writeMemory(offset_p2, host_p2); <span style=color:#75715e>// 将 host_p2 写入 Wasm 内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm function &#39;point_add&#39; with offsets...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// 参数是偏移量 (i32)，代表指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> point_add_args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(offset_result, offset_p1, offset_p2);
</span></span><span style=display:flex><span>host.callFunctionVoid<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span>, <span style=color:#66d9ef>int32_t</span>, <span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(<span style=color:#e6db74>&#34;point_add&#34;</span>, point_add_args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Reading result struct from WASM memory...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// host.readMemory 封装了获取 Span 和 memcpy 的逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Point result_point <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span>(offset_result); <span style=color:#75715e>// 从 Wasm 内存读取结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] &#39;point_add&#39; Result read from memory: { x: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_point.x
</span></span><span style=display:flex><span>          <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, y: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result_point.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; }&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// ... 验证结果 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost 类中的 writeMemory/readMemory 简化实现：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> WasmHost<span style=color:#f92672>::</span>writeMemory(<span style=color:#66d9ef>int32_t</span> offset, <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> memory_span <span style=color:#f92672>=</span> getMemorySpan();
</span></span><span style=display:flex><span>    size_t data_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(T);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(offset) <span style=color:#f92672>+</span> data_size <span style=color:#f92672>&gt;</span> memory_span.size()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>out_of_range(<span style=color:#e6db74>&#34;Memory write out of bounds&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(memory_span.data() <span style=color:#f92672>+</span> offset, <span style=color:#f92672>&amp;</span>data, data_size);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T WasmHost<span style=color:#f92672>::</span>readMemory(<span style=color:#66d9ef>int32_t</span> offset) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> memory_span <span style=color:#f92672>=</span> getMemorySpan();
</span></span><span style=display:flex><span>    size_t data_size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(T);
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(offset) <span style=color:#f92672>+</span> data_size <span style=color:#f92672>&gt;</span> memory_span.size()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>out_of_range(<span style=color:#e6db74>&#34;Memory read out of bounds&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    T result;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(<span style=color:#f92672>&amp;</span>result, memory_span.data() <span style=color:#f92672>+</span> offset, data_size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Rust Wasm 端:</strong></p><ol><li><strong>定义结构体：</strong> 定义 <code>Point</code> 结构体，并使用 <code>#[repr(C)]</code> 确保布局与 C++ 端兼容。</li><li><strong>导出函数：</strong> 导出 <code>point_add</code> 函数。它的参数是 <code>*mut Point</code> 和 <code>*const Point</code> 类型，这些实际上接收的是宿主传来的 32
位整数（内存偏移量），Wasmtime 会将它们解释为指向 Wasm 线性内存的指针。</li><li><strong>使用 <code>unsafe</code>：</strong> 在函数体内部，必须使用 <code>unsafe</code> 块来解引用这些原始指针 (<code>*result_ptr</code>, <code>*p1_ptr</code>, <code>*p2_ptr</code>)。Rust
编译器无法保证这些指针的有效性（它们来自外部世界），所以需要开发者承担责任。</li><li><strong>执行操作：</strong> 从指针读取输入的 <code>Point</code> 数据，调用 <code>core::add_points</code> 计算结果。</li><li><strong>写入内存：</strong> 将计算得到的 <code>result</code> 通过 <code>*result_ptr = result;</code> 写回到宿主指定的内存位置。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - Point struct 定义 (前面已展示)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs - 导出 point_add 函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>point_add</span>(result_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> Point, p1_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Point, p2_ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> Point) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] point_add called with pointers...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#75715e>// 必须使用 unsafe 来解引用原始指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> result_ptr.is_null() <span style=color:#f92672>||</span> p1_ptr.is_null() <span style=color:#f92672>||</span> p2_ptr.is_null() {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;[WASM FFI] Error: Received null pointer.&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解引用输入指针，读取数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> p1 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p1_ptr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> p2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>p2_ptr;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用核心逻辑计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>crate</span>::core::add_points(p1, p2);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解引用输出指针，写入结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>*</span>result_ptr <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;[WASM FFI] Wrote result to address </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, result_ptr);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core - 核心加法逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_points</span>(p1: <span style=color:#a6e22e>Point</span>, p2: <span style=color:#a6e22e>Point</span>) -&gt; <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] add_points called with p1: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>, p2: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, p1, p2);
</span></span><span style=display:flex><span>    Point {
</span></span><span style=display:flex><span>        x: <span style=color:#a6e22e>p1</span>.x.wrapping_add(p2.x),
</span></span><span style=display:flex><span>        y: <span style=color:#a6e22e>p1</span>.y.wrapping_add(p2.y),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个模式是 Wasm 与宿主进行复杂数据交换的基础。关键在于内存布局的约定和通过指针（偏移量）进行访问，以及在 Rust 中正确使用
<code>unsafe</code>。</p><h3 id=模式四宿主直接读写-wasm-内部状态>模式四：宿主直接读写 Wasm 内部状态<a hidden class=anchor aria-hidden=true href=#模式四宿主直接读写-wasm-内部状态>#</a></h3><p>这个模式演示了（但不推荐）宿主如何直接修改 Wasm 模块内部的 <code>static mut</code> 状态。</p><p><strong>C++ 宿主端 (<code>host.cpp</code>, Test 4):</strong></p><ol><li><strong>获取状态指针：</strong> 调用 Wasm 导出的 <code>get_plugin_shared_value_ptr</code> 函数。这个函数返回一个 <code>int32_t</code>，它代表
<code>PLUGIN_SHARED_VALUE</code> 在 Wasm 线性内存中的偏移量。</li><li><strong>读取初始值：</strong> 使用 <code>host.readMemory&lt;int32_t>()</code> 从获取到的偏移量读取 Wasm 状态的当前值。</li><li><strong>写入新值：</strong> 使用 <code>host.writeMemory()</code> 向该偏移量写入一个新的 <code>int32_t</code> 值。</li><li><strong>再次读取验证：</strong> 再次使用 <code>host.readMemory&lt;int32_t>()</code> 读取，确认写入成功。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main 函数内, Test 4)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> plugin_value_offset <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm &#39;get_plugin_shared_value_ptr&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// getPluginDataOffset 封装了调用 Wasm 函数获取偏移量的逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>plugin_value_offset <span style=color:#f92672>=</span> host.getPluginDataOffset(<span style=color:#e6db74>&#34;get_plugin_shared_value_ptr&#34;</span>);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Received offset: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> plugin_value_offset <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (plugin_value_offset <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) { <span style=color:#75715e>// 基本有效性检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 读取 Wasm 状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int32_t</span> value_from_plugin_before <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;</span>(plugin_value_offset);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Value read from plugin: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value_from_plugin_before <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 写入新值到 Wasm 状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int32_t</span> new_value_for_plugin <span style=color:#f92672>=</span> <span style=color:#ae81ff>777</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Writing new value (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> new_value_for_plugin <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;) to plugin state...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    host.writeMemory(plugin_value_offset, new_value_for_plugin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 再次读取验证
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int32_t</span> value_from_plugin_after <span style=color:#f92672>=</span> host.readMemory<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;</span>(plugin_value_offset);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Value read after host write: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> value_from_plugin_after <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 验证 value_from_plugin_after == new_value_for_plugin ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WasmHost::getPluginDataOffset 实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int32_t</span> WasmHost<span style=color:#f92672>::</span>getPluginDataOffset(std<span style=color:#f92672>::</span>string_view func_name) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host] Getting plugin data offset via &#39;&#34;</span> <span style=color:#f92672>&lt;&lt;</span> func_name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;&#39;...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wasm 函数无参数，返回 i32 (偏移量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> result_tuple <span style=color:#f92672>=</span> callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int32_t</span><span style=color:#f92672>&gt;&gt;</span>(func_name);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result_tuple) { <span style=color:#75715e>/* 错误处理 */</span> <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> offset <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(result_tuple.ok());
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host] Received offset from plugin: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> offset <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> offset;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Rust Wasm 端:</strong></p><ol><li><strong>定义 <code>static mut</code> 状态：</strong> <code>static mut PLUGIN_SHARED_VALUE: i32 = 100;</code></li><li><strong>导出指针函数：</strong> 导出 <code>get_plugin_shared_value_ptr</code> 函数，它在 <code>unsafe</code> 上下文中返回 <code>PLUGIN_SHARED_VALUE</code>
的原始指针（偏移量）。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_plugin_shared_value_ptr</span>() -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> { <span style=color:#f92672>&amp;</span>raw <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> };
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] get_plugin_shared_value_ptr() -&gt; </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>    ptr
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个模式展示了内存操作的强大能力，但也突显了潜在的风险。宿主现在可以直接干预 Wasm 的内部实现细节。</p><h3 id=模式五wasm-验证内部状态被宿主修改>模式五：Wasm 验证内部状态被宿主修改<a hidden class=anchor aria-hidden=true href=#模式五wasm-验证内部状态被宿主修改>#</a></h3><p>为了确认模式四中宿主的写入确实生效了，我们让 Wasm 模块自己检查一下那个 <code>static mut</code> 变量的值。</p><p><strong>C++ 宿主端 (<code>host.cpp</code>, Test 5):</strong></p><p>在模式四修改了 Wasm 状态后，调用另一个 Wasm 函数（比如 <code>simple_add</code>，虽然名字不符，但可以复用）。我们不关心这个函数的返回值，而是关心它在
Wasm 内部执行时打印的日志。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// host.cpp (main 函数内, Test 5, 假设 plugin_value_offset &gt; 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Calling Wasm &#39;simple_add&#39; to verify internal state...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用一个 Wasm 函数，让它有机会读取并打印自己的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> args <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_tuple(<span style=color:#ae81ff>1ULL</span>, <span style=color:#ae81ff>1ULL</span>);
</span></span><span style=display:flex><span>host.callFunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;</span>, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span>, <span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>&gt;&gt;</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;simple_add&#34;</span>, args);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[Host Main] Returned from &#39;simple_add&#39;. Check WASM output above.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span></code></pre></div><p><strong>Rust Wasm 端:</strong></p><p>我们需要修改 <code>simple_add</code> 函数（或其调用的核心逻辑 <code>perform_simple_add_and_read_internal_state</code>），让它在执行主要任务之前，先读取
<code>PLUGIN_SHARED_VALUE</code> 的值并打印出来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/ffi.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simple_add</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM FFI] simple_add (verification step) called...&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>crate</span>::core::perform_simple_add_and_read_internal_state(left, right)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 内部帮助函数，读取 static mut (需要 unsafe)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span>(<span style=color:#66d9ef>crate</span>) <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_plugin_value_internal</span>() -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#66d9ef>PLUGIN_SHARED_VALUE</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib.rs::core
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>perform_simple_add_and_read_internal_state</span>(left: <span style=color:#66d9ef>u64</span>, right: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>u64</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取并打印自己的内部状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> current_plugin_val <span style=color:#f92672>=</span> read_plugin_value_internal(); <span style=color:#75715e>// 调用 FFI 辅助函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[WASM Core] Current plugin&#39;s internal shared value: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#75715e>// 期望这里打印 777
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        current_plugin_val
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;[WASM Core] Performing simple add: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> + </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, left, right);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 执行原本的加法逻辑 ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    left <span style=color:#f92672>+</span> right <span style=color:#75715e>// 假设简单返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>当宿主执行 Test 5 时，我们应该能在控制台看到来自 <code>[WASM Core]</code> 的输出，显示 <code>Current plugin's internal shared value: 777</code>
（或者模式四中写入的任何值），这就验证了宿主确实成功修改了 Wasm 的内部状态。</p><h2 id=关键要点与思考>关键要点与思考<a hidden class=anchor aria-hidden=true href=#关键要点与思考>#</a></h2><p>通过这个实例，我们可以总结出使用 Wasmtime 进行 C++/Rust Wasm 交互的几个关键点：</p><ol><li><strong>清晰的接口定义:</strong> FFI 层是核心。Rust 的 <code>extern "C"</code>（导入/导出）和 C++ 的函数签名/链接必须精确匹配。</li><li><strong>内存操作是基础:</strong> 复杂数据的传递依赖于对 Wasm 线性内存的读写。理解指针即偏移量、确保数据结构布局一致 (<code>#[repr(C)]</code>,
<code>#pragma pack</code>) 至关重要。</li><li><strong><code>unsafe</code> 的必要性:</strong> 在 Rust Wasm 模块中，与 FFI 和 <code>static mut</code> 交互几乎不可避免地需要 <code>unsafe</code> 块。必须谨慎使用，并尽量将其限制在
FFI 边界层。</li><li><strong>状态管理需谨慎:</strong> 宿主和 Wasm 都可以有自己的状态。可以通过函数调用相互影响对方的状态。直接暴露 Wasm
内部状态的指针给宿主虽然技术上可行，但破坏了封装，应尽量避免，优先选择通过接口函数进行状态管理。</li><li><strong>WASI 的作用:</strong> 对于需要标准 I/O 或其他系统交互的 Wasm 模块（即使只是 <code>println!</code>），宿主需要配置并链接 WASI。</li><li><strong>Wasmtime API:</strong> Wasmtime 提供了相当完善的 C++ API (<code>wasmtime.hh</code>)，包括 <code>Engine</code>, <code>Store</code>, <code>Module</code>, <code>Linker</code>,
<code>Instance</code>, <code>Memory</code>, <code>Func</code>, <code>TypedFunc</code>, <code>Val</code> 等核心类，以及用于错误处理的 <code>Result</code> 和 <code>Trap</code>。理解这些类的作用和关系是成功使用的关键。</li></ol><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>WebAssembly 和 Wasmtime 为我们提供了一种强大的方式来扩展现有应用程序，实现高性能、安全、可移植的模块化。C++ 与 Rust 的结合，既能利用
C++ 的生态和性能，又能享受 Rust 带来的安全保证，尤其适合构建插件系统、处理性能关键任务或需要强沙箱隔离的场景。</p><p>虽然本文涉及的交互模式已经比较丰富，但这仅仅是冰山一角。Wasmtime 还支持更高级的特性，如抢占式中断（epoch
interruption）、燃料计量（fuel metering）、引用类型（reference types）、多内存、线程等。</p><p>希望这篇详细的演练能帮助你理解 C++ 宿主与 Rust Wasm 模块通过 Wasmtime 进行交互的基本原理和实践方法。如果你对这个领域感兴趣，不妨亲自动手尝试一下，将
Wasm 融入到你的下一个项目中去！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/zh/tags/wasm/>Wasm</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/wasmtime/>Wasmtime</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/cpp/>Cpp</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/rust/>Rust</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ffi/>Ffi</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/shared-memory/>Shared-Memory</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/bidirectional-communication/>Bidirectional-Communication</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/host-guest/>Host-Guest</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/linear-memory/>Linear-Memory</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/struct-passing/>Struct-Passing</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/state-management/>State-Management</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/wasi/>Wasi</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/runtime/>Runtime</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/sandboxing/>Sandboxing</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/wasmtime-api/>Wasmtime-Api</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/c-plus-plus/>C-Plus-Plus</a></li></ul><nav class=paginav><a class=next href=https://tategotoazarasi.github.io/zh/posts/weaving-the-web-managing-entity-relationships-in-entt/><span class=title>下一页 »</span><br><span>在 EnTT 中优雅地处理实体关系：从 1:1 到 N:N</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>