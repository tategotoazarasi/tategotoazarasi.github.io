<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入Anki卡片内部：反混淆技术与数据提取实践 | Tategoto Azarasi</title>
<meta name=keywords content="anki,card-templates,demystification,data-extraction,puppeteer,jsdom,ankiconnect,javascript,html,css,nodejs,typescript,web-scraping,data-migration,template-conversion,reverse-engineering,anki-customization,learning-tools,spaced-repetition,automation,scripting,headless-browser,dom-parsing,persistencejs,anki-automation,knowledge-management,data-processing,frontend-techniques"><meta name=description content="深入解析复杂Anki卡片模板的反混淆技术，通过Puppeteer和JSDOM实现动态渲染内容的精准数据提取与迁移。"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="深入Anki卡片内部：反混淆技术与数据提取实践"><meta property="og:description" content="深入解析复杂Anki卡片模板的反混淆技术，通过Puppeteer和JSDOM实现动态渲染内容的精准数据提取与迁移。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-16T21:58:20+08:00"><meta property="article:modified_time" content="2025-05-16T21:58:20+08:00"><meta property="article:tag" content="Anki"><meta property="article:tag" content="Card-Templates"><meta property="article:tag" content="Demystification"><meta property="article:tag" content="Data-Extraction"><meta property="article:tag" content="Puppeteer"><meta property="article:tag" content="Jsdom"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入Anki卡片内部：反混淆技术与数据提取实践"><meta name=twitter:description content="深入解析复杂Anki卡片模板的反混淆技术，通过Puppeteer和JSDOM实现动态渲染内容的精准数据提取与迁移。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"深入Anki卡片内部：反混淆技术与数据提取实践","item":"https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入Anki卡片内部：反混淆技术与数据提取实践","name":"深入Anki卡片内部：反混淆技术与数据提取实践","description":"深入解析复杂Anki卡片模板的反混淆技术，通过Puppeteer和JSDOM实现动态渲染内容的精准数据提取与迁移。","keywords":["anki","card-templates","demystification","data-extraction","puppeteer","jsdom","ankiconnect","javascript","html","css","nodejs","typescript","web-scraping","data-migration","template-conversion","reverse-engineering","anki-customization","learning-tools","spaced-repetition","automation","scripting","headless-browser","dom-parsing","persistencejs","anki-automation","knowledge-management","data-processing","frontend-techniques"],"articleBody":"Anki作为一款强大的间隔重复记忆软件，其灵活性和可定制性深受用户喜爱。许多用户会从网络上下载或购买制作精良的卡片模板，这些模板往往包含复杂的HTML、CSS和JavaScript，以实现丰富的交互效果和美观的视觉呈现。然而，这种复杂性有时也带来一个问题：当我们需要迁移数据、调整模板、或者仅仅是想理解卡片内容是如何生成的时候，会发现模板中的数据并非直接可见，而是通过JavaScript动态渲染或某种形式的“混淆”来展示。\n本篇博文旨在探讨一种系统性的方法，用于“反混淆”这类复杂的Anki卡片，提取其核心数据，并为后续的数据再利用（例如，迁移到新的、更简洁的模板或进行数据分析）打下基础。我们将以实际遇到的卡片模板（例如，一个政治复习模板和一个驾考题库模板）为例，逐步解析处理流程和关键技术点。本文更侧重于思路和方法论的阐述，而非代码的直接堆砌，希望读者在理解后能够根据自身需求进行调整和实践。\n为什么要进行卡片反混淆？ 在深入探讨技术细节之前，我们有必要首先明确进行Anki卡片反混淆的内在动机及其所能带来的实际价值。一个核心的驱动因素是* 数据迁移与模板更换* 的需求。用户在长期使用Anki的过程中，可能希望将积累的卡片内容从一个模板迁移到另一个自己设计的、或从社群获取的更优模板，抑或是从复杂的商业模板转向更轻量、更贴合个人学习节奏的模板。由于许多高级模板的内容是动态生成的，简单的复制粘贴操作往往无法达成预期的数据迁移效果，这就凸显了反混淆提取原始数据的必要性。\n另一个重要的价值在于数据清洗与格式统一 。原始卡片数据中可能混杂着大量对内容本身而言并非必需的HTML标签、内联样式信息，或者各项数据在格式上存在不一致的情况。通过反混淆并提取出相对纯净的数据，我们就能更便捷地进行后续的数据清洗工作，统一数据格式，为数据的进一步处理和利用奠定坚实基础。\n此外，反混淆所提取出的结构化数据为数据分析与再利用 提供了广阔的空间。这些数据可以被用于各种统计分析，例如分析题库中不同题目类型的分布比例、某一知识点在卡片中出现的频率等，从而为学习策略的调整提供数据支持。同时，这些结构化的原始数据也可以作为素材，用于生成其他形式的学习资料，如思维导图、总结笔记等，实现知识的多维度呈现和利用。\n从技术提升的角度来看，反混淆的过程本身也是一个宝贵的模板机制学习与定制 机会。通过细致地逆向分析复杂卡片模板的数据是如何被处理和呈现的，用户可以深入理解Anki模板系统的高级用法，学习到诸如JavaScript动态交互、CSS高级排版等技巧。这些经验对于用户将来独立设计和定制功能更强大、个性化程度更高的Anki模板是非常有益的。\n最后，或许也是最根本的一点，掌握卡片反混淆技术能够帮助用户摆脱对特定模板的依赖 。当核心数据掌握在自己手中后，用户就不再受限于某个特定的、可能因为作者停止维护、功能不再满足需求，或者与新版Anki不兼容等原因而变得不合时宜的模板。数据的自主性意味着更大的灵活性和长期的可控性。\n总而言之，卡片反混淆的核心目标是将“所见即所得”的卡片内容还原为其内在的数据结构，从而获得对卡片信息更大的掌控力。\n核心技术栈概览 要有效地实现Anki卡片的自动化反混淆，我们需要依赖一套现代的编程工具与库组合。其中，Node.js与TypeScript 构成了我们脚本开发的基础。Node.js以其强大的JavaScript运行时环境，为我们在服务器端或本地执行自动化脚本提供了便利。而TypeScript，作为JavaScript的超集，通过引入静态类型检查机制，显著增强了代码的健壮性和可维护性，这在处理复杂数据结构和逻辑流程时尤为重要，能帮助我们更早地发现潜在的类型错误，提升开发效率和代码质量。\n在模拟浏览器行为和执行JavaScript方面，Puppeteer扮演了不可或缺的角色。这个由Google Chrome团队维护的Node库，提供了一套高级API，允许我们通过DevTools协议来控制Chrome或Chromium浏览器的行为。对于Anki卡片反混淆而言，Puppeteer的核心价值在于它能够创建一个真实的浏览器环境，通常是以无头（headless）模式运行，这意味着它可以在后台执行而无需图形界面。许多设计精良的Anki卡片模板会大量使用JavaScript来动态生成卡片内容、响应用户交互，甚至进行一些简单的数据解密或转换。如果我们仅仅分析卡片的静态HTML模板文件，往往无法获取用户最终看到的、经过JavaScript处理后的完整数据。Puppeteer能够加载HTML模板，执行其中嵌入的JavaScript代码，模拟浏览器的完整渲染流程，最终输出一个包含了所有动态生成内容的DOM（文档对象模型）结构。这对于处理那些内容并非静态写死在HTML中的卡片至关重要。\n当Puppeteer完成了页面的渲染并返回了包含所有动态内容的HTML字符串后，JSDOM便登场了。JSDOM是一个纯JavaScript实现的、遵循WHATWG DOM和HTML标准的库，它使得我们能够在Node.js这样的非浏览器环境中，方便地使用与Web浏览器中几乎一致的API来操作HTML文档。具体来说，JSDOM可以将Puppeteer输出的HTML字符串解析成一个完整的DOM树结构。这个DOM树随后就可以像我们在浏览器开发者工具的控制台中操作 document对象那样，通过标准的DOM方法，如document.getElementById()、document.getElementsByClassName()、 document.querySelectorAll()等，进行元素的定位、遍历和内容提取。这为我们从复杂的HTML结构中精确抓取所需数据提供了极大的便利。\n最后，为了能够与Anki应用程序本身进行交互——读取源卡片数据并写入处理后的新卡片——我们需要借助AnkiConnect 。AnkiConnect是一个非常实用的Anki插件，它通过暴露一个本地HTTP服务接口，允许外部应用程序对Anki进行编程控制。在我们的反混淆任务中，AnkiConnect主要承担以下职责：首先，通过其 findNotes动作，我们可以根据牌组名称、标签或其他查询条件，批量获取需要处理的笔记ID列表。其次，对于每一个笔记ID，我们可以使用 notesInfo动作来获取该笔记的全部详细信息，这包括了笔记中各个字段（如“问题”、“答案”、“解析”等）的原始内容，以及笔记的标签等元数据。最后，在数据提取和转换完成后，我们可以利用 addNote动作，将整理好的新数据以指定的笔记类型和字段结构添加回Anki，从而完成整个数据的迁移或格式化过程。可以说，AnkiConnect是我们自动化脚本与Anki数据库之间进行数据交换的关键桥梁。\n反混淆通用工作流程 尽管不同的Anki卡片模板其复杂度和实现方式各异，但反混淆的基本流程大同小异，可以概括为以下几个核心步骤：\n准备阶段：理解源卡片 在正式开始编写自动化脚本之前，首要且至关重要的步骤是进行充分的准备阶段 ，其核心在于深入理解源卡片的构成和数据组织方式。这一阶段的工作质量直接影响后续自动化流程的效率和准确性。\n首先，我们需要确定数据源。这意味着要明确指定我们需要处理的卡片具体位于Anki中的哪个牌组。一旦确定了目标牌组，就可以利用AnkiConnect提供的 findNotes动作，通过构造查询语句（例如，deck:YourDeckName，其中YourDeckName 需替换为实际的牌组名称）来获取该牌组下所有笔记的唯一ID列表。这个ID列表将是我们后续自动化处理的入口点。\n接下来，进入分析卡片结构 的环节，这是理解数据如何存储和呈现的关键。我们应在Anki的卡片浏览器中选取一个或多个具有代表性的卡片样本进行细致观察。第一步是查看这些卡片的“字段”内容。要弄清楚每个字段究竟存储了何种类型的原始数据，例如，哪个字段是题目文本，哪个字段是选项（特别注意选项之间可能存在的特定分隔符，如双竖线 ||），哪个字段记录了正确答案，哪个字段包含了详细的解析或备注信息，以及是否存在题号、标签等辅助字段。对源数据在字段层面的理解，是后续数据映射的基础。\n更为关键的是，我们需要深入到Anki的模板编辑器中，对卡片的“正面模板”、“背面模板”以及“样式(CSS) ”进行仔细研究。对于HTML结构，要留意各个字段的数据是如何通过Anki的占位符（例如 {{字段名}} 或 {{cloze:字段名}} ）被嵌入到最终的HTML文档中的。这有助于我们理解原始数据与最终显示内容之间的映射关系。\n然而，对于复杂的卡片模板，JavaScript行为的分析往往是反混淆的核心与难点。许多模板会利用JavaScript来实现动态的内容渲染和交互效果。我们需要大致梳理模板中 ","wordCount":"273","inLanguage":"zh","datePublished":"2025-05-16T21:58:20+08:00","dateModified":"2025-05-16T21:58:20+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入Anki卡片内部：反混淆技术与数据提取实践</h1><div class=post-meta><span title='2025-05-16 21:58:20 +0800 +0800'>五月 16, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;273 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/en/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#为什么要进行卡片反混淆>为什么要进行卡片反混淆？</a></li><li><a href=#核心技术栈概览>核心技术栈概览</a></li><li><a href=#反混淆通用工作流程>反混淆通用工作流程</a><ol><li><a href=#准备阶段理解源卡片>准备阶段：理解源卡片</a></li><li><a href=#自动化处理核心流程>自动化处理核心流程</a></li><li><a href=#辅助功能>辅助功能</a></li></ol></li><li><a href=#处理典型模板的经验>处理典型模板的经验</a></li><li><a href=#实践要点与未来展望>实践要点与未来展望</a></li></ol></nav></div></details></div><div class=post-content><p>Anki作为一款强大的间隔重复记忆软件，其灵活性和可定制性深受用户喜爱。许多用户会从网络上下载或购买制作精良的卡片模板，这些模板往往包含复杂的HTML、CSS和JavaScript，以实现丰富的交互效果和美观的视觉呈现。然而，这种复杂性有时也带来一个问题：当我们需要迁移数据、调整模板、或者仅仅是想理解卡片内容是如何生成的时候，会发现模板中的数据并非直接可见，而是通过JavaScript动态渲染或某种形式的“混淆”来展示。</p><p>本篇博文旨在探讨一种系统性的方法，用于“反混淆”这类复杂的Anki卡片，提取其核心数据，并为后续的数据再利用（例如，迁移到新的、更简洁的模板或进行数据分析）打下基础。我们将以实际遇到的卡片模板（例如，一个政治复习模板和一个驾考题库模板）为例，逐步解析处理流程和关键技术点。本文更侧重于思路和方法论的阐述，而非代码的直接堆砌，希望读者在理解后能够根据自身需求进行调整和实践。</p><h2 id=为什么要进行卡片反混淆>为什么要进行卡片反混淆？<a hidden class=anchor aria-hidden=true href=#为什么要进行卡片反混淆>#</a></h2><p>在深入探讨技术细节之前，我们有必要首先明确进行Anki卡片反混淆的内在动机及其所能带来的实际价值。一个核心的驱动因素是*
<em>数据迁移与模板更换</em>*
的需求。用户在长期使用Anki的过程中，可能希望将积累的卡片内容从一个模板迁移到另一个自己设计的、或从社群获取的更优模板，抑或是从复杂的商业模板转向更轻量、更贴合个人学习节奏的模板。由于许多高级模板的内容是动态生成的，简单的复制粘贴操作往往无法达成预期的数据迁移效果，这就凸显了反混淆提取原始数据的必要性。</p><p>另一个重要的价值在于<strong>数据清洗与格式统一</strong>
。原始卡片数据中可能混杂着大量对内容本身而言并非必需的HTML标签、内联样式信息，或者各项数据在格式上存在不一致的情况。通过反混淆并提取出相对纯净的数据，我们就能更便捷地进行后续的数据清洗工作，统一数据格式，为数据的进一步处理和利用奠定坚实基础。</p><p>此外，反混淆所提取出的结构化数据为<strong>数据分析与再利用</strong>
提供了广阔的空间。这些数据可以被用于各种统计分析，例如分析题库中不同题目类型的分布比例、某一知识点在卡片中出现的频率等，从而为学习策略的调整提供数据支持。同时，这些结构化的原始数据也可以作为素材，用于生成其他形式的学习资料，如思维导图、总结笔记等，实现知识的多维度呈现和利用。</p><p>从技术提升的角度来看，反混淆的过程本身也是一个宝贵的<strong>模板机制学习与定制</strong>
机会。通过细致地逆向分析复杂卡片模板的数据是如何被处理和呈现的，用户可以深入理解Anki模板系统的高级用法，学习到诸如JavaScript动态交互、CSS高级排版等技巧。这些经验对于用户将来独立设计和定制功能更强大、个性化程度更高的Anki模板是非常有益的。</p><p>最后，或许也是最根本的一点，掌握卡片反混淆技术能够帮助用户<strong>摆脱对特定模板的依赖</strong>
。当核心数据掌握在自己手中后，用户就不再受限于某个特定的、可能因为作者停止维护、功能不再满足需求，或者与新版Anki不兼容等原因而变得不合时宜的模板。数据的自主性意味着更大的灵活性和长期的可控性。</p><p>总而言之，卡片反混淆的核心目标是将“所见即所得”的卡片内容还原为其内在的数据结构，从而获得对卡片信息更大的掌控力。</p><h2 id=核心技术栈概览>核心技术栈概览<a hidden class=anchor aria-hidden=true href=#核心技术栈概览>#</a></h2><p>要有效地实现Anki卡片的自动化反混淆，我们需要依赖一套现代的编程工具与库组合。其中，<strong>Node.js与TypeScript</strong>
构成了我们脚本开发的基础。Node.js以其强大的JavaScript运行时环境，为我们在服务器端或本地执行自动化脚本提供了便利。而TypeScript，作为JavaScript的超集，通过引入静态类型检查机制，显著增强了代码的健壮性和可维护性，这在处理复杂数据结构和逻辑流程时尤为重要，能帮助我们更早地发现潜在的类型错误，提升开发效率和代码质量。</p><p>在模拟浏览器行为和执行JavaScript方面，<strong>Puppeteer</strong>扮演了不可或缺的角色。这个由Google
Chrome团队维护的Node库，提供了一套高级API，允许我们通过DevTools协议来控制Chrome或Chromium浏览器的行为。对于Anki卡片反混淆而言，Puppeteer的核心价值在于它能够创建一个真实的浏览器环境，通常是以无头（headless）模式运行，这意味着它可以在后台执行而无需图形界面。许多设计精良的Anki卡片模板会大量使用JavaScript来动态生成卡片内容、响应用户交互，甚至进行一些简单的数据解密或转换。如果我们仅仅分析卡片的静态HTML模板文件，往往无法获取用户最终看到的、经过JavaScript处理后的完整数据。Puppeteer能够加载HTML模板，执行其中嵌入的JavaScript代码，模拟浏览器的完整渲染流程，最终输出一个包含了所有动态生成内容的DOM（文档对象模型）结构。这对于处理那些内容并非静态写死在HTML中的卡片至关重要。</p><p>当Puppeteer完成了页面的渲染并返回了包含所有动态内容的HTML字符串后，<strong>JSDOM</strong>便登场了。JSDOM是一个纯JavaScript实现的、遵循WHATWG
DOM和HTML标准的库，它使得我们能够在Node.js这样的非浏览器环境中，方便地使用与Web浏览器中几乎一致的API来操作HTML文档。具体来说，JSDOM可以将Puppeteer输出的HTML字符串解析成一个完整的DOM树结构。这个DOM树随后就可以像我们在浏览器开发者工具的控制台中操作
<code>document</code>对象那样，通过标准的DOM方法，如<code>document.getElementById()</code>、<code>document.getElementsByClassName()</code>、
<code>document.querySelectorAll()</code>等，进行元素的定位、遍历和内容提取。这为我们从复杂的HTML结构中精确抓取所需数据提供了极大的便利。</p><p>最后，为了能够与Anki应用程序本身进行交互——读取源卡片数据并写入处理后的新卡片——我们需要借助<strong>AnkiConnect</strong>
。AnkiConnect是一个非常实用的Anki插件，它通过暴露一个本地HTTP服务接口，允许外部应用程序对Anki进行编程控制。在我们的反混淆任务中，AnkiConnect主要承担以下职责：首先，通过其
<code>findNotes</code>动作，我们可以根据牌组名称、标签或其他查询条件，批量获取需要处理的笔记ID列表。其次，对于每一个笔记ID，我们可以使用
<code>notesInfo</code>动作来获取该笔记的全部详细信息，这包括了笔记中各个字段（如“问题”、“答案”、“解析”等）的原始内容，以及笔记的标签等元数据。最后，在数据提取和转换完成后，我们可以利用
<code>addNote</code>动作，将整理好的新数据以指定的笔记类型和字段结构添加回Anki，从而完成整个数据的迁移或格式化过程。可以说，AnkiConnect是我们自动化脚本与Anki数据库之间进行数据交换的关键桥梁。</p><h2 id=反混淆通用工作流程>反混淆通用工作流程<a hidden class=anchor aria-hidden=true href=#反混淆通用工作流程>#</a></h2><p>尽管不同的Anki卡片模板其复杂度和实现方式各异，但反混淆的基本流程大同小异，可以概括为以下几个核心步骤：</p><h3 id=准备阶段理解源卡片>准备阶段：理解源卡片<a hidden class=anchor aria-hidden=true href=#准备阶段理解源卡片>#</a></h3><p>在正式开始编写自动化脚本之前，首要且至关重要的步骤是进行充分的<strong>准备阶段</strong>
，其核心在于深入理解源卡片的构成和数据组织方式。这一阶段的工作质量直接影响后续自动化流程的效率和准确性。</p><p>首先，我们需要<strong>确定数据源</strong>。这意味着要明确指定我们需要处理的卡片具体位于Anki中的哪个牌组。一旦确定了目标牌组，就可以利用AnkiConnect提供的
<code>findNotes</code>动作，通过构造查询语句（例如，<code>deck:YourDeckName</code>，其中<code>YourDeckName</code>
需替换为实际的牌组名称）来获取该牌组下所有笔记的唯一ID列表。这个ID列表将是我们后续自动化处理的入口点。</p><p>接下来，进入<strong>分析卡片结构</strong>
的环节，这是理解数据如何存储和呈现的关键。我们应在Anki的卡片浏览器中选取一个或多个具有代表性的卡片样本进行细致观察。第一步是查看这些卡片的“字段”内容。要弄清楚每个字段究竟存储了何种类型的原始数据，例如，哪个字段是题目文本，哪个字段是选项（特别注意选项之间可能存在的特定分隔符，如双竖线
<code>||</code>），哪个字段记录了正确答案，哪个字段包含了详细的解析或备注信息，以及是否存在题号、标签等辅助字段。对源数据在字段层面的理解，是后续数据映射的基础。</p><p>更为关键的是，我们需要深入到Anki的模板编辑器中，对卡片的“正面模板”、“背面模板”以及“样式(CSS)
”进行仔细研究。对于HTML结构，要留意各个字段的数据是如何通过Anki的占位符（例如 <code>{{字段名}}</code> 或 <code>{{cloze:字段名}}</code>
）被嵌入到最终的HTML文档中的。这有助于我们理解原始数据与最终显示内容之间的映射关系。</p><p>然而，对于复杂的卡片模板，<strong>JavaScript行为</strong>的分析往往是反混淆的核心与难点。许多模板会利用JavaScript来实现动态的内容渲染和交互效果。我们需要大致梳理模板中
<code>&lt;script></code>标签内JavaScript代码的主要功能。这些脚本可能负责解析占位符中的原始数据（例如，将以<code>||</code>
分隔的选项字符串拆分成独立的选项，并渲染成HTML列表项），或者根据用户选择和正确答案来动态地高亮显示选项，亦或是控制“解析”等附加学习内容的显示与隐藏逻辑。理解这些JavaScript如何操作DOM、如何处理数据，对于我们后续在Puppeteer中正确模拟渲染至关重要。</p><p>同时，在分析HTML和JavaScript的过程中，还要特别关注<strong>CSS类名</strong>
的使用。动态添加或修改的CSS类名，常常是定位卡片状态（如用户已选选项、正确答案、错误答案）的重要线索。例如，模板可能会为被选中的正确选项赋予
<code>correct-light</code>或<code>correct</code>这样的类名，为错误选项赋予<code>wrong-light</code>或<code>wrong</code>
类名。识别这些关键的CSS类名，将极大地帮助我们后续使用JSDOM从渲染后的HTML中准确提取信息。</p><p>最后，在充分理解源卡片的数据构成和渲染逻辑之后，我们需要<strong>确定提取目标</strong>
。这意味着要清晰地列出我们希望从旧卡片中提取出的具体数据项，以及这些数据项在迁移到新卡片模板后，将分别对应新模板中的哪些字段。一个清晰的目标定义，能够指导我们后续的数据提取和转换逻辑的编写。</p><h3 id=自动化处理核心流程>自动化处理核心流程<a hidden class=anchor aria-hidden=true href=#自动化处理核心流程>#</a></h3><p>在完成准备阶段对源卡片有了深入理解之后，我们便可以进入<strong>自动化的核心处理流程</strong>
。这个流程的核心思想是遍历在准备阶段获取到的所有笔记ID，并对每一个笔记ID所代表的卡片执行一系列标准化的数据提取与转换操作。</p><p>对于列表中的每一个笔记ID，处理流程的第一步是<strong>获取笔记信息</strong>。我们会利用AnkiConnect提供的<code>notesInfo</code>
动作，将当前的笔记ID作为参数传入。AnkiConnect会返回该笔记的全部详细信息，这通常是一个包含了所有字段及其对应值的对象，同时也包含了该笔记的标签列表。这些原始的字段值是后续构建渲染用HTML的基础。</p><p>紧接着是<strong>构建用于渲染的HTML文档</strong>
。这一步需要我们预先准备一个本地的HTML模板文件，这个文件的结构应该与我们正在处理的源Anki卡片的模板（包括正面、背面和CSS样式）保持一致或高度相似。例如，在我们之前的讨论中，这个文件可能是
<code>pol2.html</code>或<code>jiazhao.html</code>。获取到笔记的字段数据后，我们的脚本会将这些数据逐一替换到本地HTML模板文件中预设的占位符（例如，
<code>{{题目}}</code>、<code>{{选项}}</code>等）中。一个需要特别注意的细节是，如果占位符本身包含如冒号这样的特殊字符（常见于<code>{{cloze:问题}}</code>
），在将这些占位符用作正则表达式进行替换时，务必对这些特殊字符进行转义，以确保替换操作的准确性。例如，<code>{{选项}}</code>
占位符会被替换为从笔记中获取到的、以<code>||</code>分隔的选项字符串。</p><p>当包含具体笔记数据的HTML内容构建完毕后，就进入了<strong>使用Puppeteer进行动态渲染</strong>
的阶段。首先，脚本会将上一步生成的、填充了实际卡片数据的完整HTML内容写入一个临时的本地HTML文件。随后，启动Puppeteer，并创建一个新的无头浏览器页面实例。一个非常关键的步骤，尤其是在处理像
<code>jiazhao.html</code>这样依赖<code>Persistence.js</code>或其他类似库来管理会话状态的模板时，是对浏览器环境进行必要的模拟。某些模板会在用户与卡片正面交互时（例如，选择选项、设置显示偏好）将状态信息存储在Anki
WebView的会话存储中，而背面模板在加载时会读取这些信息来决定内容的最终呈现方式（比如是否默认显示解析、选项的显示顺序等）。如果我们的自动化脚本直接尝试渲染一个包含完整正反面逻辑的模板，或者仅渲染背面部分，而没有预先建立起
<code>Persistence.js</code>所期望的会话状态，那么模板中的部分JavaScript逻辑可能不会按照我们获取完整数据的预期来执行，典型的例子就是“解析”部分可能默认是隐藏的。</p><p>为了解决这个问题，我们运用Puppeteer提供的<code>page.evaluateOnNewDocument()</code>
方法。这个强大的API允许我们在目标页面加载其自身的任何脚本之前，向页面注入我们自定义的JavaScript代码。利用这一点，我们可以在页面上下文中创建一个
<code>Persistence</code>对象的模拟实现（mock）。这个mock对象需要提供与真实库相似的核心API，如<code>isAvailable</code>、<code>getItem</code>、<code>setItem</code>和
<code>removeItem</code>等，并且允许我们预先设定某些键值对的值。例如，我们可以通过
<code>window.Persistence.setItem('ANKI-SETTINGS-HIDE-NOTES', '0');</code>
这样的代码，强制告知模板脚本我们希望显示解析内容。同时，为了应对正面模板可能存在的选项随机化逻辑（通常会将随机后的顺序存储在
<code>ANKI-OPTIONS-ORDER</code>中，供背面读取），我们也可以在mock中预设一个固定的选项顺序，例如
<code>window.Persistence.setItem('ANKI-OPTIONS-ORDER', '1,2,3,4');</code>（假设最多四个选项，且按原始1、2、3、4的顺序）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 示意性的Puppeteer脚本片段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>evaluateOnNewDocument</span>(() =&gt; {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mockStore</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>	window.<span style=color:#a6e22e>Persistence</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>isAvailable</span><span style=color:#f92672>:</span> () =&gt; <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>getItem</span>    <span style=color:#f92672>:</span> (<span style=color:#a6e22e>key</span>) =&gt; <span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>?</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>]) <span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>setItem</span>    <span style=color:#f92672>:</span> (<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>) =&gt; {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mockStore</span>[<span style=color:#a6e22e>key</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ... 其他必要方法，如removeItem, clear, getAllKeys，如果模板脚本有用到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	};
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 强制显示解析
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	window.<span style=color:#a6e22e>Persistence</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;ANKI-SETTINGS-HIDE-NOTES&#39;</span>, <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 设置一个默认的选项顺序，以确保背面能够正确解析和高亮
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 这个值应与卡片正面模板JS中getOptionObjs期望处理的原始选项顺序一致，或简单地设置为1,2,3,4...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Persistence</span>.<span style=color:#a6e22e>setItem</span>(<span style=color:#e6db74>&#39;ANKI-OPTIONS-ORDER&#39;</span>, <span style=color:#e6db74>&#39;1,2,3,4&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>在注入了模拟的<code>Persistence</code>环境后，我们再使用<code>page.goto()</code>方法加载之前创建的、包含卡片数据的临时HTML文件。由于模板中的JavaScript执行通常是异步的，因此
<strong>等待渲染完成</strong>是不可或缺的一环。我们需要确保在提取内容之前，所有相关的JavaScript逻辑都已执行完毕，并且DOM已经更新到最终状态。这可以通过几种方式实现：一种是使用
<code>page.waitForSelector()</code>，等待一个或多个关键的CSS选择器所匹配的元素出现在DOM中。例如，在卡片的背面，我们可以等待那些表示选项状态（如正确、错误、应选）的CSS类（诸如
<code>.correct-light</code>, <code>.should-select-light</code>, <code>.correct</code>等）被实际应用到选项列表项（<code>&lt;li></code>元素）上。另一种方式是使用
<code>page.waitForFunction()</code>
，它可以等待一个在页面上下文中执行的JavaScript函数返回真值，例如，我们可以编写一个函数来检查“解析”内容的容器是否已经填充了文本。一旦这些等待条件得到满足，就意味着页面已经渲染完毕，此时我们可以调用
<code>page.content()</code>来获取整个页面渲染后的HTML内容字符串。</p><p>获取到渲染完成的HTML后，下一步是<strong>使用JSDOM解析HTML并提取结构化数据</strong>
。我们将Puppeteer返回的HTML字符串传递给JSDOM的构造函数，这将为我们生成一个可以在Node.js环境中操作的<code>document</code>对象，其API与浏览器中的
<code>document</code>对象高度兼容。利用这个<code>document</code>对象，我们便可以使用标准的DOM遍历和查询方法来精确地提取所需数据。例如，<strong>题目文本
<strong>通常位于某个具有特定类名（如<code>.question</code>）的元素内，提取后可能还需要进行如去除题号前缀之类的后续处理。对于</strong>选项文本</strong>
，我们需要先定位到包含所有选项的父容器（例如，一个<code>id</code>为<code>back-options</code>的<code>div</code>元素），然后遍历其中的每一个代表选项的子元素（如
<code>&lt;li class="option"></code>），并提取它们的<code>textContent</code>。<strong>正确答案</strong>
的提取则依赖于检查这些选项元素是否被赋予了表示“正确”或“应选”状态的CSS类。根据这些类以及选项在列表中的原始顺序（可以通过分析其在父容器中的索引得到，或者如果选项本身有ID，则通过ID），我们可以确定正确答案对应的字母标识（A,
B, C, D等）。如果卡片是多选题，我们需要将所有标记为正确的选项的字母拼接起来。<strong>解析或备注信息</strong>通常也位于特定的容器元素中（例如，
<code>jiazhao.html</code>模板中的<code>&lt;div id="notes-wrapper">&lt;div class="notes-container">...&lt;/div>&lt;/div></code>结构），我们可以提取其
<code>innerHTML</code>以保留可能的HTML格式，或者提取<code>textContent</code>以获取纯文本。至于<strong>标签信息</strong>，则可以直接从第一步通过AnkiConnect获取的
<code>notesInfo</code>对象中获得。在提取出各类数据后，往往还需要进行必要的<strong>数据清洗</strong>，比如去除文本两端多余的空格（使用<code>.trim()</code>
），或者根据目标字段的要求剔除不必要的HTML标签。</p><p>当所有需要的数据都已从渲染后的HTML中成功提取并清洗完毕后，就进入了<strong>构建新笔记数据</strong>
的阶段。在这一步，我们需要根据目标Anki笔记类型的具体字段结构，将提取到的各项数据组织成一个符合AnkiConnect <code>addNote</code>
动作要求的JavaScript对象。这个对象需要指定目标牌组名称（<code>deckName</code>）、目标笔记类型名称（<code>modelName</code>），以及一个<code>fields</code>
对象，该对象的键是目标笔记类型中的字段名，值是我们刚刚提取和处理过的数据。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>deckName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;我的新驾考题库&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>modelName</span>
</span></span><span style=display:flex><span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;驾考选择题-简化版&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fields</span>
</span></span><span style=display:flex><span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;题干&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedQuestionText</span>,
</span></span><span style=display:flex><span>			<span style=color:#e6db74>&#34;选项A&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedOptions</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#e6db74>&#34;选项B&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedOptions</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#e6db74>&#34;正确答案&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedCorrectAnswerLetters</span>, <span style=color:#75715e>// &#34;A&#34;, &#34;BC&#34;, &#34;ACD&#34; 等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#e6db74>&#34;详细解析&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>extractedRemarkText</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tags</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>originalTagsArray</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后一步是<strong>将新笔记添加到Anki</strong>。我们调用AnkiConnect的<code>addNote</code>
动作，并将上一步精心构建的笔记数据对象作为参数传递。AnkiConnect会处理这个请求，在Anki中创建一张新的、结构清晰、数据干净的卡片。至此，针对单个源笔记的反混淆和数据迁移（或重构）流程便告一段落。</p><h3 id=辅助功能>辅助功能<a hidden class=anchor aria-hidden=true href=#辅助功能>#</a></h3><p>在设计和实现Anki卡片反混淆的自动化脚本时，除了核心的数据提取与转换逻辑外，还应考虑加入一些<strong>辅助功能</strong>以增强脚本的鲁棒性和用户体验。其中，
<strong>完善的错误处理与日志记录机制</strong>
是必不可少的。在遍历处理每一张卡片的过程中，由于涉及文件读写、网络通信（通过AnkiConnect）、浏览器自动化（通过Puppeteer）以及DOM解析（通过JSDOM）等多个环节，各种预料之外的错误都可能发生，例如网络连接中断、Puppeteer操作超时、无法找到预期的DOM元素导致JSDOM解析失败等。因此，在主处理循环中，针对每个笔记的处理过程都应当被包裹在
<code>try...catch</code>
块内。一旦捕获到异常，脚本不应立即终止，而是应该记录下当前发生错误的笔记ID以及详细的错误信息（包括错误类型、消息和可能的堆栈跟踪）到一个专门的日志文件中。这样做的好处是，即使部分卡片处理失败，脚本也能继续尝试处理剩余的卡片，待整个流程结束后，用户可以查阅日志文件，定位问题卡片，进行针对性的排查和必要的手动干预。此外，对于一些可预见的、非致命性的“小问题”，比如源笔记中缺少某个并非绝对关键的字段，我们可以选择记录一条警告信息，并优雅地跳过该笔记的处理，而不是因为这类小瑕疵就中断整个自动化任务。</p><p>另一方面，<strong>清晰的进度提示与剩余时间估算（ETA）</strong>
对于提升用户体验也同样重要，尤其是在处理包含成百上千张卡片的大型牌组时，整个自动化过程可能会耗费相当长的时间。如果在脚本执行期间没有任何反馈，用户可能会感到焦虑或不确定脚本是否仍在正常运行。为了改善这一点，我们可以在控制台中实时输出当前的jons处理进度，例如显示“正在处理第
X / Y
个笔记&mldr;”，其中X是当前已处理的笔记数量，Y是总笔记数量。更进一步，我们还可以根据已处理笔记的平均耗时来动态估算剩余处理时间（ETA）。具体做法是，记录脚本开始处理笔记的总时间，然后在每处理完一个笔记后，计算（当前总耗时 /
已处理笔记数）得到平均单个笔记处理耗时，再乘以剩余未处理的笔记数量，即可得出一个大致的剩余时间。将这个ETA信息（例如，格式化为“预计剩余时间：HH:
MM:SS”）与进度一同输出，能给用户一个明确的预期，使等待过程不再那么盲目。</p><h2 id=处理典型模板的经验>处理典型模板的经验<a hidden class=anchor aria-hidden=true href=#处理典型模板的经验>#</a></h2><p>过往曾遇到过几类具有代表性的Anki卡片模板，它们各自在反混淆过程中呈现出不同类型的挑战。以<strong>政治复习模板</strong>
为例，其主要特点在于数据替换逻辑相对直接，卡片内容主要通过Anki的字段占位符填充到HTML结构中。然而，该模板的复杂性体现在其JavaScript部分，特别是对于选项的处理。源数据中的“选项”字段通常是以特定分隔符（例如
<code>A. xxx||B. yyy</code>）连接的单一字符串。模板内的JavaScript脚本负责解析这个字符串，将其动态地渲染成多个独立的
<code>&lt;div class="option"></code>
HTML元素，每个元素对应一个选项。因此，在自动化处理这类模板时，关键在于确保Puppeteer能够正确无误地执行这部分前端JavaScript代码。一旦JavaScript执行完毕，DOM结构更新完成，我们便可以借助JSDOM从渲染后的HTML中提取出各个选项的具体文本内容，并通过检查选项元素被赋予的CSS类来判断其是否为正确答案。此外，该模板中“解析”部分的显示逻辑也可能受到JavaScript的控制。在这种情况下，通过
<code>waitForSelector</code>等待表示选项状态（如高亮）的CSS类名出现，通常也能够间接保证“解析”内容（如果它是同步或紧随选项逻辑之后加载的话）已经被正确渲染到页面上，从而可以被JSDOM捕获。</p><p>另一类模板，如<strong>驾考题库模板</strong>，则引入了更高的复杂度，主要是因为它使用了<code>Persistence.js</code>这样的库。正如前面技术栈部分所述，
<code>Persistence.js</code>（或类似功能的库）通常用于在Anki的WebView会话中存储用户的个性化设置或卡片状态，例如用户是否偏好随机打乱选项顺序、是否希望在翻开卡片背面时默认显示“解析”内容等。这种机制带来的主要
<strong>挑战</strong>在于，如果我们的自动化脚本直接尝试渲染包含完整正反面逻辑（或者仅渲染背面，并期望其处于“答案已揭晓”状态）的模板，而没有预先在Puppeteer的浏览器环境中建立起
<code>Persistence.js</code>所依赖的那些存储项（特别是像<code>ANKI-SETTINGS-HIDE-NOTES</code>这样的关键设置），那么模板背面的JavaScript脚本（例如
<code>prepareNotes()</code>函数）可能因为无法读取到预期的设置值而不会将“解析”内容注入到对应的DOM容器（如<code>.notes-container</code>
）中。这将直接导致我们后续使用JSDOM提取数据时无法获取到“解析”信息。</p><p>针对这种依赖会话存储的模板，<strong>核心解决方案</strong>是利用Puppeteer的<code>page.evaluateOnNewDocument()</code>
方法。该方法允许我们在目标HTML页面的任何自带脚本执行之前，向页面注入自定义的JavaScript代码。我们可以借此机会，在页面上下文中创建一个
<code>Persistence</code>对象的模拟实现（mock object）。这个mock对象需要模仿真实<code>Persistence.js</code>库提供的关键API接口，例如
<code>isAvailable()</code>、<code>getItem()</code>和<code>setItem()</code>等。通过这个mock对象，我们可以主动调用
<code>Persistence.setItem('ANKI-SETTINGS-HIDE-NOTES', '0')</code>
，从而“欺骗”卡片背面的脚本，使其认为用户已经设置了“显示解析”的偏好。这样一来，模板的JavaScript逻辑就会按照预期将“解析”内容渲染到DOM中，使得JSDOM能够顺利提取。</p><p>此外，关于驾考模板的另一个值得注意的细节是<strong>选项顺序</strong>的处理。其正面模板中的<code>showFrontOptions</code>
函数有可能包含随机化选项显示顺序的逻辑，并将这个随机化后的顺序（通常是选项的原始索引序列，如<code>2,1,4,3</code>）存储在<code>Persistence</code>的
<code>ANKI-OPTIONS-ORDER</code>键中。卡片背面的<code>getOptionObjs</code>
函数在渲染选项和高亮正确答案时，会读取这个存储的顺序来确保选项文本与其原始答案标识（如数字1、2、3、4对应A、B、C、D）的正确对应。在我们的
<code>render</code>函数中，由于我们通常一次性将包含所有占位符数据的HTML模板（可能已合并正反面逻辑）提供给Puppeteer进行渲染，并且可以在
<code>evaluateOnNewDocument</code>阶段为<code>ANKI-OPTIONS-ORDER</code>预设一个确定的、非随机的选项顺序（例如，简单地设为<code>'1,2,3,4'</code>
，代表按原始顺序显示），这就保证了在卡片背面渲染时，选项内容与其对应的正确性判断之间具有稳定和可预测的关系，从而便于我们准确地提取出格式化的选项和答案。</p><h2 id=实践要点与未来展望>实践要点与未来展望<a hidden class=anchor aria-hidden=true href=#实践要点与未来展望>#</a></h2><p>在实际进行Anki卡片反混淆脚本的编写与应用时，遵循一些关键的<strong>实践要点</strong>能显著提升工作的效率和成果的可靠性。首当其冲的是*
<em>彻底的模板分析</em>*
。在投入编码之前，必须花费充足的时间在Anki环境下，借助浏览器开发者工具，深入剖析目标卡片模板的HTML结构、CSS类名的动态变化规律，以及至关重要的JavaScript执行逻辑。只有充分理解了数据如何在模板中流动和被转换，才能为后续Puppeteer的精确渲染和JSDOM的准确提取奠定坚实基础。</p><p>其次，<strong>迭代式的构建与测试</strong>
是应对复杂性的有效策略。建议将整个反混淆流程分解为若干独立模块，如模板占位符替换、Puppeteer动态渲染验证、JSDOM数据提取函数的单元测试，最后再进行端到端的AnkiConnect集成测试。这种逐步验证的方式有助于快速定位和解决问题。同时，在编写JSDOM提取规则时，应追求
<strong>CSS选择器的健壮性</strong>，优先使用ID或高度特定的类名组合，以增强脚本对模板微小变动的适应能力。</p><p>对于从卡片中提取的字段内容，要审慎<strong>区分并处理HTML格式与纯文本</strong>。根据目标卡片模板的需求，决定是提取包含HTML标签的
<code>innerHTML</code>，还是仅提取纯文本的<code>textContent</code>。特别地，Anki特有的<code>{{cloze:字段名}}</code>占位符，在迁移到同样支持完形填空的新模板时应予以保留，否则需按需处理其内容。</p><p>考虑到整个流程中文件操作、Puppeteer交互和AnkiConnect通信均涉及异步处理，<strong>精通异步操作的管理</strong>（例如，熟练运用<code>async/await</code>
）是保证脚本逻辑正确、顺序执行的关键。此外，<strong>注重资源管理</strong>
，确保Puppeteer浏览器实例在使用后能被及时关闭，以及合理使用临时文件并考虑清理，都是良好编程实践的一部分。遵循这些原则，将能更顺畅地实现卡片数据的反混淆。</p><p><strong>总结而言</strong>
，通过巧妙结合Puppeteer的动态渲染能力和JSDOM强大的DOM解析功能，我们能够有效“解开”那些依赖JavaScript进行内容生成的复杂Anki卡片。其核心在于深入理解源卡片的渲染机制，并在Puppeteer环境中精确模拟或适当地绕过这些机制，从而获取到最终的、结构化的HTML数据。对于像
<code>Persistence.js</code>这类在Anki WebView会话间持久化状态的库，利用Puppeteer的<code>page.evaluateOnNewDocument</code>
方法进行必要的环境模拟（mocking）是确保所需内容（如卡片背面的“解析”部分）能被正确渲染并提取的关键技巧。</p><p>这一反混淆过程不仅为用户提供了迁移和重用宝贵学习数据的有效途径，其本身也是一个深入学习和理解Web前端技术（HTML、CSS、JavaScript、DOM交互）以及Anki模板高级定制机制的宝贵实践机会。虽然本文提供了一套通用的解决框架和针对特定模板挑战的思路，但每一种Anki卡片模板都可能存在其独特的实现细节和复杂性。因此，面对具体的反混淆任务时，耐心细致的分析、严谨的逐步调试以及根据实际情况灵活应变，是达成目标的不可或缺的素养。</p><p><strong>展望未来</strong>
，当前述的反混淆流程和技术方法得到进一步完善和抽象后，完全有潜力被封装成更为通用的、用户友好的工具或库。这样的工具可以极大地降低普通Anki用户处理复杂卡片模板的技术门槛。更进一步，这些技术也可以被集成到更大型的Anki辅助管理系统或插件中，从而为Anki用户提供更强大的知识库管理和再利用能力，提升Anki作为个性化学习平台的整体效能。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/zh/tags/anki/>Anki</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/card-templates/>Card-Templates</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/demystification/>Demystification</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/data-extraction/>Data-Extraction</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/puppeteer/>Puppeteer</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/jsdom/>Jsdom</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ankiconnect/>Ankiconnect</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/javascript/>Javascript</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/html/>Html</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/css/>Css</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/nodejs/>Nodejs</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/typescript/>Typescript</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/web-scraping/>Web-Scraping</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/data-migration/>Data-Migration</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/template-conversion/>Template-Conversion</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/reverse-engineering/>Reverse-Engineering</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/anki-customization/>Anki-Customization</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/learning-tools/>Learning-Tools</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/spaced-repetition/>Spaced-Repetition</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/automation/>Automation</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/scripting/>Scripting</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/headless-browser/>Headless-Browser</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/dom-parsing/>Dom-Parsing</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/persistencejs/>Persistencejs</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/anki-automation/>Anki-Automation</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/knowledge-management/>Knowledge-Management</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/data-processing/>Data-Processing</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/frontend-techniques/>Frontend-Techniques</a></li></ul><nav class=paginav><a class=next href=https://tategotoazarasi.github.io/zh/posts/automating-online-grading-with-tampermonkey-and-ai/><span class=title>下一页 »</span><br><span>用Tampermonkey和AI为在线作业批改减负</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>