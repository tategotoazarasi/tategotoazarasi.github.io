<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>发现 debtap 中一个“删库跑路”级 Bug | Tategoto Azarasi</title>
<meta name=keywords content="debtap,bug,rm-rf,shell-script,bash,arch-linux,pkgbuild,dirname,debugging,git,git-blame,open-source,data-loss,linux,command-line,software-development,code-review,typo"><meta name=description content="一篇对 Arch Linux 工具 debtap 的 Bug 调查，揭示了一个看似无害的拼写错误修复，是如何意外触发了删除当前目录下所有文件的“rm -rf”致命缺陷。"><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="发现 debtap 中一个“删库跑路”级 Bug"><meta property="og:description" content="一篇对 Arch Linux 工具 debtap 的 Bug 调查，揭示了一个看似无害的拼写错误修复，是如何意外触发了删除当前目录下所有文件的“rm -rf”致命缺陷。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-06T18:02:24+08:00"><meta property="article:modified_time" content="2025-08-06T18:02:24+08:00"><meta property="article:tag" content="Debtap"><meta property="article:tag" content="Bug"><meta property="article:tag" content="Rm-Rf"><meta property="article:tag" content="Shell-Script"><meta property="article:tag" content="Bash"><meta property="article:tag" content="Arch-Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="发现 debtap 中一个“删库跑路”级 Bug"><meta name=twitter:description content="一篇对 Arch Linux 工具 debtap 的 Bug 调查，揭示了一个看似无害的拼写错误修复，是如何意外触发了删除当前目录下所有文件的“rm -rf”致命缺陷。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"发现 debtap 中一个“删库跑路”级 Bug","item":"https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"发现 debtap 中一个“删库跑路”级 Bug","name":"发现 debtap 中一个“删库跑路”级 Bug","description":"一篇对 Arch Linux 工具 debtap 的 Bug 调查，揭示了一个看似无害的拼写错误修复，是如何意外触发了删除当前目录下所有文件的“rm -rf”致命缺陷。","keywords":["debtap","bug","rm-rf","shell-script","bash","arch-linux","pkgbuild","dirname","debugging","git","git-blame","open-source","data-loss","linux","command-line","software-development","code-review","typo"],"articleBody":"故事的开头平淡无奇。我需要安装一个名为 SwashbucklerDiary 的软件，官方只提供了 .deb 包。这对于 Arch Linux 用户来说不是问题， debtap 正是为此而生。\n我像往常一样，创建了一个临时目录来处理这次转换，以免污染我的下载文件夹。\n\u003e pwd /home/myusername/Downloads/tmp \u003e ls SwashbucklerDiary-1.17.0-linux-x64.deb 一切正常。目录里只有我刚刚下载的 .deb 文件。我首先执行了标准的 debtap 命令，它顺利地生成了我想要的 pkg.tar.zst 包。\n\u003e debtap SwashbucklerDiary-1.17.0-linux-x64.deb ... (省略转换过程输出) ... ==\u003e Package successfully created! ==\u003e Removing leftover files... \u003e ls -alh total 106M drwxr-xr-x 2 myusername myusername 116 Aug 6 12:34 . drwxr-xr-x 4 myusername myusername 41 Aug 6 12:34 .. -rw-r--r-- 1 myusername root 58M Aug 6 12:34 com.yucore.swashbucklerdiary-1.17.0-1-x86_64.pkg.tar.zst -rw-r--r-- 1 myusername myusername 49M Aug 4 18:14 SwashbucklerDiary-1.17.0-linux-x64.deb 完美。转换后的包和原始的 .deb 包都在这里。但接着，我出于好奇和学习的目的，想看看 debtap 生成的 PKGBUILD 文件是什么样的。 debtap 提供了 -p 或 -P 标志来生成 PKGBUILD。于是，我删除了刚刚生成的文件，重新执行了命令，这次带上了 -p 标志。\n\u003e debtap -p SwashbucklerDiary-1.17.0-linux-x64.deb ... (同样的交互式提问) ... ==\u003e Package successfully created! ==\u003e Generating PKGBUILD file... mv: cannot stat 'PKGBUILD': No such file or directory ==\u003e PKGBUILD is now located in \"/home/myusername/Downloads/tmp\" and ready to be edited ==\u003e Removing leftover files... 输出看起来有点奇怪，有一个 mv: cannot stat 'PKGBUILD': No such file or directory 的错误，但最后它依然提示我 PKGBUILD 已经生成在当前目录了。我没有多想，习惯性地敲下了 ls -alh。\n然后，我看到了让我脊背发凉的一幕。\n\u003e ls -alh total 0 空空如也。\n我的第一反应是震惊。不仅是预期的 PKGBUILD 目录没有出现，连原始的 .deb 文件也消失了！整个 tmp 目录被清空了。\n更诡异的事情还在后面。我尝试 cd .. 然后再 cd tmp 回来，我的 shell 提示符（我用的是 Oh My Zsh + Powerlevel10k）显示出了一些奇怪的现象，似乎连目录本身的元数据都受到了影响。当我再次 ls -alh 时，我看到了更让我困惑的输出：\n\u003e ls -alh total 0 drwxr-xr-x 2 myusername myusername 6 Aug 6 12:35 . drwxr-xr-x 4 myusername myusername 41 Aug 6 12:35 .. 注意看 . 目录的大小，只有 6 字节。一个正常的、刚刚被清空的目录，在 XFS 文件系统上大小通常是 4096 字节。这太不寻常了。\n我的大脑开始飞速运转。我的 /home 目录建立在两块 SSD 组成的 RAID0 上，文件系统是 XFS。我第一个念头是：“完了，RAID0 是不是出问题了？难道这么快就坏了一块盘？” RAID0 带来的高性能是以零冗余为代价的，任何一块硬盘的故障都会导致整个阵列的数据丢失。我开始检查 dmesg 和系统日志，但没有发现任何 I/O 错误或文件系统损坏的迹象。\n排除了硬件和文件系统问题后，我冷静下来，开始怀疑 debtap 本身。既然第一次不带 -p 的运行是正常的，而第二次带了 -p 就出事了，那么问题很可能就出在这个参数上。\n我决定复现这个问题，但这次要在一个绝对安全的环境下。我新建了一个测试目录，放了几个无关紧要的触摸文件和一个 .deb 包的副本。\nmkdir ~/safe-test cd ~/safe-test touch fileA.txt fileB.log cp ~/Downloads/SwashbucklerDiary-1.17.0-linux-x64.deb . ls -l # total 49264 # -rw-r--r-- 1 myusername myusername 50442386 Aug 4 18:14 SwashbucklerDiary-1.17.0-linux-x64.deb # -rw-r--r-- 1 myusername myusername 0 Aug 6 13:00 fileA.txt # -rw-r--r-- 1 myusername myusername 0 Aug 6 13:00 fileB.log 接着，我屏住呼吸，再次执行了那条“魔鬼”命令：\ndebtap -p SwashbucklerDiary-1.17.0-linux-x64.deb 走完流程后，我再次 ls。\nls -l # total 0 结果一模一样。目录被清空了。\n至此，案情明朗了。这不是什么灵异事件，也不是硬件故障，而是 debtap 在使用 -p 或 -P 参数时，存在一个极其危险的 Bug，它会删除当前工作目录下的所有文件。\n确定了问题所在，下一步就是找出原因。debtap 是一个 shell 脚本，这让源码分析变得非常直接。我打开了 /usr/bin/debtap 文件，版本号是 3.6.2。这是一个长达三千多行的庞大脚本，直接通读显然不现实。\n我的调查思路很明确：\nBug 与 -p/-P 参数强相关。 这个参数的功能是生成 PKGBUILD。 最终现象是当前目录被删除。 所以，我需要在脚本中找到处理 -p/-P 参数，并最终生成、移动 PKGBUILD 文件的相关代码块。我直接在代码中搜索关键字 pkgbuild。\n很快，我在脚本的末尾部分，找到了生成和处理 PKGBUILD 的逻辑。\n# ... (前面是生成 PKGBUILD 内容的代码) ... # Moving PKGBUILD (and .INSTALL, if it exists) and announcing its creation pkgname=\"$(grep '^pkgname=' PKGBUILD | sed s'/^pkgname=//')\" if [[ $output == set ]]; then pkgbuild_location=\"$(dirname \"$outputdirectory/$pkgname-PKGBUILD\")\" rm -rf \"$pkgbuild_location\" 2\u003e /dev/null mkdir \"$pkgbuild_location\" 2\u003e /dev/null # ... (错误处理和移动文件的代码) ... else pkgbuild_location=\"$(dirname \"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\")\" rm -rf \"$pkgbuild_location\" 2\u003e /dev/null mkdir \"$pkgbuild_location\" 2\u003e /dev/null # ... (错误处理和移动文件的代码) ... fi 我的目光立刻被 rm -rf \"$pkgbuild_location\" 这行代码吸引住了。这无疑是最大的嫌疑犯。脚本在这里执行了一个强制递归删除操作。现在的问题是， $pkgbuild_location 这个变量的值到底是什么？\n我们来看 else 分支中的这行关键代码，因为我没有使用 -o 输出目录选项，所以程序会走到这里：\npkgbuild_location=\"$(dirname \"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\")\" 这行代码看起来有些复杂，嵌套了两层 dirname 命令。让我们来庖丁解牛，一步步分析它的执行过程。\ndirname 是一个基础的 shell 命令，它的作用是去除文件名，返回其所在的目录路径。例如：\ndirname /usr/bin/ls 会返回 /usr/bin dirname /home/user/file.txt 会返回 /home/user 现在，我们把实际的变量值代入进去。\n$package_with_full_path：这个变量在脚本开头被定义为输入 .deb 文件的绝对路径。在我的例子中，它的值是 /home/myusername/Downloads/tmp/SwashbucklerDiary-1.17.0-linux-x64.deb。 $pkgname：这个变量是从临时生成的 PKGBUILD 文件中提取的包名。根据我的日志，转换后的包名是 com.yucore.swashbucklerdiary-1.17.0-1。 现在，我们来解析那个嵌套的命令：\n第一步：执行内层的 dirname\n\"$(dirname \"$package_with_full_path\")\" # 等价于 \"$(dirname \"/home/myusername/Downloads/tmp/SwashbucklerDiary-1.17.0-linux-x64.deb\")\" 这步的输出是 .deb 文件所在的目录：/home/myusername/Downloads/tmp。\n第二步：拼接字符串\n上一步的结果会和后面的字符串拼接起来，形成一个更长的路径字符串：\n\"/home/myusername/Downloads/tmp/$pkgname-PKGBUILD\" # 代入 $pkgname 的值 \"/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD\" 这个字符串的含义是：在 .deb 文件所在的目录中，创建一个名为 包名-PKGBUILD 的……等等，这似乎是一个文件路径，而不是目录 路径。作者的意图应该是创建一个名为 包名-PKGBUILD 的目录，然后把 PKGBUILD 文件放进去。\n第三步：执行外层的 dirname\n现在，最关键的一步来了。脚本对上一步生成的整个字符串执行了外层的 dirname：\n\"$(dirname \"/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD\")\" 这个命令的输出是什么？正是 /home/myusername/Downloads/tmp！\n真相大白\n经过这三步分析，我们得到了 pkgbuild_location 变量的最终值：/home/myusername/Downloads/tmp，也就是我执行 debtap 命令时所在的 当前工作目录。\n现在再回看那几行致命的代码：\npkgbuild_location=\"/home/myusername/Downloads/tmp\" rm -rf \"$pkgbuild_location\" # 相当于执行 rm -rf \"/home/myusername/Downloads/tmp\" mkdir \"$pkgbuild_location\" # 相当于执行 mkdir \"/home/myusername/Downloads/tmp\" 谜底揭晓了。脚本先是计算出了一个错误的路径——当前工作目录，然后毫不犹豫地执行了 rm -rf，将这个目录连同其内部所有文件（包括原始的 .deb 包）一并删除。紧接着，mkdir 命令又重新创建了这个目录，这就是为什么我最后看到了一个空空如也的 tmp 目录，连目录本身的元数据都像是“初始化”了。\n这真是一个经典而又可怕的逻辑错误。作者的本意可能是想确保目标目录是一个干净的新目录，所以先删除后创建。但他错误地使用了两次 dirname，导致删除的目标从“预想中的子目录”变成了“整个当前目录”。\n找到问题根源后，我冒出了一个新的想法：这么严重的 Bug，不太可能是 debtap 一直以来就有的，否则早就被发现了。它很可能是近期才被引入的。\n我决定去 debtap 的 GitHub 仓库进行“代码考古”，看看这个 Bug 的前世今生。通过 git blame 和翻阅提交历史，我很快锁定了一个可疑的提交： commit 27a9ff5。\n这个提交的信息很简单，就是一次代码更新。我们来看看它的 diff：\ndiff --git a/debtap b/debtap index 4518a7a..71aea20 100755 --- a/debtap +++ b/debtap @@ -3458,8 +3458,8 @@ if [[ $output == set ]]; then fi else pkgbuild_location=\"$(dirname \"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\")\" - rm -rf \"$pkgbuilt_location\" 2\u003e /dev/null - mkdir \"$pkgbuilt_location\" 2\u003e /dev/null + rm -rf \"$pkgbuild_location\" 2\u003e /dev/null + mkdir \"$pkgbuild_location\" 2\u003e /dev/null if [[ $? != 0 ]]; then echo -e \"${red}Error: Cannot create PKGBUILD directory to the same directory as .deb package, permission denied. Removing leftover files and exiting...${NC}\" rm -rf \"$working_directory\" 看到这里，我恍然大悟，甚至有点哭笑不得。\n在这次提交之前，代码是这样的：\nrm -rf \"$pkgbuilt_location\" 2\u003e /dev/null mkdir \"$pkgbuilt_location\" 2\u003e /dev/null 注意看变量名：pkgbuilt_location。而上面定义变量时用的是 pkgbuild_location。这是一个拼写错误！\n在 shell 脚本中，如果引用一个不存在的变量（比如因为拼写错误），它会扩展成一个空字符串。所以，在 27a9ff5 这个提交之前，实际执行的命令是：\nrm -rf \"\" 2\u003e /dev/null mkdir \"\" 2\u003e /dev/null rm -rf \"\" 和 mkdir \"\" 都不会产生任何效果，也不会报错。因此，那个有逻辑缺陷的 dirname 虽然计算出了错误的路径，但由于这个拼写错误，它从未被用在 rm -rf 命令中。这个拼写错误，就像一个保险丝，阴差阳错地保护了无数用户的数据安全。\n而 commit 27a9ff5 的作者，很可能是在代码审查时发现了这个拼写错误，本着“修正代码”的好意，将 pkgbuilt_location 改成了正确的 pkgbuild_location。他“修复”了这个拼写错误，却无意中接通了那根引爆炸弹的引线。\n这是一个教科书级别的案例，告诉我们一个看似微不足道的、善意的修改，如果没有完全理解其上下文和潜在影响，也可能导致灾难性的后果。\n发现了问题的来龙去脉后，我意识到必须尽快将此问题报告给项目维护者，以防更多用户遭殃。我立刻在 debtap 的 GitHub 仓库创建了一个新的 Issue。\nIssue 提交后，很快得到了社区的回应。有其他用户证实他们也遇到了同样的问题，其中一位用户庆幸自己没有在 $HOME 目录下运行这个命令。这再次凸显了问题的严重性。\n项目维护者 helixarch 很快注意到了这个问题，并在几天后发布了修复。我们来看一下修复这个 Bug 的核心 diff：\n--- a/debtap +++ b/debtap @@ -3486,7 +3486,7 @@ if [[ $output == set ]]; then echo -e \"${lightgreen}==\u003e${NC} ${bold}PKGBUILD is now located in${normal} ${lightblue}\\\"$pkgbuild_location\\\"${NC} ${bold}and ready to be edited${normal}\" fi else - pkgbuild_location=\"$(dirname \"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\")\" + pkgbuild_location=\"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\" rm -rf \"$pkgbuild_location\" 2\u003e /dev/null mkdir \"$pkgbuild_location\" 2\u003e /dev/null if [[ $? != 0 ]]; then 修复方案非常直接、优雅。维护者移除了外层的 dirname。\n现在，pkgbuild_location 的计算方式变成了：\npkgbuild_location=\"\"$(dirname \"$package_with_full_path\")\"/$pkgname-PKGBUILD\" 我们再来走一遍流程：\ndirname \"$package_with_full_path\" 仍然是 /home/myusername/Downloads/tmp。 拼接后的字符串是 /home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD。 这个值现在被直接赋给了 pkgbuild_location。于是，后续的命令变成了：\nrm -rf \"/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD\" mkdir \"/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD\" 这正是我们期望的行为！脚本现在会正确地在当前目录下创建一个新的、干净的子目录，用来存放 PKGBUILD 文件，而不会再对当前目录本身造成任何威胁。\n随着 debtap 3.6.3 版本的发布，这个惊心动魄的 Bug 终于被修复了。\n","wordCount":"745","inLanguage":"zh","datePublished":"2025-08-06T18:02:24+08:00","dateModified":"2025-08-06T18:02:24+08:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">发现 debtap 中一个“删库跑路”级 Bug</h1><div class=post-meta><span title='2025-08-06 18:02:24 +0800 +0800'>八月 6, 2025</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;745 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/en/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/>En</a></li></ul></div></header><div class=post-content><p>故事的开头平淡无奇。我需要安装一个名为 <code>SwashbucklerDiary</code> 的软件，官方只提供了 <code>.deb</code> 包。这对于 Arch Linux 用户来说不是问题，
<code>debtap</code> 正是为此而生。</p><p>我像往常一样，创建了一个临时目录来处理这次转换，以免污染我的下载文件夹。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; pwd
</span></span><span style=display:flex><span>/home/myusername/Downloads/tmp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; ls
</span></span><span style=display:flex><span>SwashbucklerDiary-1.17.0-linux-x64.deb
</span></span></code></pre></div><p>一切正常。目录里只有我刚刚下载的 <code>.deb</code> 文件。我首先执行了标准的 <code>debtap</code> 命令，它顺利地生成了我想要的 <code>pkg.tar.zst</code> 包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; debtap SwashbucklerDiary-1.17.0-linux-x64.deb
</span></span><span style=display:flex><span>... <span style=color:#f92672>(</span>省略转换过程输出<span style=color:#f92672>)</span> ...
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; Package successfully created!
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; Removing leftover files...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; ls -alh
</span></span><span style=display:flex><span>total 106M
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>2</span> myusername myusername <span style=color:#ae81ff>116</span> Aug  <span style=color:#ae81ff>6</span> 12:34 .
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>4</span> myusername myusername  <span style=color:#ae81ff>41</span> Aug  <span style=color:#ae81ff>6</span> 12:34 ..
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> myusername root        58M Aug  <span style=color:#ae81ff>6</span> 12:34 com.yucore.swashbucklerdiary-1.17.0-1-x86_64.pkg.tar.zst
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> myusername myusername 49M Aug  <span style=color:#ae81ff>4</span> 18:14 SwashbucklerDiary-1.17.0-linux-x64.deb
</span></span></code></pre></div><p>完美。转换后的包和原始的 <code>.deb</code> 包都在这里。但接着，我出于好奇和学习的目的，想看看 <code>debtap</code> 生成的 <code>PKGBUILD</code> 文件是什么样的。
<code>debtap</code> 提供了 <code>-p</code> 或 <code>-P</code> 标志来生成 <code>PKGBUILD</code>。于是，我删除了刚刚生成的文件，重新执行了命令，这次带上了 <code>-p</code> 标志。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; debtap -p SwashbucklerDiary-1.17.0-linux-x64.deb
</span></span><span style=display:flex><span>... <span style=color:#f92672>(</span>同样的交互式提问<span style=color:#f92672>)</span> ...
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; Package successfully created!
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; Generating PKGBUILD file...
</span></span><span style=display:flex><span>mv: cannot stat <span style=color:#e6db74>&#39;PKGBUILD&#39;</span>: No such file or directory
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; PKGBUILD is now located in <span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp&#34;</span> and ready to be edited
</span></span><span style=display:flex><span><span style=color:#f92672>==</span>&gt; Removing leftover files...
</span></span></code></pre></div><p>输出看起来有点奇怪，有一个 <code>mv: cannot stat 'PKGBUILD': No such file or directory</code> 的错误，但最后它依然提示我 <code>PKGBUILD</code>
已经生成在当前目录了。我没有多想，习惯性地敲下了 <code>ls -alh</code>。</p><p>然后，我看到了让我脊背发凉的一幕。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; ls -alh
</span></span><span style=display:flex><span>total <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>空空如也。</p><p>我的第一反应是震惊。不仅是预期的 <code>PKGBUILD</code> 目录没有出现，连原始的 <code>.deb</code> 文件也消失了！整个 <code>tmp</code> 目录被清空了。</p><p>更诡异的事情还在后面。我尝试 <code>cd ..</code> 然后再 <code>cd tmp</code> 回来，我的 shell 提示符（我用的是 Oh My Zsh +
Powerlevel10k）显示出了一些奇怪的现象，似乎连目录本身的元数据都受到了影响。当我再次 <code>ls -alh</code> 时，我看到了更让我困惑的输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; ls -alh
</span></span><span style=display:flex><span>total <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>2</span> myusername myusername  <span style=color:#ae81ff>6</span> Aug  <span style=color:#ae81ff>6</span> 12:35 .
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>4</span> myusername myusername <span style=color:#ae81ff>41</span> Aug  <span style=color:#ae81ff>6</span> 12:35 ..
</span></span></code></pre></div><p>注意看 <code>.</code> 目录的大小，只有 6 字节。一个正常的、刚刚被清空的目录，在 XFS 文件系统上大小通常是 4096 字节。这太不寻常了。</p><p>我的大脑开始飞速运转。我的 <code>/home</code> 目录建立在两块 SSD 组成的 RAID0 上，文件系统是 XFS。我第一个念头是：“完了，RAID0
是不是出问题了？难道这么快就坏了一块盘？” RAID0 带来的高性能是以零冗余为代价的，任何一块硬盘的故障都会导致整个阵列的数据丢失。我开始检查
<code>dmesg</code> 和系统日志，但没有发现任何 I/O 错误或文件系统损坏的迹象。</p><p>排除了硬件和文件系统问题后，我冷静下来，开始怀疑 <code>debtap</code> 本身。既然第一次不带 <code>-p</code> 的运行是正常的，而第二次带了 <code>-p</code>
就出事了，那么问题很可能就出在这个参数上。</p><p>我决定复现这个问题，但这次要在一个绝对安全的环境下。我新建了一个测试目录，放了几个无关紧要的触摸文件和一个 <code>.deb</code> 包的副本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir ~/safe-test
</span></span><span style=display:flex><span>cd ~/safe-test
</span></span><span style=display:flex><span>touch fileA.txt fileB.log
</span></span><span style=display:flex><span>cp ~/Downloads/SwashbucklerDiary-1.17.0-linux-x64.deb .
</span></span><span style=display:flex><span>ls -l
</span></span><span style=display:flex><span><span style=color:#75715e># total 49264</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 myusername myusername 50442386 Aug  4 18:14 SwashbucklerDiary-1.17.0-linux-x64.deb</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 myusername myusername        0 Aug  6 13:00 fileA.txt</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -rw-r--r-- 1 myusername myusername        0 Aug  6 13:00 fileB.log</span>
</span></span></code></pre></div><p>接着，我屏住呼吸，再次执行了那条“魔鬼”命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>debtap -p SwashbucklerDiary-1.17.0-linux-x64.deb
</span></span></code></pre></div><p>走完流程后，我再次 <code>ls</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l
</span></span><span style=display:flex><span><span style=color:#75715e># total 0</span>
</span></span></code></pre></div><p>结果一模一样。目录被清空了。</p><p>至此，案情明朗了。这不是什么灵异事件，也不是硬件故障，而是 <code>debtap</code> 在使用 <code>-p</code> 或 <code>-P</code> 参数时，存在一个极其危险的
Bug，它会删除当前工作目录下的所有文件。</p><p>确定了问题所在，下一步就是找出原因。<code>debtap</code> 是一个 shell 脚本，这让源码分析变得非常直接。我打开了 <code>/usr/bin/debtap</code> 文件，版本号是
<code>3.6.2</code>。这是一个长达三千多行的庞大脚本，直接通读显然不现实。</p><p>我的调查思路很明确：</p><ol><li>Bug 与 <code>-p</code>/<code>-P</code> 参数强相关。</li><li>这个参数的功能是生成 <code>PKGBUILD</code>。</li><li>最终现象是当前目录被删除。</li></ol><p>所以，我需要在脚本中找到处理 <code>-p</code>/<code>-P</code> 参数，并最终生成、移动 <code>PKGBUILD</code> 文件的相关代码块。我直接在代码中搜索关键字
<code>pkgbuild</code>。</p><p>很快，我在脚本的末尾部分，找到了生成和处理 <code>PKGBUILD</code> 的逻辑。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># ... (前面是生成 PKGBUILD 内容的代码) ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Moving PKGBUILD (and .INSTALL, if it exists) and announcing its creation</span>
</span></span><span style=display:flex><span>pkgname<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>grep <span style=color:#e6db74>&#39;^pkgname=&#39;</span> PKGBUILD | sed s<span style=color:#e6db74>&#39;/^pkgname=//&#39;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $output <span style=color:#f92672>==</span> set <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    pkgbuild_location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;</span>$outputdirectory<span style=color:#e6db74>/</span>$pkgname<span style=color:#e6db74>-PKGBUILD&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    rm -rf <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>    mkdir <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... (错误处理和移动文件的代码) ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    pkgbuild_location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;</span>$package_with_full_path<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;/</span>$pkgname<span style=color:#e6db74>-PKGBUILD&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    rm -rf <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>    mkdir <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... (错误处理和移动文件的代码) ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>我的目光立刻被 <code>rm -rf "$pkgbuild_location"</code> 这行代码吸引住了。这无疑是最大的嫌疑犯。脚本在这里执行了一个强制递归删除操作。现在的问题是，
<code>$pkgbuild_location</code> 这个变量的值到底是什么？</p><p>我们来看 <code>else</code> 分支中的这行关键代码，因为我没有使用 <code>-o</code> 输出目录选项，所以程序会走到这里：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pkgbuild_location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;</span>$package_with_full_path<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;/</span>$pkgname<span style=color:#e6db74>-PKGBUILD&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>这行代码看起来有些复杂，嵌套了两层 <code>dirname</code> 命令。让我们来庖丁解牛，一步步分析它的执行过程。</p><p><code>dirname</code> 是一个基础的 shell 命令，它的作用是去除文件名，返回其所在的目录路径。例如：</p><ul><li><code>dirname /usr/bin/ls</code> 会返回 <code>/usr/bin</code></li><li><code>dirname /home/user/file.txt</code> 会返回 <code>/home/user</code></li></ul><p>现在，我们把实际的变量值代入进去。</p><ol><li><strong><code>$package_with_full_path</code></strong>：这个变量在脚本开头被定义为输入 <code>.deb</code> 文件的绝对路径。在我的例子中，它的值是
<code>/home/myusername/Downloads/tmp/SwashbucklerDiary-1.17.0-linux-x64.deb</code>。</li><li><strong><code>$pkgname</code></strong>：这个变量是从临时生成的 <code>PKGBUILD</code> 文件中提取的包名。根据我的日志，转换后的包名是
<code>com.yucore.swashbucklerdiary-1.17.0-1</code>。</li></ol><p>现在，我们来解析那个嵌套的命令：</p><p><strong>第一步：执行内层的 <code>dirname</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;</span>$package_with_full_path<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等价于</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/SwashbucklerDiary-1.17.0-linux-x64.deb&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>这步的输出是 <code>.deb</code> 文件所在的目录：<code>/home/myusername/Downloads/tmp</code>。</p><p><strong>第二步：拼接字符串</strong></p><p>上一步的结果会和后面的字符串拼接起来，形成一个更长的路径字符串：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/</span>$pkgname<span style=color:#e6db74>-PKGBUILD&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 代入 $pkgname 的值</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD&#34;</span>
</span></span></code></pre></div><p>这个字符串的含义是：在 <code>.deb</code> 文件所在的目录中，创建一个名为 <code>包名-PKGBUILD</code> 的……等等，这似乎是一个<strong>文件</strong>路径，而不是<strong>目录
<strong>路径。作者的意图应该是创建一个名为 <code>包名-PKGBUILD</code> 的</strong>目录</strong>，然后把 <code>PKGBUILD</code> 文件放进去。</p><p><strong>第三步：执行外层的 <code>dirname</code></strong></p><p>现在，最关键的一步来了。脚本对上一步生成的整个字符串执行了外层的 <code>dirname</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>这个命令的输出是什么？正是 <code>/home/myusername/Downloads/tmp</code>！</p><p><strong>真相大白</strong></p><p>经过这三步分析，我们得到了 <code>pkgbuild_location</code> 变量的最终值：<code>/home/myusername/Downloads/tmp</code>，也就是我执行 <code>debtap</code> 命令时所在的
<strong>当前工作目录</strong>。</p><p>现在再回看那几行致命的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pkgbuild_location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp&#34;</span>
</span></span><span style=display:flex><span>rm -rf <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span>  <span style=color:#75715e># 相当于执行 rm -rf &#34;/home/myusername/Downloads/tmp&#34;</span>
</span></span><span style=display:flex><span>mkdir <span style=color:#e6db74>&#34;</span>$pkgbuild_location<span style=color:#e6db74>&#34;</span> <span style=color:#75715e># 相当于执行 mkdir &#34;/home/myusername/Downloads/tmp&#34;</span>
</span></span></code></pre></div><p>谜底揭晓了。脚本先是计算出了一个错误的路径——当前工作目录，然后毫不犹豫地执行了 <code>rm -rf</code>，将这个目录连同其内部所有文件（包括原始的
<code>.deb</code> 包）一并删除。紧接着，<code>mkdir</code> 命令又重新创建了这个目录，这就是为什么我最后看到了一个空空如也的 <code>tmp</code>
目录，连目录本身的元数据都像是“初始化”了。</p><p>这真是一个经典而又可怕的逻辑错误。作者的本意可能是想确保目标目录是一个干净的新目录，所以先删除后创建。但他错误地使用了两次
<code>dirname</code>，导致删除的目标从“预想中的子目录”变成了“整个当前目录”。</p><p>找到问题根源后，我冒出了一个新的想法：这么严重的 Bug，不太可能是 <code>debtap</code> 一直以来就有的，否则早就被发现了。它很可能是近期才被引入的。</p><p>我决定去 <code>debtap</code> 的 GitHub 仓库进行“代码考古”，看看这个 Bug 的前世今生。通过 <code>git blame</code> 和翻阅提交历史，我很快锁定了一个可疑的提交：
<strong>commit <code>27a9ff5</code></strong>。</p><p>这个提交的信息很简单，就是一次代码更新。我们来看看它的 <code>diff</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/debtap b/debtap
</span></span><span style=display:flex><span>index 4518a7a..71aea20 100755
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/debtap
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/debtap
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -3458,8 +3458,8 @@ if [[ $output == set ]]; then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fi
</span></span><span style=display:flex><span> else
</span></span><span style=display:flex><span>    pkgbuild_location=&#34;$(dirname &#34;&#34;$(dirname &#34;$package_with_full_path&#34;)&#34;/$pkgname-PKGBUILD&#34;)&#34;
</span></span><span style=display:flex><span><span style=color:#f92672>-   rm -rf &#34;$pkgbuilt_location&#34; 2&gt; /dev/null
</span></span></span><span style=display:flex><span><span style=color:#f92672>-   mkdir &#34;$pkgbuilt_location&#34; 2&gt; /dev/null
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+   rm -rf &#34;$pkgbuild_location&#34; 2&gt; /dev/null
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+   mkdir &#34;$pkgbuild_location&#34; 2&gt; /dev/null
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>    if [[ $? != 0 ]]; then
</span></span><span style=display:flex><span>        echo -e &#34;${red}Error: Cannot create PKGBUILD directory to the same directory as .deb package, permission denied. Removing leftover files and exiting...${NC}&#34;
</span></span><span style=display:flex><span>        rm -rf &#34;$working_directory&#34;
</span></span></code></pre></div><p>看到这里，我恍然大悟，甚至有点哭笑不得。</p><p>在这次提交之前，代码是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf <span style=color:#e6db74>&#34;</span>$pkgbuilt_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>mkdir <span style=color:#e6db74>&#34;</span>$pkgbuilt_location<span style=color:#e6db74>&#34;</span> 2&gt; /dev/null
</span></span></code></pre></div><p>注意看变量名：<code>pkgbuilt_location</code>。而上面定义变量时用的是 <code>pkgbuild_location</code>。这是一个<strong>拼写错误</strong>！</p><p>在 shell 脚本中，如果引用一个不存在的变量（比如因为拼写错误），它会扩展成一个空字符串。所以，在 <code>27a9ff5</code> 这个提交之前，实际执行的命令是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf <span style=color:#e6db74>&#34;&#34;</span> 2&gt; /dev/null
</span></span><span style=display:flex><span>mkdir <span style=color:#e6db74>&#34;&#34;</span> 2&gt; /dev/null
</span></span></code></pre></div><p><code>rm -rf ""</code> 和 <code>mkdir ""</code> 都不会产生任何效果，也不会报错。因此，那个有逻辑缺陷的 <code>dirname</code> 虽然计算出了错误的路径，但由于这个拼写错误，它从未被用在
<code>rm -rf</code> 命令中。这个拼写错误，就像一个保险丝，阴差阳错地保护了无数用户的数据安全。</p><p>而 <strong>commit <code>27a9ff5</code></strong> 的作者，很可能是在代码审查时发现了这个拼写错误，本着“修正代码”的好意，将 <code>pkgbuilt_location</code> 改成了正确的
<code>pkgbuild_location</code>。他“修复”了这个拼写错误，却无意中接通了那根引爆炸弹的引线。</p><p>这是一个教科书级别的案例，告诉我们一个看似微不足道的、善意的修改，如果没有完全理解其上下文和潜在影响，也可能导致灾难性的后果。</p><p>发现了问题的来龙去脉后，我意识到必须尽快将此问题报告给项目维护者，以防更多用户遭殃。我立刻在 <code>debtap</code> 的 GitHub 仓库创建了一个新的
Issue。</p><p>Issue 提交后，很快得到了社区的回应。有其他用户证实他们也遇到了同样的问题，其中一位用户庆幸自己没有在 <code>$HOME</code>
目录下运行这个命令。这再次凸显了问题的严重性。</p><p>项目维护者 helixarch 很快注意到了这个问题，并在几天后发布了修复。我们来看一下修复这个 Bug 的核心 <code>diff</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>--- a/debtap
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/debtap
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -3486,7 +3486,7 @@ if [[ $output == set ]]; then
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        echo -e &#34;${lightgreen}==&gt;${NC} ${bold}PKGBUILD is now located in${normal} ${lightblue}\&#34;$pkgbuild_location\&#34;${NC} ${bold}and ready to be edited${normal}&#34;
</span></span><span style=display:flex><span>    fi
</span></span><span style=display:flex><span> else
</span></span><span style=display:flex><span><span style=color:#f92672>-   pkgbuild_location=&#34;$(dirname &#34;&#34;$(dirname &#34;$package_with_full_path&#34;)&#34;/$pkgname-PKGBUILD&#34;)&#34;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+   pkgbuild_location=&#34;&#34;$(dirname &#34;$package_with_full_path&#34;)&#34;/$pkgname-PKGBUILD&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>    rm -rf &#34;$pkgbuild_location&#34; 2&gt; /dev/null
</span></span><span style=display:flex><span>    mkdir &#34;$pkgbuild_location&#34; 2&gt; /dev/null
</span></span><span style=display:flex><span>    if [[ $? != 0 ]]; then
</span></span></code></pre></div><p>修复方案非常直接、优雅。维护者<strong>移除了外层的 <code>dirname</code></strong>。</p><p>现在，<code>pkgbuild_location</code> 的计算方式变成了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pkgbuild_location<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#66d9ef>$(</span>dirname <span style=color:#e6db74>&#34;</span>$package_with_full_path<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;/</span>$pkgname<span style=color:#e6db74>-PKGBUILD&#34;</span>
</span></span></code></pre></div><p>我们再来走一遍流程：</p><ol><li><code>dirname "$package_with_full_path"</code> 仍然是 <code>/home/myusername/Downloads/tmp</code>。</li><li>拼接后的字符串是 <code>/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD</code>。</li></ol><p>这个值现在被直接赋给了 <code>pkgbuild_location</code>。于是，后续的命令变成了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf <span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD&#34;</span>
</span></span><span style=display:flex><span>mkdir <span style=color:#e6db74>&#34;/home/myusername/Downloads/tmp/com.yucore.swashbucklerdiary-1.17.0-1-PKGBUILD&#34;</span>
</span></span></code></pre></div><p>这正是我们期望的行为！脚本现在会正确地在当前目录下创建一个新的、干净的子目录，用来存放 <code>PKGBUILD</code> 文件，而不会再对当前目录本身造成任何威胁。</p><p>随着 <code>debtap 3.6.3</code> 版本的发布，这个惊心动魄的 Bug 终于被修复了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/zh/tags/debtap/>Debtap</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/bug/>Bug</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/rm-rf/>Rm-Rf</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/shell-script/>Shell-Script</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/bash/>Bash</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/arch-linux/>Arch-Linux</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/pkgbuild/>Pkgbuild</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/dirname/>Dirname</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/debugging/>Debugging</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/git/>Git</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/git-blame/>Git-Blame</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/open-source/>Open-Source</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/data-loss/>Data-Loss</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/linux/>Linux</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/command-line/>Command-Line</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/software-development/>Software-Development</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/code-review/>Code-Review</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/typo/>Typo</a></li></ul><nav class=paginav><a class=next href=https://tategotoazarasi.github.io/zh/posts/troubleshooting-a-stubborn-dmic-on-a-thinkbook-16-g7-plus-asp-with-linux/><span class=title>下一页 »</span><br><span>解决 ThinkBook 16 G7+ ASP 在 Linux 系统下数字麦克风的顽固问题</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>