<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Tategoto Azarasi</title>
    <link>https://blog.tategotoazarasi.me/zh/posts/</link>
    <description>Recent content in Posts on Tategoto Azarasi</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 11 Jan 2026 02:15:47 +0000</lastBuildDate>
    <atom:link href="https://blog.tategotoazarasi.me/zh/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HPC 矩阵乘法性能基准测试分析</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/matrix-multiplication-benchmark-hpc-cuda-python/</link>
      <pubDate>Sun, 11 Jan 2026 02:15:47 +0000</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/matrix-multiplication-benchmark-hpc-cuda-python/</guid>
      <description>本文分析了英特尔至强CPU和NVIDIA V100 GPU上的矩阵乘法基准测试结果，对比了C++、OpenMP、CUDA、MPI、NVSHMEM及Python框架的计算性能。</description>
    </item>
    <item>
      <title>在 HPC 集群上复现 RetinaSim</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/reproducing-retinasim-on-hpc-cluster/</link>
      <pubDate>Sun, 28 Dec 2025 23:38:53 +0000</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/reproducing-retinasim-on-hpc-cluster/</guid>
      <description>深入记录在一个高性能计算（HPC）集群上复现复杂的多语言生物医学模拟项目 RetinaSim 的全过程，详解从编译错误调试到无头渲染环境适配的每一个技术细节。</description>
    </item>
    <item>
      <title>打造数据驱动的城市：利用 Python 整合住房、治安与社会剥夺指标</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/</link>
      <pubDate>Wed, 03 Dec 2025 20:32:25 +0000</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/building-a-data-driven-city-python-gis-visualization/</guid>
      <description>本文复盘了如何利用 Python、Geopandas 和 Folium 将住房规划、治安数据与社会经济指标融合，构建支持动态权重的城市决策可视化系统。</description>
    </item>
    <item>
      <title>将我的大学课程表导入个人日历：一次手动 API 探索与 iCalendar 文件生成实践</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/</link>
      <pubDate>Sun, 09 Nov 2025 22:32:33 +0000</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/reverse-engineering-a-university-timetable-api-to-generate-an-ics-file-with-python/</guid>
      <description>本文详细介绍如何利用浏览器开发者工具分析大学课程表网站的内部 API，通过 Python 脚本将获取到的 JSON 格式课表数据转换为通用的 iCalendar (.ics) 文件，从而一键导入到任何个人日历应用中。</description>
    </item>
    <item>
      <title>构建一个能应对复杂反爬机制的 TypeScript 视频下载器</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/</link>
      <pubDate>Sun, 09 Nov 2025 19:33:20 +0000</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/building-a-resilient-typescript-video-downloader-against-advanced-anti-scraping/</guid>
      <description>记录了如何使用 TypeScript、Node.js 和 Playwright 从零开始构建一个能够应对复杂反爬机制、动态加载和网络竞态条件的健壮视频下载器。</description>
    </item>
    <item>
      <title>Uol 2025 Wk3 &amp;&amp; LeetCode Biweekly Contest 168 题解</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/uol-2025-wk3/</link>
      <pubDate>Sat, 25 Oct 2025 17:55:44 +0100</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/uol-2025-wk3/</guid>
      <description>&lt;h2 id=&#34;weak-vertices-弱顶点&#34;&gt;Weak Vertices (弱顶点)&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在图论中，一个网络的结构强度通常可以通过识别其中的基本形状（如三角形）来分析。三角形能提供结构刚性，是许多应用中常见的母题。这个问题要求我们识别那些&lt;em&gt;不属于&lt;/em&gt;任何三角形的顶点。一个顶点 &lt;code&gt;i&lt;/code&gt; 被定义为属于一个三角形，如果它有两个不同的邻居 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，并且 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 彼此之间也是邻居。我们的任务是找出所有不满足此条件的顶点，问题将其称为“弱顶点”。图以邻接矩阵的形式给出。&lt;/p&gt;
&lt;h3 id=&#34;我的代码&#34;&gt;我的代码&lt;/h3&gt;
&lt;p&gt;我的方法是对定义进行直接模拟。对每个顶点，我遍历其所有邻居对，并检查它们之间是否相连。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 遍历从 0 到 n-1 的每个顶点 `i`，检查它是否是弱顶点。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 一个标志位，用于追踪顶点 `i` 是否属于任何三角形。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 我们将其初始化为 true，假设 `i` 是弱顶点，直到找到反证。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历 `i` 的所有邻居。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 外层循环选择第一个邻居 `j`。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;siblings[i].size(); j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 内层循环选择第二个邻居 `k`。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 我们从 j+1 开始，以确保每对邻居只被考虑一次。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; k&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;siblings[i].size(); k&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 检查 `i` 的两个邻居，即 `siblings[i][j]` 和 `siblings[i][k]`，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 是否相互连接。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(graph[siblings[i][j]][siblings[i][k]]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果它们相连，那么顶点 `i`、`j` 和 `k` 构成一个三角形。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 因此，顶点 `i` 不是弱顶点。我们将标志位设为 false。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 既然已经找到了一个涉及 `i` 的三角形，我们可以停止对该顶点的检查。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果标志位已被设为 false，我们也可以跳出外层的邻居循环。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;flag) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 如果在检查完所有邻居对后，标志位仍然为 true，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这意味着没有找到涉及 `i` 的三角形。因此，`i` 是一个弱顶点。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(flag) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;我的解法及其正确性&#34;&gt;我的解法及其正确性&lt;/h3&gt;
&lt;p&gt;这个问题要求我们识别给定无向图中所有不属于任何三角形的顶点。如果一个顶点满足这个条件，它就被认为是“弱”的。图的结构通过一个 $n \times n$ 的邻接矩阵给出，其中 $n$ 是顶点的数量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Uol 2025 Wk2 题解</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/uol-2025-wk2/</link>
      <pubDate>Wed, 01 Oct 2025 21:47:12 +0100</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/uol-2025-wk2/</guid>
      <description>&lt;h2 id=&#34;recount&#34;&gt;Recount&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！&lt;/p&gt;
&lt;p&gt;在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！&lt;/p&gt;
&lt;h4 id=&#34;输入&#34;&gt;输入&lt;/h4&gt;
&lt;p&gt;输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符
&lt;code&gt;***&lt;/code&gt; 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。&lt;/p&gt;
&lt;h4 id=&#34;输出&#34;&gt;输出&lt;/h4&gt;
&lt;p&gt;如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“
&lt;code&gt;Runoff!&lt;/code&gt;”（别忘了包含感叹号！）&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unordered_map&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// using namespace std; // 为简洁起见，在单个文件中可以如此使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; recount {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(istream &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cin, ostream &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cout) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 unordered_map 存储每位候选人的票数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string line;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 逐行读取选票，直到遇到哨兵值 &amp;#34;***&amp;#34;。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;getline(cin, line)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(line &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;***&amp;#34;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 为当前行所指的候选人增加票数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            m[line]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string ans             &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;***&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 使用哨兵值来检查是否存在平局。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; max_vote &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第一遍遍历：找出所有候选人中的最高票数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;[k, v]&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; m) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            max_vote &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;max(max_vote, v);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第二遍遍历：找出获得最高票数的候选人。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;[k, v]&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; m) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(v &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; max_vote) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果 &amp;#39;ans&amp;#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 此时再找到一个说明存在平局。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ans &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;***&amp;#34;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Runoff!&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 在打印平局结果后退出。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 这是找到的第一个获得最高票数的候选人。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果循环完成且 &amp;#39;ans&amp;#39; 只被更新过一次，则打印获胜者的名字。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ans;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;p&gt;这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff!
”。投票列表以一个特殊的字符串 &lt;code&gt;***&lt;/code&gt; 结尾。&lt;/p&gt;</description>
    </item>
    <item>
      <title>发现 debtap 中一个“删库跑路”级 Bug</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/</link>
      <pubDate>Wed, 06 Aug 2025 18:02:24 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/</guid>
      <description>一篇对 Arch Linux 工具 &lt;code&gt;debtap&lt;/code&gt; 的 Bug 调查，揭示了一个看似无害的拼写错误修复，是如何意外触发了删除当前目录下所有文件的“rm -rf”致命缺陷。</description>
    </item>
    <item>
      <title>解决 ThinkBook 16 G7&#43; ASP 在 Linux 系统下数字麦克风的顽固问题</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/troubleshooting-a-stubborn-dmic-on-a-thinkbook-16-g7-plus-asp-with-linux/</link>
      <pubDate>Sat, 24 May 2025 21:32:30 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/troubleshooting-a-stubborn-dmic-on-a-thinkbook-16-g7-plus-asp-with-linux/</guid>
      <description>记录了在联想 ThinkBook 16 G7+ ASP (AMD Ryzen AI 9) 笔记本上解决 Linux 系统下数字麦克风无声问题的详细过程，主要通过添加内核模块参数 &lt;code&gt;options snd_sof_amd_common enable_pdm=1&lt;/code&gt; 实现</description>
    </item>
    <item>
      <title>深入Anki卡片内部：反混淆技术与数据提取实践</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/</link>
      <pubDate>Fri, 16 May 2025 21:58:20 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/delving-into-anki-cards-demystifying-templates-for-data-extraction-and-practical-application/</guid>
      <description>深入解析复杂Anki卡片模板的反混淆技术，通过Puppeteer和JSDOM实现动态渲染内容的精准数据提取与迁移。</description>
    </item>
    <item>
      <title>用Tampermonkey和AI为在线作业批改减负</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/automating-online-grading-with-tampermonkey-and-ai/</link>
      <pubDate>Fri, 02 May 2025 17:16:19 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/automating-online-grading-with-tampermonkey-and-ai/</guid>
      <description>记录了如何使用Tampermonkey脚本和百度文心AI为在线作业批改（特别是简答题）提供自动化辅助，以减轻教师重复性评分和评语工作的负担。</description>
    </item>
    <item>
      <title>矩阵乘法性能测试：从三重循环到百 GFLOPS (AMD Ryzen AI &#43; Radeon 平台实测)</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/matrix-multiplication-performance-benchmark-from-triple-loops-to-100-plus-gflops-on-amd-ryzen-ai-radeon/</link>
      <pubDate>Sat, 19 Apr 2025 20:33:11 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/matrix-multiplication-performance-benchmark-from-triple-loops-to-100-plus-gflops-on-amd-ryzen-ai-radeon/</guid>
      <description>深度对比11种矩阵乘法实现（从Naive到CPU SIMD、多核、BLAS及GPU加速如OpenCL/HIP/Vulkan）在AMD Ryzen AI + Radeon平台上的巨大性能差异与优化关键。</description>
    </item>
    <item>
      <title>信号驱动的桥接演进：使用 Boost.Signals2 优化 C&#43;&#43; EnTT 与 Rust WASM 交互</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/</link>
      <pubDate>Mon, 07 Apr 2025 21:50:58 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/beyond-basic-bridging-robust-eventing-between-cpp-entt-and-rust-wasm-with-boost-signals2/</guid>
      <description>重构 C++ EnTT 宿主与 Rust WASM 插件架构，将自定义事件替换为 Boost.Signals2，通过 Wasmtime 实现健壮、解耦的 FFI 通信与高级宿主-插件交互。</description>
    </item>
    <item>
      <title>使用 EnTT 在 C&#43;&#43; Host 与 Rust WASM 插件间实现灵活的关系管理</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/bridging-the-gap-flexible-relationship-management-between-cpp-host-and-rust-wasm-plugins-using-entt/</link>
      <pubDate>Sun, 06 Apr 2025 19:32:52 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/bridging-the-gap-flexible-relationship-management-between-cpp-host-and-rust-wasm-plugins-using-entt/</guid>
      <description>使用 Wasmtime 和稳定 C FFI，在 C++ Host 中通过 EnTT 管理实体关系，并允许 Rust WebAssembly (WASM) 插件安全交互，利用数据驱动设计克服 WASM 边界限制。</description>
    </item>
    <item>
      <title>深入探索 Wasmtime：C&#43;&#43; 与 Rust Wasm 模块的双向通信与内存共享</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/</link>
      <pubDate>Sun, 06 Apr 2025 16:34:33 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/deep-dive-into-wasmtime-bidirectional-communication-and-memory-sharing-between-cpp-and-rust-wasm-modules/</guid>
      <description>一篇详细的技术指南，介绍如何使用 Wasmtime 运行时在 C++ 宿主应用程序与 Rust WebAssembly 模块之间实现复杂的双向通信、共享内存访问和结构体传递。</description>
    </item>
    <item>
      <title>在 EnTT 中优雅地处理实体关系：从 1:1 到 N:N</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/weaving-the-web-managing-entity-relationships-in-entt/</link>
      <pubDate>Sat, 05 Apr 2025 20:07:37 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/weaving-the-web-managing-entity-relationships-in-entt/</guid>
      <description>详细探讨了如何在 EnTT 中使用组件优雅地表示和管理 1:1、1:N 和 N:N 的实体关系，并通过代码示例展示了 CRUD 操作的实现。</description>
    </item>
    <item>
      <title>给 Breezy Weather 添加一个“全家桶”样式的新小部件：ClockDayHourWeekWidget 开发记录</title>
      <link>https://blog.tategotoazarasi.me/zh/posts/clock-day-hour-week-widget/</link>
      <pubDate>Sun, 30 Mar 2025 16:40:50 +0800</pubDate>
      <guid>https://blog.tategotoazarasi.me/zh/posts/clock-day-hour-week-widget/</guid>
      <description>一篇详细指南，介绍如何为Breezy Weather应用添加一个集时钟、日预报和小时预报于一体的“ClockDayHourWeekWidget”安卓小部件。</description>
    </item>
  </channel>
</rss>
