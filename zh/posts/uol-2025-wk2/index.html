<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Uol 2025 Wk2 题解 | Tategoto Azarasi</title>
<meta name=keywords content="recount-problem-solution,set-card-game-solver,planting-trees-problem-solution,competitive-programming,c-plus-plus,algorithm-tutorial,data-structures-and-algorithms,bilingual-guide,greedy-algorithm,brute-force-search,hash-map-example,vote-counting-algorithm,combinatorial-game-programming,scheduling-optimization,time-complexity-analysis,space-complexity,exchange-argument-proof,coding-challenges,problem-solving-guide,chinese-english-programming-tutorial,c-plus-plus-code-explanation"><meta name=description content='Recount
问题描述
最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！
在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！
输入
输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符
*** 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。
输出
如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“
Runoff!”（别忘了包含感叹号！）
代码
#include <iostream>
#include <string>
#include <unordered_map>
#include <algorithm>

// using namespace std; // 为简洁起见，在单个文件中可以如此使用

namespace recount {
    int main(istream &amp;cin, ostream &amp;cout) {
        // 使用 unordered_map 存储每位候选人的票数。
        // 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。
        std::unordered_map<std::string, unsigned long> m = std::unordered_map<std::string, unsigned long>();
        std::string line;

        // 逐行读取选票，直到遇到哨兵值 "***"。
        while(std::getline(cin, line)) {
            if(line == "***") {
                break;
            }
            // 为当前行所指的候选人增加票数。
            // 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。
            m[line]++;
        }

        // 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。
        std::string ans             = "***"; // 使用哨兵值来检查是否存在平局。
        unsigned long max_vote = 0;

        // 第一遍遍历：找出所有候选人中的最高票数。
        for(const auto &[k, v]: m) {
            max_vote = std::max(max_vote, v);
        }

        // 第二遍遍历：找出获得最高票数的候选人。
        for(const auto &[k, v]: m) {
            if(v == max_vote) {
                // 如果 &#39;ans&#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。
                // 此时再找到一个说明存在平局。
                if(ans != "***") {
                    cout << "Runoff!";
                    return 0; // 在打印平局结果后退出。
                }
                // 这是找到的第一个获得最高票数的候选人。
                ans = k;
            }
        }
        // 如果循环完成且 &#39;ans&#39; 只被更新过一次，则打印获胜者的名字。
        cout << ans;

        return 0;
    }
}
题解
这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff!
”。投票列表以一个特殊的字符串 *** 结尾。'><meta name=author content="Tategoto Azarasi"><link rel=canonical href=https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://tategotoazarasi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tategotoazarasi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tategotoazarasi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tategotoazarasi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tategotoazarasi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/><link rel=alternate hreflang=zh href=https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ rel=stylesheet><script crossorigin=anonymous defer integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script crossorigin=anonymous defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR onload=renderMathInElement(document.body) src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js></script>>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/"><meta property="og:site_name" content="Tategoto Azarasi"><meta property="og:title" content="Uol 2025 Wk2 题解"><meta property="og:description" content='Recount 问题描述 最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！
在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！
输入 输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符 *** 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。
输出 如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“ Runoff!”（别忘了包含感叹号！）
代码 #include <iostream> #include <string> #include <unordered_map> #include <algorithm> // using namespace std; // 为简洁起见，在单个文件中可以如此使用 namespace recount { int main(istream &amp;cin, ostream &amp;cout) { // 使用 unordered_map 存储每位候选人的票数。 // 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。 std::unordered_map<std::string, unsigned long> m = std::unordered_map<std::string, unsigned long>(); std::string line; // 逐行读取选票，直到遇到哨兵值 "***"。 while(std::getline(cin, line)) { if(line == "***") { break; } // 为当前行所指的候选人增加票数。 // 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。 m[line]++; } // 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。 std::string ans = "***"; // 使用哨兵值来检查是否存在平局。 unsigned long max_vote = 0; // 第一遍遍历：找出所有候选人中的最高票数。 for(const auto &[k, v]: m) { max_vote = std::max(max_vote, v); } // 第二遍遍历：找出获得最高票数的候选人。 for(const auto &[k, v]: m) { if(v == max_vote) { // 如果 &#39;ans&#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。 // 此时再找到一个说明存在平局。 if(ans != "***") { cout << "Runoff!"; return 0; // 在打印平局结果后退出。 } // 这是找到的第一个获得最高票数的候选人。 ans = k; } } // 如果循环完成且 &#39;ans&#39; 只被更新过一次，则打印获胜者的名字。 cout << ans; return 0; } } 题解 这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff! ”。投票列表以一个特殊的字符串 *** 结尾。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-01T21:47:12+01:00"><meta property="article:modified_time" content="2025-10-01T21:47:12+01:00"><meta property="article:tag" content="Recount-Problem-Solution"><meta property="article:tag" content="Set-Card-Game-Solver"><meta property="article:tag" content="Planting-Trees-Problem-Solution"><meta property="article:tag" content="Competitive-Programming"><meta property="article:tag" content="C-Plus-Plus"><meta property="article:tag" content="Algorithm-Tutorial"><meta name=twitter:card content="summary"><meta name=twitter:title content="Uol 2025 Wk2 题解"><meta name=twitter:description content='Recount
问题描述
最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！
在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！
输入
输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符
*** 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。
输出
如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“
Runoff!”（别忘了包含感叹号！）
代码
#include <iostream>
#include <string>
#include <unordered_map>
#include <algorithm>

// using namespace std; // 为简洁起见，在单个文件中可以如此使用

namespace recount {
    int main(istream &amp;cin, ostream &amp;cout) {
        // 使用 unordered_map 存储每位候选人的票数。
        // 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。
        std::unordered_map<std::string, unsigned long> m = std::unordered_map<std::string, unsigned long>();
        std::string line;

        // 逐行读取选票，直到遇到哨兵值 "***"。
        while(std::getline(cin, line)) {
            if(line == "***") {
                break;
            }
            // 为当前行所指的候选人增加票数。
            // 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。
            m[line]++;
        }

        // 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。
        std::string ans             = "***"; // 使用哨兵值来检查是否存在平局。
        unsigned long max_vote = 0;

        // 第一遍遍历：找出所有候选人中的最高票数。
        for(const auto &[k, v]: m) {
            max_vote = std::max(max_vote, v);
        }

        // 第二遍遍历：找出获得最高票数的候选人。
        for(const auto &[k, v]: m) {
            if(v == max_vote) {
                // 如果 &#39;ans&#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。
                // 此时再找到一个说明存在平局。
                if(ans != "***") {
                    cout << "Runoff!";
                    return 0; // 在打印平局结果后退出。
                }
                // 这是找到的第一个获得最高票数的候选人。
                ans = k;
            }
        }
        // 如果循环完成且 &#39;ans&#39; 只被更新过一次，则打印获胜者的名字。
        cout << ans;

        return 0;
    }
}
题解
这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff!
”。投票列表以一个特殊的字符串 *** 结尾。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tategotoazarasi.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"Uol 2025 Wk2 题解","item":"https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Uol 2025 Wk2 题解","name":"Uol 2025 Wk2 题解","description":"Recount 问题描述 最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！\n在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！\n输入 输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符 *** 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。\n输出 如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“ Runoff!”（别忘了包含感叹号！）\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;algorithm\u0026gt; // using namespace std; // 为简洁起见，在单个文件中可以如此使用 namespace recount { int main(istream \u0026amp;cin, ostream \u0026amp;cout) { // 使用 unordered_map 存储每位候选人的票数。 // 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。 std::unordered_map\u0026lt;std::string, unsigned long\u0026gt; m = std::unordered_map\u0026lt;std::string, unsigned long\u0026gt;(); std::string line; // 逐行读取选票，直到遇到哨兵值 \u0026#34;***\u0026#34;。 while(std::getline(cin, line)) { if(line == \u0026#34;***\u0026#34;) { break; } // 为当前行所指的候选人增加票数。 // 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。 m[line]++; } // 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。 std::string ans = \u0026#34;***\u0026#34;; // 使用哨兵值来检查是否存在平局。 unsigned long max_vote = 0; // 第一遍遍历：找出所有候选人中的最高票数。 for(const auto \u0026amp;[k, v]: m) { max_vote = std::max(max_vote, v); } // 第二遍遍历：找出获得最高票数的候选人。 for(const auto \u0026amp;[k, v]: m) { if(v == max_vote) { // 如果 \u0026#39;ans\u0026#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。 // 此时再找到一个说明存在平局。 if(ans != \u0026#34;***\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Runoff!\u0026#34;; return 0; // 在打印平局结果后退出。 } // 这是找到的第一个获得最高票数的候选人。 ans = k; } } // 如果循环完成且 \u0026#39;ans\u0026#39; 只被更新过一次，则打印获胜者的名字。 cout \u0026lt;\u0026lt; ans; return 0; } } 题解 这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff! ”。投票列表以一个特殊的字符串 *** 结尾。\n","keywords":["recount-problem-solution","set-card-game-solver","planting-trees-problem-solution","competitive-programming","c-plus-plus","algorithm-tutorial","data-structures-and-algorithms","bilingual-guide","greedy-algorithm","brute-force-search","hash-map-example","vote-counting-algorithm","combinatorial-game-programming","scheduling-optimization","time-complexity-analysis","space-complexity","exchange-argument-proof","coding-challenges","problem-solving-guide","chinese-english-programming-tutorial","c-plus-plus-code-explanation"],"articleBody":"Recount 问题描述 最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！\n在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！\n输入 输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符 *** 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。\n输出 如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“ Runoff!”（别忘了包含感叹号！）\n代码 #include #include #include #include // using namespace std; // 为简洁起见，在单个文件中可以如此使用 namespace recount { int main(istream \u0026cin, ostream \u0026cout) { // 使用 unordered_map 存储每位候选人的票数。 // 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。 std::unordered_map\u003cstd::string, unsigned long\u003e m = std::unordered_map\u003cstd::string, unsigned long\u003e(); std::string line; // 逐行读取选票，直到遇到哨兵值 \"***\"。 while(std::getline(cin, line)) { if(line == \"***\") { break; } // 为当前行所指的候选人增加票数。 // 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。 m[line]++; } // 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。 std::string ans = \"***\"; // 使用哨兵值来检查是否存在平局。 unsigned long max_vote = 0; // 第一遍遍历：找出所有候选人中的最高票数。 for(const auto \u0026[k, v]: m) { max_vote = std::max(max_vote, v); } // 第二遍遍历：找出获得最高票数的候选人。 for(const auto \u0026[k, v]: m) { if(v == max_vote) { // 如果 'ans' 不再是哨兵值，意味着我们已经找到了一个获胜者。 // 此时再找到一个说明存在平局。 if(ans != \"***\") { cout \u003c\u003c \"Runoff!\"; return 0; // 在打印平局结果后退出。 } // 这是找到的第一个获得最高票数的候选人。 ans = k; } } // 如果循环完成且 'ans' 只被更新过一次，则打印获胜者的名字。 cout \u003c\u003c ans; return 0; } } 题解 这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff! ”。投票列表以一个特殊的字符串 *** 结尾。\n为了解决这个问题，我们需要一种高效的方式来存储和统计可能非常多的不同候选人的票数。哈希表（或字典）是完成此任务的理想数据结构。在 C++ 中，std::unordered_map 就是哈希表的实现。我们可以将每个候选人的名字（std::string）映射到他们的总票数（一个整数类型，如 unsigned long）。\n整体算法主要分为三个阶段：\n首先，我们读取输入并统计票数。我们逐行遍历输入。对于每一行，也就是一张选票，我们检查它是否是终止符 *** 。如果是，我们停止读取。否则，我们用候选人的名字作为 unordered_map 的键，并增加其对应的值。std::unordered_map 的 [] 操作符在这里非常方便：如果键（名字）在哈希表中不存在，它会自动插入并赋予一个默认构造的值（对于整数是0），然后自增操作 ++ 使其变为1。如果键已经存在，它的值就简单地加一。\n其次，处理完所有选票后，我们需要确定所有候选人中获得的最高票数是多少。我们可以通过遍历哈希表中的所有键值对，并记录下到目前为止看到的最大值（票数）来实现这一点。我们将这个最大值称为 max_vote。\n第三，我们必须确定获胜者或检测是否存在平局。在寻找最大值的同时可靠地完成这项任务仅用一次遍历是不够的。因此，最简单明了的方法是对哈希表进行第二次遍历。在第二次迭代中，我们将每个候选人的票数与上一步中找到的 max_vote 进行比较。我们使用一个字符串变量，比如 winner_name，并将其初始化为一个特殊的哨兵值（例如输入中的 *** ，因为它不可能是合法的候选人名字）。当我们找到第一个票数等于 max_vote 的候选人时，我们将其名字存储在 winner_name 中。如果随后我们又遇到了另一位票数也等于 max_vote 的候选人，我们就知道出现了平局。此时，我们可以立即打印 “Runoff!” 并终止程序。如果第二次循环完成而没有找到第二个票数等于 max_vote 的候选人，那就意味着有唯一的获胜者，其名字已存储在我们的 winner_name 变量中。然后我们打印这个名字。\n复杂度分析 设 N 为总投票数，C 为独立候选人的人数。设 L 为候选人名字的最大长度。\n时间复杂度 这个过程可以分解为三个部分。\n读取选票并填充哈希表：我们循环 N 次。在循环内部，std::getline 需要 O(L) 的时间。使用字符串键访问 unordered_map 需要对字符串进行哈希计算，平均情况下需要 O(L) 的时间。因此，这个阶段的平均时间复杂度为 O(N * L)。 找到最高票数：我们遍历存储在哈希表中的 C 位独立候选人。这需要 O(C) 的时间。 确定获胜者或平局：我们再次遍历 C 位独立候选人，这也需要 O(C) 的时间。 总时间复杂度是这些部分的总和：O(N * L + C + C) = O(N * L + C)。由于独立候选人的人数 C 不能超过总投票数 N（即 C ≤ N），复杂度主要由第一阶段决定，最终的平均时间复杂度为 O(N * L)。\n空间复杂度 主要的内存使用来自 unordered_map。在最坏的情况下，每一票都投给了不同的候选人，这意味着我们将存储 N 个不同的名字。哈希表所需的空间与独立候选人的人数 (C) 以及他们名字长度的总和成正比。在最坏的情况下，这会是 O(N * L)，即我们存储了 N 个平均长度为 L 的名字。因此，空间复杂度为 O(N * L)。\nSet 问题描述 Set是一款由Marsha Falco于1974年设计的纸牌游戏，由Set Enterprises, Inc.公司推广。它也以联合供稿的形式出现在《纽约时报》的网站上。玩家会看到12张牌，每张牌上包含1、2或3个符号。这些符号可以是菱形、波浪形或椭圆形。符号的绘制风格有实心、条纹或空心三种。每个符号的颜色可以是红色、绿色或紫色。在任意一张牌上，所有符号的类型、颜色和填充风格都是相同的。\n要构成一个“Set”，你必须选择三张牌，这三张牌的全部4个特性必须满足“要么全部相同，要么两两不同”的规则。例如，有3张牌，第一张显示2个红色条纹椭圆，第二张显示3个绿色条纹波浪形，第三张显示1个紫色条纹菱形，这就构成了一个“Set”。它们的符号数量分别为2、3和1（每个数量都不同）；形状分别为椭圆、波浪形和菱形（每种形状都不同）；颜色为红色、绿色和紫色（3种不同颜色）；最后，它们都共享相同的填充风格：条纹。\n请编写一个程序，找出给定的12张牌中所有的“Set”！\n输入 你的程序的输入将包括4行，每行包含3个字符串，代表3张牌。每个字符串由四个字符ABCD组成，其中\nA ∈ {1, 2, 3}，对应符号的数量。\nB ∈ {D, S, O}，对应菱形(D)、波浪形(S)和椭圆(O)。\nC ∈ {S, T, O}，对应实心(S)、条纹(T)和空心(O)的填充风格。\nD ∈ {R, G, P}，对应红色(R)、绿色(G)和紫色(P)。\n可以认为输入中的卡牌排列如下： +———-+ | 1 2 3 | | 4 5 6 | | 7 8 9 | | 10 11 12 | +———-+\n输出 输出你找到的所有“Set”，每行一个。对于每个“Set”，按排序顺序输出其中卡牌的编号。所有找到的“Set”应根据其第一张牌的编号进行排序，如果第一张牌编号相同，则按第二张和第三张牌的编号来打破平局。 如果无法构成任何“Set”，则输出“no sets”。\n代码 #include #include #include #include #include #include namespace set { std::vector\u003cstd::vector\u003cint\u003e\u003e ans = {}; class card { public: int id; char f[4]; card(int id, std::string s); }; class cardset { public: unsigned short mask = -1; int cnt = 0; std::unordered_set\u003ccard *\u003e cards{}; cardset() = default; cardset(card *c); void insert(card *c); }; cardset::cardset(card *c) { this-\u003ecards.insert(c); this-\u003ecnt = 1; } unsigned short calc_mask(card *c1, card *c2) { unsigned short mask = 0; for(int i = 0; i \u003c 4; i++) { mask \u003c\u003c= 1; mask |= c1-\u003ef[i] == c2-\u003ef[i]; } return mask; } card::card(int id, std::string s) { this-\u003eid = id; std::istringstream iss(s); iss \u003e\u003e this-\u003ef[0] \u003e\u003e this-\u003ef[1] \u003e\u003e this-\u003ef[2] \u003e\u003e this-\u003ef[3]; } void cardset::insert(card *c) { if(this-\u003emask == (unsigned short) (-1)) { this-\u003emask = calc_mask(c, *this-\u003ecards.begin()); } this-\u003ecards.insert(c); this-\u003ecnt++; if(this-\u003ecnt == 3) { std::vector\u003cint\u003e vec = {}; for(auto \u0026card_ptr: this-\u003ecards) { vec.emplace_back(card_ptr-\u003eid); } std::sort(vec.begin(), vec.end()); ans.emplace_back(vec); } } bool fit(card *c, const cardset *s) { if(s-\u003emask == (unsigned short) (-1)) { return true; } for(auto \u0026sc: s-\u003ecards) { if(calc_mask(sc, c) != s-\u003emask) { return false; } } return true; } int main(std::istream \u0026cin, std::ostream \u0026cout) { cardset sets[1 \u003c\u003c 10] = {}; int sets_cnt = 0; std::string input; for(int i = 1; i \u003c= 12; i++) { cin \u003e\u003e input; card *newcard = new card(i, input); for(int j = 0; j \u003c sets_cnt; j++) { if(fit(newcard, \u0026sets[j])) { cardset newset = sets[j]; newset.insert(newcard); sets[sets_cnt++] = (newset); } } cardset newset = cardset(newcard); sets[sets_cnt++] = (newset); } if(ans.size() == 0) { cout \u003c\u003c \"no sets\"; return 0; } std::sort(ans.begin(), ans.end(), [](const std::vector\u003cint\u003e \u0026a, const std::vector\u003cint\u003e \u0026b) { if(a[0] != b[0]) { return a[0] \u003c b[0]; } else if(a[1] != b[1]) { return a[1] \u003c b[1]; } else { return a[2] \u003c b[2]; } }); for(const auto \u0026s: ans) { cout \u003c\u003c s[0] \u003c\u003c ' ' \u003c\u003c s[1] \u003c\u003c ' ' \u003c\u003c s[2] \u003c\u003c std::endl; } return 0; } } 题解 这个问题要求我们从给定的12张卡牌中找出所有有效的“Set”。一个“Set”由三张卡牌组成，对于它们的四个特征中的任何一个，特征值要么是三张牌都完全相同，要么是三张牌两两互不相同。\n这里的C++代码实现了一种构造性或增量式算法来寻找这些“Set”。它不是通过检查所有可能的三张牌组合（暴力方法），而是通过一次添加一张牌来逐步构建潜在的“Set”。\n其核心逻辑巧妙地利用了位掩码（bitmasking）来表示两张卡牌之间的关系。函数 calc_mask(card *c1, card *c2) 生成一个4位的整数。每一位对应四个特征中的一个。如果两张牌在该特征上相同，则该位设置为 1；如果不同，则为 0 。这个“相似性掩码”紧凑地描述了两张牌的相互关系。\n使用这个掩码，三张牌（A, B, C）构成一个“Set”的规则可以被重新表述为：A和B之间的相似性掩码必须与A和C之间的相似性掩码相同，并且也必须与B和C之间的相似性掩码相同。这确保了每个特征都满足“全部相同或全部不同”的属性。\n主算法的流程如下：\n它从第1张到第12张，逐一处理卡牌。它维护一个数组 sets，用于存储 cardset 对象。一个 cardset 是一个潜在的“Set”，可以包含一张或两张卡牌。\n对于每个新读入的卡牌 newcard：\n它会遍历所有已经创建的 cardset 对象 (sets[j])。一个 cardset 的大小可以是1（单张牌）或2（一对牌）。 函数 fit(newcard, \u0026sets[j]) 检查 newcard 是否可以有效地添加到现有的 cardset 中。 如果 sets[j] 只包含一张牌，任何 newcard 都可以“fit”以形成一个对。一个大小为2的新 cardset 会由此创建。它的 mask 成员此时被计算并存储，代表这两张牌之间的相似性。 如果 sets[j] 包含两张牌，fit 函数会检查 newcard 与 sets[j] 中两张牌的相似性掩码是否都与 sets[j] 中已存储的 mask 相匹配。如果匹配，那么一个有效的三张牌“Set”就找到了。一个大小为3的新 cardset 被创建，其卡牌ID被添加到全局的 ans 向量中。 在尝试扩展所有现有的 cardset 之后，一个只包含 newcard 的新 cardset 会被创建并添加到列表中。这使得 newcard 能够与后续处理的卡牌开始新的潜在“Set”。 在所有12张卡牌都处理完毕后，ans 向量就包含了所有找到的“Set”。然后代码检查是否找到了任何“Set”。如果没有，则打印 “no sets” 。否则，它按照题目要求的字典序对“Set”列表进行排序，并每行打印一个“Set”。\n复杂度分析 设 N 为卡牌数量（N=12）。\n时间复杂度 外层循环运行 N 次。内层循环遍历 sets_cnt，即已存在的 cardset 的数量。处理完 i 张牌后，大小为1的 cardset 数量为 i ，大小为2的数量为 i*(i-1)/2。因此 sets_cnt 是二次增长的，即 O(i^2)。总工作量大约是从 i=1 到 N-1 对 i^2 求和，这导致时间复杂度为 O(N^3)。对于 N=12，这是非常高效的。\n空间复杂度 sets 数组存储了所有的 cardset 对象。这些对象的数量是 O(N^2)。每个 cardset 存储指针，所以空间主要由数组本身主导，导致 O(N^2) 的空间复杂度。\nPlanting Trees 问题描述 农夫乔恩最近买了n棵树苗，他想把它们种在院子里。乔恩种植一棵树苗需要1天时间，并且对于每棵树，乔恩都确切地知道它在种植后需要多少天才能完全成熟。乔恩还想为他的农夫朋友们举办一个派对，但为了给他们留下深刻印象，他希望只在所有树都长成之后才组织派对。更准确地说，派对最早可以在最后一棵树长成后的第二天举办。\n请帮助乔恩找出可以举办派对的最早日期。乔恩可以随心所欲地选择种植树木的顺序，因此他希望以一种能让派对尽早举行的方式来种植树木。\n输入 输入包含两行。第一行包含一个整数 N (1 ≤ N ≤ 100,000)，表示树苗的数量。接下来的一行是 N 个整数 t_i (1 ≤ t_i ≤ 1,000,000)，其中 t_i 表示第 i 棵树生长所需的天数。\n输出 你的程序应该输出一行，包含一个整数，表示可以组织派对的最早日期。天数从当前时刻开始编号为 1, 2, 3, …。\n代码 #include #include #include namespace plantingtrees { int main(std::istream \u0026cin, std::ostream \u0026cout) { int n; cin \u003e\u003e n; std::vector\u003cint\u003e vec(n); for(int i = 0; i \u003c n; i++) { cin \u003e\u003e vec[i]; } // 将树的生长时间按降序排序。 // rbegin() 和 rend() 迭代器用于反向排序。 std::sort(vec.rbegin(), vec.rend()); int ans = 0; // 按照选定的种植顺序遍历树木。 // 位于索引 'i' 的树在第 'i + 1' 天被种植。 for(int i = 0; i \u003c n; i++) { // 种植日: i + 1 // 生长时间: vec[i] // 成熟日: (i + 1) + vec[i] // 派对必须在所有树成熟后举行，所以我们寻找最晚的成熟日。 // 派对在最后一棵树成熟后的第二天举行。 // 值 `i + vec[i] + 2` 对应 `(i + 1) + vec[i] + 1`， // 如果这棵树是最后一棵成熟的，这就是最早可能的派对日期。 ans = std::max(ans, i + vec[i] + 2); } cout \u003c\u003c ans; return 0; } } 题解 这个问题要求我们找出举办派对的最早可能日期。派对必须在所有种植的树木都成熟后的第二天举行。我们有N棵树苗，并且知道每棵树苗在种植后需要 t_i 天才能成熟。种植一棵树苗需要一天。我们可以决定种植的顺序。目标是找到一个种植顺序，使得最终的派对日期最小化。\n让我们分析一下时间线。如果我们确定了种植顺序，第一棵树在第1天种植，第二棵在第2天，以此类推，序列中的第 i 棵树在第 i 天种植。如果这第 i 棵树的成熟时间是 t_i，它将在第 i + t_i 天完全成熟。派对只能在所有 树木都成熟后举行。这意味着我们需要在所有树中找到最晚的成熟日期。派对可以在这个最晚成熟日期的第二天举行。 因此，对于一个给定的种植序列 p_1, p_2, ..., p_N 及其对应的生长时间 t_{p_1}, t_{p_2}, ..., t_{p_N}，派对日期将是 1 + max(1 + t_{p_1}, 2 + t_{p_2}, ..., N + t_{p_N})。我们的任务是找到树木的一个排序（一个排列 p），以最小化这个值。\n这个问题可以用贪心算法解决。直觉告诉我们，需要较长时间生长的树应该尽早种植。这给了它们漫长成熟期的“领先优势”。相反，生长快的树可以稍后种植，而不会显著推迟最终的完成日期。\n让我们来证明这个贪心策略是最优的。该策略是：将树木按其生长时间 t_i 的降序排序，并按此顺序种植。 考虑任何一个最优的种植计划。如果这个计划不是按生长时间降序排列的，那么在种植序列中，必然至少存在一对相邻的树，比如在第 i 天和第 i+1 天种植的树，其中第 i 天种植的树（称之为树A，生长时间为 t_A）的生长时间比第 i+1 天种植的树（树B，生长时间为 t_B）要短。即 t_A \u003c t_B。\n在这个计划中，这两棵树的成熟日期是：\n树A的成熟日期：i + t_A\n树B的成熟日期：(i + 1) + t_B\n序列中所有其他的树不受我们对A和B操作的影响。该计划的最晚成熟日期是 max(..., i + t_A, (i + 1) + t_B, ...)。\n现在，让我们交换A和B的种植顺序。我们在第 i 天种植B，第 i+1 天种植A。新的成熟日期是：\n树B的新成熟日期：i + t_B\n树A的新成熟日期：(i + 1) + t_A\n让我们比较交换前后这对树的最晚成熟日期。 交换前，最晚的是 max(i + t_A, i + 1 + t_B)。因为 t_A \u003c t_B，所以 t_A \u003c= t_B - 1。 因此，i + t_A \u003c i + t_B - 1 \u003c i + 1 + t_B。最大值是 i + 1 + t_B。 交换后，最晚的是 max(i + t_B, i + 1 + t_A)。 因为 t_A \u003c t_B，所以 i + 1 + t_A \u003c i + 1 + t_B。并且如果 t_B - t_A \u003e 1，i + t_B 也大于 i + 1 + t_A。无论如何，最大值是 i + t_B。\n比较最大值：(i + t_B) (交换后) vs. (i + 1 + t_B) (交换前)。 很明显，i + t_B \u003c i + 1 + t_B。交换减少了这对树的最晚成熟日期。由于所有其他树的成熟日期保持不变，整个计划的总体最晚成熟日期只能减少或保持不变，不可能增加。 这个“交换论证”表明，我们总是可以通过将生长时间较长的树提前来改进或维持一个未排序的计划。通过反复应用这个逻辑，我们可以将任何最优计划转换为一个按生长时间降序排列的计划，而不会使结果变差。因此，优先种植生长时间长的树的贪心策略确实是最优的。\n实现很简单：\n读取N和所有的生长时间 t_i 到一个向量中。 将向量按降序排序。 初始化一个变量 max_party_day 为0。 从 i = 0 到 N-1 遍历排序后的向量。树 t_i 在第 i+1 天种植。它的成熟日期是 (i+1) + t_i。考虑到这棵树，最早的派对日期是 (i+1) + t_i + 1。我们用 max_party_day 的当前值和这个新计算出的日期的最大值来更新它。 循环结束后，max_party_day 将持有最终答案。 复杂度分析 设N为树苗的数量。\n时间复杂度 主要的操作是对生长时间进行排序。标准排序算法需要 O(N log N) 的时间。读取输入需要 O(N) 的时间，最后的循环计算最大派对日期也需要 O(N) 的时间。因此，总时间复杂度为 O(N log N)。\n空间复杂度 我们需要将N个生长时间存储在一个向量中，这需要 O(N) 的空间。\n","wordCount":"1145","inLanguage":"zh","datePublished":"2025-10-01T21:47:12+01:00","dateModified":"2025-10-01T21:47:12+01:00","author":{"@type":"Person","name":"Tategoto Azarasi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tategotoazarasi.github.io/zh/posts/uol-2025-wk2/"},"publisher":{"@type":"Organization","name":"Tategoto Azarasi","logo":{"@type":"ImageObject","url":"https://tategotoazarasi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tategotoazarasi.github.io/zh/ accesskey=h title="Tategoto Azarasi (Alt + H)">Tategoto Azarasi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://tategotoazarasi.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://tategotoazarasi.github.io/zh/ title=首页><span>首页</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/ title=Tags><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tategotoazarasi.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://tategotoazarasi.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Uol 2025 Wk2 题解</h1><div class=post-meta><span title='2025-10-01 21:47:12 +0100 +0100'>十月 1, 2025</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;1145 字&nbsp;·&nbsp;Tategoto Azarasi&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://tategotoazarasi.github.io/en/posts/uol-2025-wk2/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ol><li><a href=#recount>Recount</a><ol><li><a href=#问题描述>问题描述</a><ol><li><a href=#输入>输入</a></li><li><a href=#输出>输出</a></li></ol></li><li><a href=#代码>代码</a></li><li><a href=#题解>题解</a></li><li><a href=#复杂度分析>复杂度分析</a><ol><li><a href=#时间复杂度>时间复杂度</a></li><li><a href=#空间复杂度>空间复杂度</a></li></ol></li></ol></li><li><a href=#set>Set</a><ol><li><a href=#问题描述-1>问题描述</a><ol><li><a href=#输入-1>输入</a></li><li><a href=#输出-1>输出</a></li></ol></li><li><a href=#代码-1>代码</a></li><li><a href=#题解-1>题解</a></li><li><a href=#复杂度分析-1>复杂度分析</a><ol><li><a href=#时间复杂度-1>时间复杂度</a></li><li><a href=#空间复杂度-1>空间复杂度</a></li></ol></li></ol></li><li><a href=#planting-trees>Planting Trees</a><ol><li><a href=#问题描述-2>问题描述</a><ol><li><a href=#输入-2>输入</a></li><li><a href=#输出-2>输出</a></li></ol></li><li><a href=#代码-2>代码</a></li><li><a href=#题解-2>题解</a></li><li><a href=#复杂度分析-2>复杂度分析</a><ol><li><a href=#时间复杂度-2>时间复杂度</a></li><li><a href=#空间复杂度-2>空间复杂度</a></li></ol></li></ol></li></ol></nav></div></details></div><div class=post-content><h2 id=recount>Recount<a hidden class=anchor aria-hidden=true href=#recount>#</a></h2><h3 id=问题描述>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述>#</a></h3><p>最近的学校董事会选举竞争异常激烈：提案内容包括互换中小学的上学时间，一项备受争议的禁止在校穿着运动服的新着装规定，以及一项旨在提高房地产税以资助新橄榄球训练设施的提案，诸如此类的议题层出不穷。现在，距离投票站关闭已过去数小时，但获胜者仍未揭晓！</p><p>在绝望之中，选举官员们求助于您，请您编写一个程序来统计选票！</p><h4 id=输入>输入<a hidden class=anchor aria-hidden=true href=#输入>#</a></h4><p>输入包含一个单一的测试用例，即一张已投选票的列表。输入中的每一行都包含一位被投票的候选人的名字。一个名字可能由多个单词组成，以空格分隔。单词包含字母或连字符，但不含其他标点符号。列表中至少有2张选票。选票列表以包含字符
<code>***</code> 的单行结束。这一行不应被计入票数。最多可以有100,000张有效选票。</p><h4 id=输出>输出<a hidden class=anchor aria-hidden=true href=#输出>#</a></h4><p>如果某位候选人获得了简单多数或绝对多数的选票（即，票数超过任何其他候选人），则输出这位候选人的名字！如果没有候选人获得简单多数，则输出：“
<code>Runoff!</code>”（别忘了包含感叹号！）</p><h3 id=代码>代码<a hidden class=anchor aria-hidden=true href=#代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// using namespace std; // 为简洁起见，在单个文件中可以如此使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> recount {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(istream <span style=color:#f92672>&amp;</span>cin, ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 unordered_map 存储每位候选人的票数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 键是候选人的名字（字符串），值是他们的票数（无符号长整型）。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> m <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>unordered_map<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string line;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 逐行读取选票，直到遇到哨兵值 &#34;***&#34;。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(std<span style=color:#f92672>::</span>getline(cin, line)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(line <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;***&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 为当前行所指的候选人增加票数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 如果候选人尚不存在于哈希表中，则会以计票数为1被添加进去。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            m[line]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化一个字符串来存放获胜者的名字，以及一个变量用于存放最高票数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>string ans             <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;***&#34;</span>; <span style=color:#75715e>// 使用哨兵值来检查是否存在平局。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> max_vote <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 第一遍遍历：找出所有候选人中的最高票数。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>[k, v]<span style=color:#f92672>:</span> m) {
</span></span><span style=display:flex><span>            max_vote <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(max_vote, v);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 第二遍遍历：找出获得最高票数的候选人。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>[k, v]<span style=color:#f92672>:</span> m) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>==</span> max_vote) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果 &#39;ans&#39; 不再是哨兵值，意味着我们已经找到了一个获胜者。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 此时再找到一个说明存在平局。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span>(ans <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;***&#34;</span>) {
</span></span><span style=display:flex><span>                    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Runoff!&#34;</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 在打印平局结果后退出。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这是找到的第一个获得最高票数的候选人。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                ans <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果循环完成且 &#39;ans&#39; 只被更新过一次，则打印获胜者的名字。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=题解>题解<a hidden class=anchor aria-hidden=true href=#题解>#</a></h3><p>这个问题要求我们处理一个投票列表，其中每一票都是一个代表候选人姓名的字符串。我们需要找出得票最多的候选人。如果只有一位候选人得票最高，我们就打印他/她的名字。如果有两位或更多的候选人并列获得最高票数，我们必须宣布“Runoff!
”。投票列表以一个特殊的字符串 <code>***</code> 结尾。</p><p>为了解决这个问题，我们需要一种高效的方式来存储和统计可能非常多的不同候选人的票数。哈希表（或字典）是完成此任务的理想数据结构。在
C++ 中，<code>std::unordered_map</code> 就是哈希表的实现。我们可以将每个候选人的名字（<code>std::string</code>）映射到他们的总票数（一个整数类型，如
<code>unsigned long</code>）。</p><p>整体算法主要分为三个阶段：</p><p>首先，我们读取输入并统计票数。我们逐行遍历输入。对于每一行，也就是一张选票，我们检查它是否是终止符 <code>***</code>
。如果是，我们停止读取。否则，我们用候选人的名字作为 <code>unordered_map</code> 的键，并增加其对应的值。<code>std::unordered_map</code> 的 <code>[]</code>
操作符在这里非常方便：如果键（名字）在哈希表中不存在，它会自动插入并赋予一个默认构造的值（对于整数是0），然后自增操作 <code>++</code>
使其变为1。如果键已经存在，它的值就简单地加一。</p><p>其次，处理完所有选票后，我们需要确定所有候选人中获得的最高票数是多少。我们可以通过遍历哈希表中的所有键值对，并记录下到目前为止看到的最大值（票数）来实现这一点。我们将这个最大值称为
<code>max_vote</code>。</p><p>第三，我们必须确定获胜者或检测是否存在平局。在寻找最大值的同时可靠地完成这项任务仅用一次遍历是不够的。因此，最简单明了的方法是对哈希表进行第二次遍历。在第二次迭代中，我们将每个候选人的票数与上一步中找到的
<code>max_vote</code> 进行比较。我们使用一个字符串变量，比如 <code>winner_name</code>，并将其初始化为一个特殊的哨兵值（例如输入中的 <code>***</code>
，因为它不可能是合法的候选人名字）。当我们找到第一个票数等于 <code>max_vote</code> 的候选人时，我们将其名字存储在 <code>winner_name</code>
中。如果随后我们又遇到了另一位票数也等于 <code>max_vote</code> 的候选人，我们就知道出现了平局。此时，我们可以立即打印 &ldquo;Runoff!&rdquo;
并终止程序。如果第二次循环完成而没有找到第二个票数等于 <code>max_vote</code> 的候选人，那就意味着有唯一的获胜者，其名字已存储在我们的
<code>winner_name</code> 变量中。然后我们打印这个名字。</p><h3 id=复杂度分析>复杂度分析<a hidden class=anchor aria-hidden=true href=#复杂度分析>#</a></h3><p>设 N 为总投票数，C 为独立候选人的人数。设 L 为候选人名字的最大长度。</p><h4 id=时间复杂度>时间复杂度<a hidden class=anchor aria-hidden=true href=#时间复杂度>#</a></h4><p>这个过程可以分解为三个部分。</p><ol><li>读取选票并填充哈希表：我们循环 N 次。在循环内部，<code>std::getline</code> 需要 O(L) 的时间。使用字符串键访问 <code>unordered_map</code>
需要对字符串进行哈希计算，平均情况下需要 O(L) 的时间。因此，这个阶段的平均时间复杂度为 O(N * L)。</li><li>找到最高票数：我们遍历存储在哈希表中的 C 位独立候选人。这需要 O(C) 的时间。</li><li>确定获胜者或平局：我们再次遍历 C 位独立候选人，这也需要 O(C) 的时间。</li></ol><p>总时间复杂度是这些部分的总和：O(N * L + C + C) = O(N * L + C)。由于独立候选人的人数 C 不能超过总投票数 N（即 C ≤
N），复杂度主要由第一阶段决定，最终的平均时间复杂度为 O(N * L)。</p><h4 id=空间复杂度>空间复杂度<a hidden class=anchor aria-hidden=true href=#空间复杂度>#</a></h4><p>主要的内存使用来自 <code>unordered_map</code>。在最坏的情况下，每一票都投给了不同的候选人，这意味着我们将存储 N
个不同的名字。哈希表所需的空间与独立候选人的人数 (C) 以及他们名字长度的总和成正比。在最坏的情况下，这会是 O(N * L)，即我们存储了
N 个平均长度为 L 的名字。因此，空间复杂度为 O(N * L)。</p><h2 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h2><h3 id=问题描述-1>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述-1>#</a></h3><p>Set是一款由Marsha Falco于1974年设计的纸牌游戏，由Set Enterprises,
Inc.公司推广。它也以联合供稿的形式出现在《纽约时报》的网站上。玩家会看到12张牌，每张牌上包含1、2或3个符号。这些符号可以是菱形、波浪形或椭圆形。符号的绘制风格有实心、条纹或空心三种。每个符号的颜色可以是红色、绿色或紫色。在任意一张牌上，所有符号的类型、颜色和填充风格都是相同的。</p><p>要构成一个“Set”，你必须选择三张牌，这三张牌的全部4个特性必须满足“要么全部相同，要么两两不同”的规则。例如，有3张牌，第一张显示2个红色条纹椭圆，第二张显示3个绿色条纹波浪形，第三张显示1个紫色条纹菱形，这就构成了一个“Set”。它们的符号数量分别为2、3和1（每个数量都不同）；形状分别为椭圆、波浪形和菱形（每种形状都不同）；颜色为红色、绿色和紫色（3种不同颜色）；最后，它们都共享相同的填充风格：条纹。</p><p>请编写一个程序，找出给定的12张牌中所有的“Set”！</p><h4 id=输入-1>输入<a hidden class=anchor aria-hidden=true href=#输入-1>#</a></h4><p>你的程序的输入将包括4行，每行包含3个字符串，代表3张牌。每个字符串由四个字符ABCD组成，其中</p><p>A ∈ {1, 2, 3}，对应符号的数量。</p><p>B ∈ {D, S, O}，对应菱形(D)、波浪形(S)和椭圆(O)。</p><p>C ∈ {S, T, O}，对应实心(S)、条纹(T)和空心(O)的填充风格。</p><p>D ∈ {R, G, P}，对应红色(R)、绿色(G)和紫色(P)。</p><p>可以认为输入中的卡牌排列如下：
+&mdash;&mdash;&mdash;-+
| 1 2 3 |
| 4 5 6 |
| 7 8 9 |
| 10 11 12 |
+&mdash;&mdash;&mdash;-+</p><h4 id=输出-1>输出<a hidden class=anchor aria-hidden=true href=#输出-1>#</a></h4><p>输出你找到的所有“Set”，每行一个。对于每个“Set”，按排序顺序输出其中卡牌的编号。所有找到的“Set”应根据其第一张牌的编号进行排序，如果第一张牌编号相同，则按第二张和第三张牌的编号来打破平局。
如果无法构成任何“Set”，则输出“no sets”。</p><h3 id=代码-1>代码<a hidden class=anchor aria-hidden=true href=#代码-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> set {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> ans <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>card</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> f[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>        card(<span style=color:#66d9ef>int</span> id, std<span style=color:#f92672>::</span>string s);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>cardset</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> mask <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cnt             <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>unordered_set<span style=color:#f92672>&lt;</span>card <span style=color:#f92672>*&gt;</span> cards{};
</span></span><span style=display:flex><span>        cardset() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>        cardset(card <span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(card <span style=color:#f92672>*</span>c);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cardset<span style=color:#f92672>::</span>cardset(card <span style=color:#f92672>*</span>c) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.insert(c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> <span style=color:#a6e22e>calc_mask</span>(card <span style=color:#f92672>*</span>c1, card <span style=color:#f92672>*</span>c2) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            mask <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            mask <span style=color:#f92672>|=</span> c1<span style=color:#f92672>-&gt;</span>f[i] <span style=color:#f92672>==</span> c2<span style=color:#f92672>-&gt;</span>f[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mask;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    card<span style=color:#f92672>::</span>card(<span style=color:#66d9ef>int</span> id, std<span style=color:#f92672>::</span>string s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> id;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>istringstream iss(s);
</span></span><span style=display:flex><span>        iss <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>f[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> cardset<span style=color:#f92672>::</span>insert(card <span style=color:#f92672>*</span>c) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>==</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>=</span> calc_mask(c, <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.begin());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards.insert(c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cnt <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>card_ptr: <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>cards) {
</span></span><span style=display:flex><span>                vec.emplace_back(card_ptr<span style=color:#f92672>-&gt;</span>id);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>sort(vec.begin(), vec.end());
</span></span><span style=display:flex><span>            ans.emplace_back(vec);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>fit</span>(card <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>const</span> cardset <span style=color:#f92672>*</span>s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(s<span style=color:#f92672>-&gt;</span>mask <span style=color:#f92672>==</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span>) (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>sc: s<span style=color:#f92672>-&gt;</span>cards) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(calc_mask(sc, c) <span style=color:#f92672>!=</span> s<span style=color:#f92672>-&gt;</span>mask) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(std<span style=color:#f92672>::</span>istream <span style=color:#f92672>&amp;</span>cin, std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        cardset sets[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> sets_cnt          <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string input;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>12</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> input;
</span></span><span style=display:flex><span>            card <span style=color:#f92672>*</span>newcard <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> card(i, input);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> sets_cnt; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(fit(newcard, <span style=color:#f92672>&amp;</span>sets[j])) {
</span></span><span style=display:flex><span>                    cardset newset <span style=color:#f92672>=</span> sets[j];
</span></span><span style=display:flex><span>                    newset.insert(newcard);
</span></span><span style=display:flex><span>                    sets[sets_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> (newset);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            cardset newset   <span style=color:#f92672>=</span> cardset(newcard);
</span></span><span style=display:flex><span>            sets[sets_cnt<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> (newset);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(ans.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;no sets&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>sort(ans.begin(), ans.end(), [](<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>b) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> b[<span style=color:#ae81ff>0</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> b[<span style=color:#ae81ff>1</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> a[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;</span> b[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>s: ans) {
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> s[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=题解-1>题解<a hidden class=anchor aria-hidden=true href=#题解-1>#</a></h3><p>这个问题要求我们从给定的12张卡牌中找出所有有效的“Set”。一个“Set”由三张卡牌组成，对于它们的四个特征中的任何一个，特征值要么是三张牌都完全相同，要么是三张牌两两互不相同。</p><p>这里的C++代码实现了一种构造性或增量式算法来寻找这些“Set”。它不是通过检查所有可能的三张牌组合（暴力方法），而是通过一次添加一张牌来逐步构建潜在的“Set”。</p><p>其核心逻辑巧妙地利用了位掩码（bitmasking）来表示两张卡牌之间的关系。函数 <code>calc_mask(card *c1, card *c2)</code>
生成一个4位的整数。每一位对应四个特征中的一个。如果两张牌在该特征上相同，则该位设置为 <code>1</code>；如果不同，则为 <code>0</code>
。这个“相似性掩码”紧凑地描述了两张牌的相互关系。</p><p>使用这个掩码，三张牌（A, B,
C）构成一个“Set”的规则可以被重新表述为：A和B之间的相似性掩码必须与A和C之间的相似性掩码相同，并且也必须与B和C之间的相似性掩码相同。这确保了每个特征都满足“全部相同或全部不同”的属性。</p><p>主算法的流程如下：</p><p>它从第1张到第12张，逐一处理卡牌。它维护一个数组 <code>sets</code>，用于存储 <code>cardset</code> 对象。一个 <code>cardset</code> 是一个潜在的“Set”，可以包含一张或两张卡牌。</p><p>对于每个新读入的卡牌 <code>newcard</code>：</p><ol><li>它会遍历所有已经创建的 <code>cardset</code> 对象 (<code>sets[j]</code>)。一个 <code>cardset</code> 的大小可以是1（单张牌）或2（一对牌）。</li><li>函数 <code>fit(newcard, &amp;sets[j])</code> 检查 <code>newcard</code> 是否可以有效地添加到现有的 <code>cardset</code> 中。</li><li>如果 <code>sets[j]</code> 只包含一张牌，任何 <code>newcard</code> 都可以“fit”以形成一个对。一个大小为2的新 <code>cardset</code> 会由此创建。它的 <code>mask</code>
成员此时被计算并存储，代表这两张牌之间的相似性。</li><li>如果 <code>sets[j]</code> 包含两张牌，<code>fit</code> 函数会检查 <code>newcard</code> 与 <code>sets[j]</code> 中两张牌的相似性掩码是否都与 <code>sets[j]</code> 中已存储的
<code>mask</code> 相匹配。如果匹配，那么一个有效的三张牌“Set”就找到了。一个大小为3的新 <code>cardset</code> 被创建，其卡牌ID被添加到全局的
<code>ans</code> 向量中。</li><li>在尝试扩展所有现有的 <code>cardset</code> 之后，一个只包含 <code>newcard</code> 的新 <code>cardset</code> 会被创建并添加到列表中。这使得 <code>newcard</code>
能够与后续处理的卡牌开始新的潜在“Set”。</li></ol><p>在所有12张卡牌都处理完毕后，<code>ans</code> 向量就包含了所有找到的“Set”。然后代码检查是否找到了任何“Set”。如果没有，则打印 &ldquo;no sets&rdquo;
。否则，它按照题目要求的字典序对“Set”列表进行排序，并每行打印一个“Set”。</p><h3 id=复杂度分析-1>复杂度分析<a hidden class=anchor aria-hidden=true href=#复杂度分析-1>#</a></h3><p>设 N 为卡牌数量（N=12）。</p><h4 id=时间复杂度-1>时间复杂度<a hidden class=anchor aria-hidden=true href=#时间复杂度-1>#</a></h4><p>外层循环运行 N 次。内层循环遍历 <code>sets_cnt</code>，即已存在的 <code>cardset</code> 的数量。处理完 <code>i</code> 张牌后，大小为1的 <code>cardset</code> 数量为 <code>i</code>
，大小为2的数量为 <code>i*(i-1)/2</code>。因此 <code>sets_cnt</code> 是二次增长的，即 O(i^2)。总工作量大约是从 <code>i=1</code> 到 <code>N-1</code> 对 <code>i^2</code>
求和，这导致时间复杂度为 O(N^3)。对于 N=12，这是非常高效的。</p><h4 id=空间复杂度-1>空间复杂度<a hidden class=anchor aria-hidden=true href=#空间复杂度-1>#</a></h4><p><code>sets</code> 数组存储了所有的 <code>cardset</code> 对象。这些对象的数量是 O(N^2)。每个 <code>cardset</code> 存储指针，所以空间主要由数组本身主导，导致
O(N^2) 的空间复杂度。</p><h2 id=planting-trees>Planting Trees<a hidden class=anchor aria-hidden=true href=#planting-trees>#</a></h2><h3 id=问题描述-2>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述-2>#</a></h3><p>农夫乔恩最近买了n棵树苗，他想把它们种在院子里。乔恩种植一棵树苗需要1天时间，并且对于每棵树，乔恩都确切地知道它在种植后需要多少天才能完全成熟。乔恩还想为他的农夫朋友们举办一个派对，但为了给他们留下深刻印象，他希望只在所有树都长成之后才组织派对。更准确地说，派对最早可以在最后一棵树长成后的第二天举办。</p><p>请帮助乔恩找出可以举办派对的最早日期。乔恩可以随心所欲地选择种植树木的顺序，因此他希望以一种能让派对尽早举行的方式来种植树木。</p><h4 id=输入-2>输入<a hidden class=anchor aria-hidden=true href=#输入-2>#</a></h4><p>输入包含两行。第一行包含一个整数 N (1 ≤ N ≤ 100,000)，表示树苗的数量。接下来的一行是 N 个整数 t_i (1 ≤ t_i ≤ 1,000,000)，其中
t_i 表示第 i 棵树生长所需的天数。</p><h4 id=输出-2>输出<a hidden class=anchor aria-hidden=true href=#输出-2>#</a></h4><p>你的程序应该输出一行，包含一个整数，表示可以组织派对的最早日期。天数从当前时刻开始编号为 1, 2, 3, &mldr;。</p><h3 id=代码-2>代码<a hidden class=anchor aria-hidden=true href=#代码-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> plantingtrees {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(std<span style=color:#f92672>::</span>istream <span style=color:#f92672>&amp;</span>cin, std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>cout) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> n;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec(n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            cin <span style=color:#f92672>&gt;&gt;</span> vec[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将树的生长时间按降序排序。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// rbegin() 和 rend() 迭代器用于反向排序。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>sort(vec.rbegin(), vec.rend());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 按照选定的种植顺序遍历树木。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 位于索引 &#39;i&#39; 的树在第 &#39;i + 1&#39; 天被种植。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 种植日: i + 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 生长时间: vec[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 成熟日: (i + 1) + vec[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 派对必须在所有树成熟后举行，所以我们寻找最晚的成熟日。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 派对在最后一棵树成熟后的第二天举行。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 值 `i + vec[i] + 2` 对应 `(i + 1) + vec[i] + 1`，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 如果这棵树是最后一棵成熟的，这就是最早可能的派对日期。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            ans <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ans, i <span style=color:#f92672>+</span> vec[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=题解-2>题解<a hidden class=anchor aria-hidden=true href=#题解-2>#</a></h3><p>这个问题要求我们找出举办派对的最早可能日期。派对必须在所有种植的树木都成熟后的第二天举行。我们有N棵树苗，并且知道每棵树苗在种植后需要
<code>t_i</code> 天才能成熟。种植一棵树苗需要一天。我们可以决定种植的顺序。目标是找到一个种植顺序，使得最终的派对日期最小化。</p><p>让我们分析一下时间线。如果我们确定了种植顺序，第一棵树在第1天种植，第二棵在第2天，以此类推，序列中的第 <code>i</code> 棵树在第 <code>i</code>
天种植。如果这第 <code>i</code> 棵树的成熟时间是 <code>t_i</code>，它将在第 <code>i + t_i</code> 天完全成熟。派对只能在<em>所有</em>
树木都成熟后举行。这意味着我们需要在所有树中找到最晚的成熟日期。派对可以在这个最晚成熟日期的第二天举行。
因此，对于一个给定的种植序列 <code>p_1, p_2, ..., p_N</code> 及其对应的生长时间 <code>t_{p_1}, t_{p_2}, ..., t_{p_N}</code>，派对日期将是
<code>1 + max(1 + t_{p_1}, 2 + t_{p_2}, ..., N + t_{p_N})</code>。我们的任务是找到树木的一个排序（一个排列 <code>p</code>），以最小化这个值。</p><p>这个问题可以用贪心算法解决。直觉告诉我们，需要较长时间生长的树应该尽早种植。这给了它们漫长成熟期的“领先优势”。相反，生长快的树可以稍后种植，而不会显著推迟最终的完成日期。</p><p>让我们来证明这个贪心策略是最优的。该策略是：将树木按其生长时间 <code>t_i</code> 的降序排序，并按此顺序种植。
考虑任何一个最优的种植计划。如果这个计划不是按生长时间降序排列的，那么在种植序列中，必然至少存在一对相邻的树，比如在第 <code>i</code>
天和第 <code>i+1</code> 天种植的树，其中第 <code>i</code> 天种植的树（称之为树A，生长时间为 <code>t_A</code>）的生长时间比第 <code>i+1</code> 天种植的树（树B，生长时间为
<code>t_B</code>）要短。即 <code>t_A &lt; t_B</code>。</p><p>在这个计划中，这两棵树的成熟日期是：</p><p>树A的成熟日期：<code>i + t_A</code></p><p>树B的成熟日期：<code>(i + 1) + t_B</code></p><p>序列中所有其他的树不受我们对A和B操作的影响。该计划的最晚成熟日期是 <code>max(..., i + t_A, (i + 1) + t_B, ...)</code>。</p><p>现在，让我们交换A和B的种植顺序。我们在第 <code>i</code> 天种植B，第 <code>i+1</code> 天种植A。新的成熟日期是：</p><p>树B的新成熟日期：<code>i + t_B</code></p><p>树A的新成熟日期：<code>(i + 1) + t_A</code></p><p>让我们比较交换前后这对树的最晚成熟日期。
交换前，最晚的是 <code>max(i + t_A, i + 1 + t_B)</code>。因为 <code>t_A &lt; t_B</code>，所以 <code>t_A &lt;= t_B - 1</code>。
因此，<code>i + t_A &lt; i + t_B - 1 &lt; i + 1 + t_B</code>。最大值是 <code>i + 1 + t_B</code>。
交换后，最晚的是 <code>max(i + t_B, i + 1 + t_A)</code>。
因为 <code>t_A &lt; t_B</code>，所以 <code>i + 1 + t_A &lt; i + 1 + t_B</code>。并且如果 <code>t_B - t_A > 1</code>，<code>i + t_B</code> 也大于 <code>i + 1 + t_A</code>。无论如何，最大值是
<code>i + t_B</code>。</p><p>比较最大值：<code>(i + t_B)</code> (交换后) vs. <code>(i + 1 + t_B)</code> (交换前)。
很明显，<code>i + t_B &lt; i + 1 + t_B</code>。交换减少了这对树的最晚成熟日期。由于所有其他树的成熟日期保持不变，整个计划的总体最晚成熟日期只能减少或保持不变，不可能增加。
这个“交换论证”表明，我们总是可以通过将生长时间较长的树提前来改进或维持一个未排序的计划。通过反复应用这个逻辑，我们可以将任何最优计划转换为一个按生长时间降序排列的计划，而不会使结果变差。因此，优先种植生长时间长的树的贪心策略确实是最优的。</p><p>实现很简单：</p><ol><li>读取N和所有的生长时间 <code>t_i</code> 到一个向量中。</li><li>将向量按降序排序。</li><li>初始化一个变量 <code>max_party_day</code> 为0。</li><li>从 <code>i = 0</code> 到 <code>N-1</code> 遍历排序后的向量。树 <code>t_i</code> 在第 <code>i+1</code> 天种植。它的成熟日期是 <code>(i+1) + t_i</code>。考虑到这棵树，最早的派对日期是
<code>(i+1) + t_i + 1</code>。我们用 <code>max_party_day</code> 的当前值和这个新计算出的日期的最大值来更新它。</li><li>循环结束后，<code>max_party_day</code> 将持有最终答案。</li></ol><h3 id=复杂度分析-2>复杂度分析<a hidden class=anchor aria-hidden=true href=#复杂度分析-2>#</a></h3><p>设N为树苗的数量。</p><h4 id=时间复杂度-2>时间复杂度<a hidden class=anchor aria-hidden=true href=#时间复杂度-2>#</a></h4><p>主要的操作是对生长时间进行排序。标准排序算法需要 O(N log N) 的时间。读取输入需要 O(N) 的时间，最后的循环计算最大派对日期也需要
O(N) 的时间。因此，总时间复杂度为 O(N log N)。</p><h4 id=空间复杂度-2>空间复杂度<a hidden class=anchor aria-hidden=true href=#空间复杂度-2>#</a></h4><p>我们需要将N个生长时间存储在一个向量中，这需要 O(N) 的空间。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tategotoazarasi.github.io/zh/tags/recount-problem-solution/>Recount-Problem-Solution</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/set-card-game-solver/>Set-Card-Game-Solver</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/planting-trees-problem-solution/>Planting-Trees-Problem-Solution</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/competitive-programming/>Competitive-Programming</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/c-plus-plus/>C-Plus-Plus</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/algorithm-tutorial/>Algorithm-Tutorial</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/bilingual-guide/>Bilingual-Guide</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/greedy-algorithm/>Greedy-Algorithm</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/brute-force-search/>Brute-Force-Search</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/hash-map-example/>Hash-Map-Example</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/vote-counting-algorithm/>Vote-Counting-Algorithm</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/combinatorial-game-programming/>Combinatorial-Game-Programming</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/scheduling-optimization/>Scheduling-Optimization</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/time-complexity-analysis/>Time-Complexity-Analysis</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/space-complexity/>Space-Complexity</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/exchange-argument-proof/>Exchange-Argument-Proof</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/coding-challenges/>Coding-Challenges</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/problem-solving-guide/>Problem-Solving-Guide</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/chinese-english-programming-tutorial/>Chinese-English-Programming-Tutorial</a></li><li><a href=https://tategotoazarasi.github.io/zh/tags/c-plus-plus-code-explanation/>C-Plus-Plus-Code-Explanation</a></li></ul><nav class=paginav><a class=next href=https://tategotoazarasi.github.io/zh/posts/discovering-a-catastrophic-rm-rf-bug-in-debtap/><span class=title>下一页 »</span><br><span>发现 debtap 中一个“删库跑路”级 Bug</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tategotoazarasi.github.io/zh/>Tategoto Azarasi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>